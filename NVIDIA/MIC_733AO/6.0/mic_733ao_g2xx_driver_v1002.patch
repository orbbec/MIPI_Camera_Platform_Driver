 .../t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi |    4 +-
 .../nvidia/t23x/nv-public/overlay/Makefile         |    1 +
 .../overlay/tegra234-camera-g2xx-overlay.dts       | 1638 ++++++++
 .../kernel-jammy-src/arch/arm64/configs/defconfig  |    8 +
 .../drivers/media/usb/uvc/uvc_ctrl.c               |    1 +
 .../drivers/media/usb/uvc/uvc_driver.c             |  336 ++
 .../drivers/media/usb/uvc/uvcvideo.h               |   36 +-
 .../drivers/media/v4l2-core/v4l2-ioctl.c           |   11 +
 .../kernel/kernel-jammy-src/drivers/of/address.c   |   13 +-
 .../include/uapi/linux/media-bus-format.h          |    1 +
 .../include/uapi/linux/videodev2.h                 |   19 +
 kernel/nvidia-oot/drivers/media/i2c/Makefile       |    3 +
 kernel/nvidia-oot/drivers/media/i2c/g2xx.c         | 4156 ++++++++++++++++++++
 kernel/nvidia-oot/drivers/media/i2c/max9295.c      |  381 +-
 kernel/nvidia-oot/drivers/media/i2c/max9296.c      |  435 +-
 .../tegra/camera/fusa-capture/capture-vi.c         |    4 +-
 .../media/platform/tegra/camera/sensor_common.c    |    4 +
 .../media/platform/tegra/camera/vi/channel.c       |  402 +-
 .../drivers/media/platform/tegra/camera/vi/graph.c |   38 +-
 .../media/platform/tegra/camera/vi/mc_common.c     |   27 +
 .../media/platform/tegra/camera/vi/vi5_fops.c      |   73 +-
 .../media/platform/tegra/camera/vi/vi5_formats.h   |   61 +-
 .../platform/tegra/rtcpu/capture-ivc-priv.h        |    1 +
 .../drivers/platform/tegra/rtcpu/capture-ivc.c     |   12 +
 kernel/nvidia-oot/include/media/gmsl-link.h        |    7 +
 kernel/nvidia-oot/include/media/max9295.h          |   11 +
 kernel/nvidia-oot/include/media/max9296.h          |   14 +
 kernel/nvidia-oot/include/media/mc_common.h        |   22 +
 .../nvidia-oot/include/media/tegra_camera_core.h   |   10 +-
 29 files changed, 7603 insertions(+), 126 deletions(-)

diff --git a/kernel/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi b/kernel/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi
index 52cbe5141..5e9e67422 100644
--- a/kernel/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi
+++ b/kernel/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi
@@ -28,7 +28,7 @@
 				iommus = <&smmu_iso TEGRA234_SID_ISO_VI>;
 				interconnects = <&mc TEGRA234_MEMORY_CLIENT_VIW &emc>;
 				interconnect-names = "write";
-				non-coherent;
+				dma-noncoherent;
 				status = "okay";
 			};
 
@@ -52,7 +52,7 @@
 				iommus = <&smmu_iso TEGRA234_SID_ISO_VI2>;
 				interconnects = <&mc TEGRA234_MEMORY_CLIENT_VI2W &emc>;
 				interconnect-names = "write";
-				non-coherent;
+				dma-noncoherent;
 				status = "okay";
 			};
 
diff --git a/kernel/hardware/nvidia/t23x/nv-public/overlay/Makefile b/kernel/hardware/nvidia/t23x/nv-public/overlay/Makefile
index c88bbe207..2a51ab30e 100644
--- a/kernel/hardware/nvidia/t23x/nv-public/overlay/Makefile
+++ b/kernel/hardware/nvidia/t23x/nv-public/overlay/Makefile
@@ -60,6 +60,7 @@ dtbo-y += tegra234-p3767-camera-p3768-imx219-A.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx219-imx477.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx477-C.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx477-A.dtbo
+dtbo-y += tegra234-camera-g2xx-overlay.dtbo  # orbbec modify
 
 ifneq ($(dtb-y),)
 dtb-y := $(addprefix $(makefile-path)/,$(dtb-y))
diff --git a/kernel/hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-g2xx-overlay.dts b/kernel/hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-g2xx-overlay.dts
new file mode 100644
index 000000000..aaf186cf0
--- /dev/null
+++ b/kernel/hardware/nvidia/t23x/nv-public/overlay/tegra234-camera-g2xx-overlay.dts
@@ -0,0 +1,1638 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2018-2023, INTEL CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
+
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson AGX CSI Connector";
+    compatible = JETSON_COMPATIBLE;
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <16>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						status = "okay";
+						g2xx_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "okay";
+						g2xx_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <2>;
+						status = "okay";
+						g2xx_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <3>;
+						status = "okay";
+						g2xx_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <4>;
+						status = "okay";
+						g2xx_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <5>;
+						status = "okay";
+						g2xx_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <6>;
+						status = "okay";
+						g2xx_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <7>;
+						status = "okay";
+						g2xx_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <8>;
+						status = "okay";
+						g2xx_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <9>;
+						status = "okay";
+						g2xx_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out9>;
+						};
+					};
+					port@10 {
+						reg = <10>;
+						status = "okay";
+						g2xx_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out10>;
+						};
+					};
+					port@11 {
+						reg = <11>;
+						status = "okay";
+						g2xx_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out11>;
+						};
+					};
+
+					port@12 {
+						reg = <12>;
+						status = "okay";
+						g2xx_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out12>;
+						};
+					};
+					port@13 {
+						reg = <13>;
+						status = "okay";
+						g2xx_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out13>;
+						};
+					};
+					port@14 {
+						reg = <14>;
+						status = "okay";
+						g2xx_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out14>;
+						};
+					};
+					port@15 {
+						reg = <15>;
+						status = "okay";
+						g2xx_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g2xx_csi_out15>;
+						};
+					};
+
+				};
+			};
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <16>;
+
+						channel@0 {
+							reg = <0>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <1>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <2>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <3>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in3>;
+									};
+								};
+							};
+						};
+
+						channel@4 {
+							reg = <4>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <5>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <6>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <7>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in7>;
+									};
+								};
+							};
+						};
+
+						channel@8 {
+							reg = <8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@10 {
+							reg = <10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in11>;
+									};
+								};
+							};
+						};
+
+						channel@12 {
+							reg = <12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@14 {
+							reg = <14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g2xx_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g2xx_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g2xx_vi_in15>;
+									};
+								};
+							};
+						};
+					};
+				};
+				i2c@3180000 {
+					status = "okay";
+					clock-frequency = <400000>;
+
+					gpio_exp0: tca9554@21 {
+						compatible = "ti,tca9554";
+						reg = <0x21>;
+						gpio-controller;
+						vcc-supply = <&vdd_1v8_ls>;
+						#gpio-cells = <2>;
+
+						gmsla-pwdn-hog {
+							gpio-hog;
+							gpios = <0 GPIO_ACTIVE_HIGH>;
+							output-high;
+							line-name = "gmsla-pwdn";
+						};
+
+						gmslb-pwdn-hog {
+							gpio-hog;
+							gpios = <1 GPIO_ACTIVE_HIGH>;
+							output-high;
+							line-name = "gmslb-pwdn";
+						};
+
+						poc-en-hog {
+							gpio-hog;
+							gpios = <2 GPIO_ACTIVE_HIGH>;
+							output-high;
+							line-name = "poc-en";
+						};
+					};
+
+					tca9546@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "nxp,pca9546";
+						#address-cells = <1>;
+						#size-cells = <0>;
+						skip_mux_detect = "yes";
+						vcc-supply = <&vdd_1v8_ls>;
+						/*vcc-pullup-supply = <&battery_reg>;*/
+						force_bus_start = <CAMERA_I2C_MUX_BUS(0)>;
+						vcc_lp = "vcc";
+						i2c@0 {
+							reg = <0>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m1_3: g2m3@6D {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6D>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								cam-type = "IR_R";
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-ser-device = <&ser0_b>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_3_out: endpoint {
+											vc-id = <1>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in7>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+								gmsl-link {
+									src-csi-port = "b"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <3>;
+									vc-id = <1>;
+									num-lanes = <4>;
+								};
+							};
+							g2m1_2: g2m2@6C {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6C>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-ser-device = <&ser0_b>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_2_out: endpoint {
+											vc-id = <0>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in6>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+								gmsl-link {
+									src-csi-port = "a"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <2>;
+									vc-id = <0>;
+									num-lanes = <4>;
+								};
+							};
+							g2m1_1: g2m1@6B {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6B>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-ser-device = <&ser0_b>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_1_out: endpoint {
+											vc-id = <3>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in5>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+								gmsl-link {
+									src-csi-port = "b"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <1>;
+									vc-id = <3>;
+									num-lanes = <4>;
+								};
+							};
+							g2m1_0: g2m0@6A {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6A>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-ser-device = <&ser0_b>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_0_out: endpoint {
+											vc-id = <2>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in4>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+								gmsl-link {
+									src-csi-port = "a"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <0>;
+									vc-id = <2>;
+									num-lanes = <4>;
+								};
+							};
+
+							/* IR_R */
+							g2m0_3: g2m3@69 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x69>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-ser-device = <&ser0_a>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <0>; //0
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in3>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+								gmsl-link {
+									src-csi-port = "b"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "a";
+									csi-mode = "1x4";
+									st-vc = <3>;
+									vc-id = <3>;
+									num-lanes = <4>;
+								};
+							};
+							/* IR_L */
+							g2m0_2: g2m2@68 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x68>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-ser-device = <&ser0_a>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in2>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+								gmsl-link {
+									src-csi-port = "a"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "a";
+									csi-mode = "1x4";
+									st-vc = <2>;
+									vc-id = <2>;
+									num-lanes = <4>;
+								};
+							};
+							/* RGB */
+							g2m0_1: g2m1@67 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x67>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-ser-device = <&ser0_a>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in1>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "1";
+								};
+								gmsl-link {
+									src-csi-port = "b"; //a = depth + ir_l, b = rgb + ir_r
+									dst-csi-port = "a";
+									serdes-csi-link = "a";
+									csi-mode = "1x4";
+									st-vc = <1>;
+									vc-id = <1>;
+									num-lanes = <4>;
+								};
+							};
+							/* Depth */
+							g2m0_0: g2m0@66 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x66>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-ser-device = <&ser0_a>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in0>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "0";
+								};
+								gmsl-link {
+									/* a = depth + ir_l, b = rgb + ir_r */
+									src-csi-port = "a";  		/**< Sensor to serializer CSI port connection. */
+									dst-csi-port = "a";			/**< Deserializer to Jetson CSI port connection. */
+									serdes-csi-link = "a";		/**< GMSL link between serializer and deserializer devices. */
+									csi-mode = "1x4";			/**< Deserializer CSI mode. */
+									st-vc = <0>;   				/**< Default sensor virtual channel. */
+									vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+									num-lanes = <4>;			/**< Sensor's CSI lane configuration. */
+								};
+							};
+							
+							ser0_a: max9295_a@42 {
+								status = "okay";
+								compatible = "maxim,max9295";
+								reg = <0x42>;
+								ser-prim-device = <&ser_prim0>;
+								maxim,gmsl-dser-device = <&dser0>;
+							};
+
+							ser0_b: max9295_b@60 {
+								status = "okay";
+								compatible = "maxim,max9295";
+								reg = <0x60>;
+								ser-prim-device = <&ser_prim0>;
+								maxim,gmsl-dser-device = <&dser0>;
+							};
+
+							ser_prim0: max9295_prim@40 {
+								status = "okay";
+								reg = <0x40>;
+								compatible = "maxim,max9295";
+								is-prim-ser;
+							};
+								
+							dser0: max9296@48 {
+								status = "okay";
+								reg = <0x48>;
+								compatible = "maxim,max9296";
+								csi-mode = "2x4";
+								max-src = <2>;
+								reset-gpios = <&gpio_exp0 0 GPIO_ACTIVE_HIGH>;
+							};
+						};
+						i2c@1 {
+							status = "okay";
+							reg = <1>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m3_3: g2m3@6D {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6D>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-ser-device = <&ser1_b>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_3_out: endpoint {
+											vc-id = <1>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in15>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+								gmsl-link {
+									src-csi-port = "b";
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <3>;
+									vc-id = <1>;
+									num-lanes = <4>;
+								};
+							};
+							g2m3_2: g2m2@6C {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6C>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-ser-device = <&ser1_b>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_2_out: endpoint {
+											vc-id = <0>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in14>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+								gmsl-link {
+									src-csi-port = "a";
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <2>;
+									vc-id = <0>;
+									num-lanes = <4>;
+								};
+							};
+							g2m3_1: g2m1@6B {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6B>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-ser-device = <&ser1_b>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_1_out: endpoint {
+											vc-id = <3>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in13>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "3";
+								};
+								gmsl-link {
+									src-csi-port = "b";
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <1>;
+									vc-id = <3>;
+									num-lanes = <4>;
+								};
+							};
+							g2m3_0: g2m0@6A {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x6A>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-ser-device = <&ser1_b>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_0_out: endpoint {
+											vc-id = <2>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in12>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "2";
+								};
+								gmsl-link {
+									src-csi-port = "a";
+									dst-csi-port = "a";
+									serdes-csi-link = "b";
+									csi-mode = "1x4";
+									st-vc = <0>;
+									vc-id = <2>;
+									num-lanes = <4>;
+								};
+							};
+							
+							g2m2_3: g2m3@69 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x69>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-ser-device = <&ser1_a>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in11>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+								gmsl-link {
+									src-csi-port = "b";
+									dst-csi-port = "a";
+									serdes-csi-link = "a";
+									csi-mode = "1x4";
+									st-vc = <3>;
+									vc-id = <3>;
+									num-lanes = <4>;
+								};
+							};
+							g2m2_2: g2m2@68 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x68>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-ser-device = <&ser1_a>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in10>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";
+									serdes_pix_clk_hz = "750000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+								gmsl-link {
+									src-csi-port = "a";
+									dst-csi-port = "a";
+									serdes-csi-link = "a";
+									csi-mode = "1x4";
+									st-vc = <2>;
+									vc-id = <2>;
+									num-lanes = <4>;
+								};
+							};
+							g2m2_1: g2m1@67 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x67>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-ser-device = <&ser1_a>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in9>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+								gmsl-link {
+									src-csi-port = "b";
+									dst-csi-port = "a";
+									serdes-csi-link = "a";
+									csi-mode = "1x4";
+									st-vc = <1>;
+									vc-id = <1>;
+									num-lanes = <4>;
+								};
+							};
+							g2m2_0: g2m0@66 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x66>;
+								compatible = "orbbec,g2xx";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-ser-device = <&ser1_a>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g2xx_csi_in8>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";
+									serdes_pix_clk_hz = "375000000";
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+								gmsl-link {
+									src-csi-port = "a";  		/**< Sensor to serializer CSI port connection. */
+									dst-csi-port = "a";			/**< Deserializer to Jetson CSI port connection. */
+									serdes-csi-link = "a";		/**< GMSL link between serializer and deserializer devices. */
+									csi-mode = "1x4";			/**< Deserializer CSI mode. */
+									st-vc = <0>;   				/**< Default sensor virtual channel. */
+									vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+									num-lanes = <4>;			/**< Sensor's CSI lane configuration. */
+								};
+							};
+
+							ser1_a: max9295_a@42 {
+								status = "okay";
+								compatible = "maxim,max9295";
+								reg = <0x42>;
+								ser-prim-device = <&ser_prim1>;
+								maxim,gmsl-dser-device = <&dser1>;
+							};
+
+							ser1_b: max9295_b@60 {
+								status = "okay";
+								compatible = "maxim,max9295";
+								reg = <0x60>;
+								ser-prim-device = <&ser_prim1>;
+								maxim,gmsl-dser-device = <&dser1>;
+							};
+
+							ser_prim1: max9295_prim@40 {
+								status = "okay";
+								reg = <0x40>;
+								compatible = "maxim,max9295";
+								is-prim-ser;
+							};
+
+							dser1: max9296@48 {
+								status = "okay";
+								reg = <0x48>;
+								compatible = "maxim,max9296";
+								csi-mode = "2x4";
+								max-src = <2>;
+								reset-gpios = <&gpio_exp0 1 GPIO_ACTIVE_HIGH>;
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/kernel/kernel/kernel-jammy-src/arch/arm64/configs/defconfig b/kernel/kernel/kernel-jammy-src/arch/arm64/configs/defconfig
index af0fd8777..4d540128b 100644
--- a/kernel/kernel/kernel-jammy-src/arch/arm64/configs/defconfig
+++ b/kernel/kernel/kernel-jammy-src/arch/arm64/configs/defconfig
@@ -862,8 +862,12 @@ CONFIG_SND_SOC_LPASS_WSA_MACRO=m
 CONFIG_SND_SOC_LPASS_VA_MACRO=m
 CONFIG_SND_SIMPLE_CARD=m
 CONFIG_SND_AUDIO_GRAPH_CARD=m
+CONFIG_HID=y
 CONFIG_HIDRAW=y
+CONFIG_HID_GENERIC=y
 CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_SENSOR_HUB=y
+CONFIG_USB_HID=y
 CONFIG_I2C_HID_ACPI=m
 CONFIG_I2C_HID_OF=m
 CONFIG_USB=y
@@ -1148,6 +1152,7 @@ CONFIG_EXTCON_USB_GPIO=y
 CONFIG_EXTCON_USBC_CROS_EC=y
 CONFIG_RENESAS_RPCIF=m
 CONFIG_IIO=y
+CONFIG_HID_SENSOR_ACCEL_3D=y
 CONFIG_EXYNOS_ADC=y
 CONFIG_MAX9611=m
 CONFIG_QCOM_SPMI_VADC=m
@@ -1155,6 +1160,9 @@ CONFIG_QCOM_SPMI_ADC5=m
 CONFIG_ROCKCHIP_SARADC=m
 CONFIG_IIO_CROS_EC_SENSORS_CORE=m
 CONFIG_IIO_CROS_EC_SENSORS=m
+CONFIG_HID_SENSOR_IIO_COMMON=y
+CONFIG_HID_SENSOR_IIO_TRIGGER=y
+CONFIG_HID_SENSOR_GYRO_3D=y
 CONFIG_IIO_ST_LSM6DSX=m
 CONFIG_IIO_CROS_EC_LIGHT_PROX=m
 CONFIG_SENSORS_ISL29018=m
diff --git a/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_ctrl.c b/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_ctrl.c
index 05335866e..cba8ceef4 100644
--- a/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_ctrl.c
@@ -367,6 +367,7 @@ static const struct uvc_menu_info power_line_frequency_controls[] = {
 	{ 0, "Disabled" },
 	{ 1, "50 Hz" },
 	{ 2, "60 Hz" },
+	{ 3, "Auto" },
 };
 
 static const struct uvc_menu_info exposure_auto_controls[] = {
diff --git a/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_driver.c b/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_driver.c
index b19c75a6f..273b95cdc 100644
--- a/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_driver.c
+++ b/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvc_driver.c
@@ -165,6 +165,11 @@ static struct uvc_format_desc uvc_fmts[] = {
 		.guid		= UVC_GUID_FORMAT_Y12I,
 		.fcc		= V4L2_PIX_FMT_Y12I,
 	},
+	{
+		.name		= "Greyscale 16 L/R (Y16I)",
+		.guid		= UVC_GUID_FORMAT_Y16I,
+		.fcc		= V4L2_PIX_FMT_Y16I,
+	},
 	{
 		.name		= "Depth data 16-bit (Z16)",
 		.guid		= UVC_GUID_FORMAT_Z16,
@@ -220,6 +225,58 @@ static struct uvc_format_desc uvc_fmts[] = {
 		.guid		= UVC_GUID_FORMAT_HEVC,
 		.fcc		= V4L2_PIX_FMT_HEVC,
 	},
+	{
+		.name		= "Depth data 16-bit (D16)",
+		.guid		= UVC_GUID_FORMAT_D16,
+		.fcc		= V4L2_PIX_FMT_Z16,
+	},
+	{
+		.name		= "Packed raw data 10-bit",
+		.guid		= UVC_GUID_FORMAT_W10,
+		.fcc		= V4L2_PIX_FMT_W10,
+	},
+	{
+		.name		= "Confidence data (C   )",
+		.guid		= UVC_GUID_FORMAT_CONFIDENCE_MAP,
+		.fcc		= V4L2_PIX_FMT_CONFIDENCE_MAP,
+	},
+	/* FishEye 8-bit monochrome */
+	{
+		.name		= "Raw data 8-bit (RAW8)",
+		.guid		= UVC_GUID_FORMAT_RAW8,
+		.fcc		= V4L2_PIX_FMT_GREY,
+	},
+	/* Legacy formats for backward-compatibility*/
+	{
+		.name		= "Raw data 16-bit (RW16)",
+		.guid		= UVC_GUID_FORMAT_RW16,
+		.fcc		= V4L2_PIX_FMT_RW16,
+	},
+	{
+		.name		= "16-bit Bayer BGBG/GRGR",
+		.guid		= UVC_GUID_FORMAT_BAYER16,
+		.fcc		= V4L2_PIX_FMT_SBGGR16,
+	},
+	{
+		.name		= "Z16 Huffman Compression",
+		.guid		= UVC_GUID_FORMAT_Z16H,
+		.fcc		= V4L2_PIX_FMT_Z16H,
+	},
+	{
+		.name		= "Frame Grabber (FG  )",
+		.guid		= UVC_GUID_FORMAT_FG,
+		.fcc		= V4L2_PIX_FMT_FG,
+	},
+	{
+		.name		= "SR300 Depth/Confidence (INZC)",
+		.guid		= UVC_GUID_FORMAT_INZC,
+		.fcc		= V4L2_PIX_FMT_INZC,
+	},
+	{
+		.name		= "Relative IR (PAIR)",
+		.guid		= UVC_GUID_FORMAT_PAIR,
+		.fcc		= V4L2_PIX_FMT_PAIR,
+	},
 };
 
 /* ------------------------------------------------------------------------
@@ -3158,6 +3215,285 @@ static const struct usb_device_id uvc_ids[] = {
 	  .bInterfaceSubClass	= 1,
 	  .bInterfaceProtocol	= 0,
 	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel SR306 depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0aa3,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel SR300 depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0aa5,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	/* Intel D400/PSR depth camera*/
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0ad1,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D410/ASR depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0ad2,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D415/ASRC depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0ad3,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D430/AWG depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0ad4,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	/* Intel D450/AWGT depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0ad5,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	/* USB2 Descriptor, Depth Sensor */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0ad6,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D400 IMU Module */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0af2,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	/* Intel D420/PWG depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0af6,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	/* Intel D420_MM/PWGT depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0afe,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D410_MM/ASRT depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0aff,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D400_MM/PSRT depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b00,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D430_MM/AWGCT depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b01,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D460/DS5U depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b03,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D435/AWGC depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b07,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D405 S depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b0c,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel L500 depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b0d,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D435i depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b3a,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel L515 Pre-PRQ */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b3d,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel SR305 Depth Camera*/
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b48,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D416 Depth Camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b49,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D430i depth camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b4b,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D465 */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b4d,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	/* Intel D555e Depth Camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor		= 0x8086,
+	  .idProduct		= 0x0b56,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= UVC_PC_PROTOCOL_15,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D405 */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b5b,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D455 */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b5c,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel L515 */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b64,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel L535 */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b68,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel D585 Depth Camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b6a,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= UVC_PC_PROTOCOL_15,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+	  /* Intel 585 Camera */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor			= 0x8086,
+	  .idProduct		= 0x0b6b,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= UVC_PC_PROTOCOL_15,
+	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
 	/* Generic USB Video Class */
 	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_UNDEFINED) },
 	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_15) },
diff --git a/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvcvideo.h b/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvcvideo.h
index 1aa2cc985..0b7067c1d 100644
--- a/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvcvideo.h
+++ b/kernel/kernel/kernel-jammy-src/drivers/media/usb/uvc/uvcvideo.h
@@ -145,6 +145,9 @@
 #define UVC_GUID_FORMAT_Y12I \
 	{ 'Y',  '1',  '2',  'I', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+#define UVC_GUID_FORMAT_Y16I \
+	{ 'Y',  '1',  '6',  'I', 0x00, 0x00, 0x10, 0x00, \
+	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 #define UVC_GUID_FORMAT_Z16 \
 	{ 'Z',  '1',  '6',  ' ', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
@@ -175,6 +178,37 @@
 	{ 'H',  'E',  'V',  'C', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 
+	#define UVC_GUID_FORMAT_D16 \
+	{ 'P', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
+		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+	#define UVC_GUID_FORMAT_W10 \
+	{ 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
+		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+	#define UVC_GUID_FORMAT_RAW8 \
+	{ 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
+		0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
+	#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
+	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
+		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+	/* Legacy formats */
+	#define UVC_GUID_FORMAT_RW16 \
+	{ 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
+		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+	#define UVC_GUID_FORMAT_BAYER16 \
+	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
+		0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
+	#define UVC_GUID_FORMAT_Z16H \
+	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
+	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+	#define UVC_GUID_FORMAT_FG \
+	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+	#define UVC_GUID_FORMAT_INZC \
+	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
+	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
+	#define UVC_GUID_FORMAT_PAIR \
+	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
+	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
 
 /* ------------------------------------------------------------------------
  * Driver specific constants.
@@ -187,7 +221,7 @@
 /* Maximum number of packets per URB. */
 #define UVC_MAX_PACKETS		32
 /* Maximum status buffer size in bytes of interrupt URB. */
-#define UVC_MAX_STATUS_SIZE	16
+#define UVC_MAX_STATUS_SIZE	32
 
 #define UVC_CTRL_CONTROL_TIMEOUT	5000
 #define UVC_CTRL_STREAMING_TIMEOUT	5000
diff --git a/kernel/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c b/kernel/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c
index 8375f9127..df6094919 100644
--- a/kernel/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/kernel/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1258,6 +1258,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_GREY:		descr = "8-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y4:		descr = "4-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y6:		descr = "6-bit Greyscale"; break;
+	case V4L2_PIX_FMT_Y8:       descr = "Y8-bit Greyscale"; break; //orbbec add
 	case V4L2_PIX_FMT_Y10:		descr = "10-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y12:		descr = "12-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y14:		descr = "14-bit Greyscale"; break;
@@ -1267,6 +1268,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_Y10P:		descr = "10-bit Greyscale (MIPI Packed)"; break;
 	case V4L2_PIX_FMT_Y8I:		descr = "Interleaved 8-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y12I:		descr = "Interleaved 12-bit Greyscale"; break;
+	case V4L2_PIX_FMT_Y16I:		descr = "Interleaved 16-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Z16:		descr = "16-bit Depth"; break;
 	case V4L2_PIX_FMT_INZI:		descr = "Planar 10:16 Greyscale Depth"; break;
 	case V4L2_PIX_FMT_CNF4:		descr = "4-bit Depth Confidence (Packed)"; break;
@@ -1396,9 +1398,18 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_META_FMT_VSP1_HGT:	descr = "R-Car VSP1 2-D Histogram"; break;
 	case V4L2_META_FMT_UVC:		descr = "UVC Payload Header Metadata"; break;
 	case V4L2_META_FMT_D4XX:	descr = "Intel D4xx UVC Metadata"; break;
+	case V4L2_META_FMT_G2XX:	descr = "Orbbec G2xx UVC Metadata"; break; //orbbec modify
 	case V4L2_META_FMT_VIVID:       descr = "Vivid Metadata"; break;
 	case V4L2_META_FMT_RK_ISP1_PARAMS:	descr = "Rockchip ISP1 3A Parameters"; break;
 	case V4L2_META_FMT_RK_ISP1_STAT_3A:	descr = "Rockchip ISP1 3A Statistics"; break;
+	/* Librealsense formats*/
+	case V4L2_PIX_FMT_RW16:		descr = "16-bit Raw data"; break;
+	case V4L2_PIX_FMT_W10:		descr = "10-bit packed 8888[2222]"; break;
+	case V4L2_PIX_FMT_CONFIDENCE_MAP:	descr = "Packed [44] confidence data"; break;
+	case V4L2_PIX_FMT_FG:		descr = "Frame Grabber (FG  )"; break;
+	case V4L2_PIX_FMT_INZC:		descr = "Planar Depth/Confidence (INZC)"; break;
+	case V4L2_PIX_FMT_PAIR:		descr = "Relative IR (PAIR)"; break;
+	case V4L2_PIX_FMT_Z16H:		descr = "Z16 Huffman Compression"; break;
 
 	default:
 		/* Compressed formats */
diff --git a/kernel/kernel/kernel-jammy-src/drivers/of/address.c b/kernel/kernel/kernel-jammy-src/drivers/of/address.c
index 4b0c036ec..b921f8306 100644
--- a/kernel/kernel/kernel-jammy-src/drivers/of/address.c
+++ b/kernel/kernel/kernel-jammy-src/drivers/of/address.c
@@ -1101,20 +1101,23 @@ bool of_dma_is_coherent(struct device_node *np)
 {
 	struct device_node *node;
 
-	if (IS_ENABLED(CONFIG_OF_DMA_DEFAULT_COHERENT))
-		return true;
+	bool is_coherent = IS_ENABLED(CONFIG_OF_DMA_DEFAULT_COHERENT);
 
 	node = of_node_get(np);
 
 	while (node) {
 		if (of_property_read_bool(node, "dma-coherent")) {
-			of_node_put(node);
-			return true;
+			is_coherent = true;
+			break;
+		}
+		if (of_property_read_bool(node, "dma-noncoherent")) {
+			is_coherent = false;
+			break;
 		}
 		node = of_get_next_dma_parent(node);
 	}
 	of_node_put(node);
-	return false;
+	return is_coherent;
 }
 EXPORT_SYMBOL_GPL(of_dma_is_coherent);
 
diff --git a/kernel/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h b/kernel/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h
index df6b711b2..02d0db3c1 100644
--- a/kernel/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h
+++ b/kernel/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h
@@ -88,6 +88,7 @@
 #define MEDIA_BUS_FMT_YUYV12_2X12		0x201e
 #define MEDIA_BUS_FMT_YVYU12_2X12		0x201f
 #define MEDIA_BUS_FMT_Y14_1X14			0x202d
+#define MEDIA_BUS_FMT_Y16_1X16			0x2033 //orbbec add
 #define MEDIA_BUS_FMT_UYVY8_1X16		0x200f
 #define MEDIA_BUS_FMT_VYUY8_1X16		0x2010
 #define MEDIA_BUS_FMT_YUYV8_1X16		0x2011
diff --git a/kernel/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h b/kernel/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h
index e6de9926c..efd67975d 100644
--- a/kernel/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h
+++ b/kernel/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h
@@ -734,14 +734,32 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_JPGL	v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
 #define V4L2_PIX_FMT_SE401      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
 #define V4L2_PIX_FMT_S5C_UYVY_JPG v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
+//Orbbec add
+#define V4L2_PIX_FMT_Y8       v4l2_fourcc('Y', '8', ' ', ' ') /* Greyscale 8-bit */
 #define V4L2_PIX_FMT_Y8I      v4l2_fourcc('Y', '8', 'I', ' ') /* Greyscale 8-bit L/R interleaved */
 #define V4L2_PIX_FMT_Y12I     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
+#define V4L2_PIX_FMT_Y16I     v4l2_fourcc('Y', '1', '6', 'I') /* Greyscale 16-bit L/R interleaved */
 #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
 #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
 #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
+
+#if 1 //orbbec add
+#define V4L2_PIX_FMT_INVR     v4l2_fourcc('I', 'N', 'V', 'R') /* 16 Depth */
+#define V4L2_PIX_FMT_INRI     v4l2_fourcc('I', 'N', 'R', 'I') /* 24 Depth/IR 16:8 */
+#define V4L2_PIX_FMT_RELI     v4l2_fourcc('R', 'E', 'L', 'I') /* 8 IR alternating on off illumination */
+#endif
+
 #define V4L2_PIX_FMT_SUNXI_TILED_NV12 v4l2_fourcc('S', 'T', '1', '2') /* Sunxi Tiled NV12 Format */
 #define V4L2_PIX_FMT_CNF4     v4l2_fourcc('C', 'N', 'F', '4') /* Intel 4-bit packed depth confidence information */
 #define V4L2_PIX_FMT_HI240    v4l2_fourcc('H', 'I', '2', '4') /* BTTV 8-bit dithered RGB */
+#define V4L2_PIX_FMT_RW16     v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
+#define V4L2_PIX_FMT_W10      v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
+#define V4L2_PIX_FMT_CONFIDENCE_MAP	v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
+/*  Librealsense development*/
+#define V4L2_PIX_FMT_FG       v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
+#define V4L2_PIX_FMT_INZC     v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
+#define V4L2_PIX_FMT_PAIR     v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
+#define V4L2_PIX_FMT_Z16H     v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
 
 /* 10bit raw bayer packed, 32 bytes for every 25 pixels, last LSB 6 bits unused */
 #define V4L2_PIX_FMT_IPU3_SBGGR10	v4l2_fourcc('i', 'p', '3', 'b') /* IPU3 packed 10-bit BGGR bayer */
@@ -770,6 +788,7 @@ struct v4l2_pix_format {
 #define V4L2_META_FMT_VSP1_HGT    v4l2_fourcc('V', 'S', 'P', 'T') /* R-Car VSP1 2-D Histogram */
 #define V4L2_META_FMT_UVC         v4l2_fourcc('U', 'V', 'C', 'H') /* UVC Payload Header metadata */
 #define V4L2_META_FMT_D4XX        v4l2_fourcc('D', '4', 'X', 'X') /* D4XX Payload Header metadata */
+#define V4L2_META_FMT_G2XX        v4l2_fourcc('G', '2', 'X', 'X') /* G2XX Payload Header metadata, orbbec modify */
 #define V4L2_META_FMT_VIVID	  v4l2_fourcc('V', 'I', 'V', 'D') /* Vivid Metadata */
 
 /* Vendor specific - used for RK_ISP1 camera sub-system */
diff --git a/kernel/nvidia-oot/drivers/media/i2c/Makefile b/kernel/nvidia-oot/drivers/media/i2c/Makefile
index 7c5913c64..e7ec63679 100644
--- a/kernel/nvidia-oot/drivers/media/i2c/Makefile
+++ b/kernel/nvidia-oot/drivers/media/i2c/Makefile
@@ -5,6 +5,9 @@ subdir-ccflags-y += -Werror
 
 obj-m += max9295.o
 obj-m += max9296.o
+subdir-ccflags-y += -DCONFIG_VIDEO_G2XX_SERDES
+subdir-ccflags-y += -DCONFIG_TEGRA_CAMERA_PLATFORM
+obj-m += g2xx.o
 ifeq ($(findstring ack_src,$(NV_BUILD_KERNEL_OPTIONS)),)
 obj-m += max96712.o
 
diff --git a/kernel/nvidia-oot/drivers/media/i2c/g2xx.c b/kernel/nvidia-oot/drivers/media/i2c/g2xx.c
new file mode 100644
index 000000000..db38c3a9f
--- /dev/null
+++ b/kernel/nvidia-oot/drivers/media/i2c/g2xx.c
@@ -0,0 +1,4156 @@
+/*
+ * orb.c - Orbbec G2XX camera driver
+ *
+ * Copyright (c) 2023-2025, ORBBEC CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+//#define DEBUG
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+
+#include <media/gmsl-link.h>
+#include <media/max9295.h>
+#include <media/max9296.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mediabus.h>
+
+#define I2C_RETRY_TIME 1
+
+//#define ORB_DRIVER_NAME "ORB RealSense camera driver"
+#define ORB_DRIVER_NAME "g2xx"
+#define ORB_DRIVER_NAME_AWG "g2xx-awg"
+#define ORB_DRIVER_NAME_ASR "g2xx-asr"
+#define ORB_DRIVER_NAME_CLASS "g2xx-class"
+#define ORB_DRIVER_NAME_DFU "g2xx-dfu"
+
+
+enum orb_mux_pad {
+	ORB_MUX_PAD_EXTERNAL,
+	ORB_MUX_PAD_DEPTH,
+	ORB_MUX_PAD_IR_L_T,
+	ORB_MUX_PAD_IR_R_T,
+	ORB_MUX_PAD_RGB,
+	ORB_MUX_PAD_COUNT,
+};
+
+#define ORB_N_CONTROLS			8
+
+#define CSI2_MAX_VIRTUAL_CHANNELS		4
+#define MAX_I2C_PACKET_SIZE 			240
+#define MAX_DEPTH_EXP					200000
+#define DEF_DEPTH_EXP					33000
+
+#define OPCODE_OPEN_STREAM      100
+#define OPCODE_CLOSE_STREAM     101
+
+struct orbbec_header{
+	u16 len;
+    u16 code;
+    u16 index;
+};
+
+static int index = 1;
+static int get_data_len = 10;
+static int orbbec_get_frame_profile_flag = 0;
+static int orbbec_communicate_finish_flag = 0;
+static int probe_cam_num = -1;
+struct orbbec_msg_body{
+	uint16_t res;
+	uint16_t prop_ver;
+    uint8_t  data[MAX_I2C_PACKET_SIZE - 4];
+};
+struct orbbec_msg_body1{
+	uint16_t res;
+    uint8_t  data[MAX_I2C_PACKET_SIZE - 2];
+};
+struct orbbec_set_imu_cmd{
+	uint16_t prop_code0;
+	uint16_t prop_code1;
+	uint16_t value0;
+	uint16_t value1;
+};
+
+struct orbbec_set_stream_cmd{
+	uint8_t stream_type;
+	uint8_t res;
+	uint8_t format;
+	uint8_t fps;
+};
+
+struct orbbec_cmd{
+	struct orbbec_header header;
+	union 
+	{
+		uint8_t _data[MAX_I2C_PACKET_SIZE];
+        struct orbbec_msg_body msg_body;
+		struct orbbec_msg_body1 msg_body1;
+		struct orbbec_set_stream_cmd set_stream_cmd;
+		struct orbbec_set_imu_cmd set_imu_cmd;
+	};
+	
+};
+struct ctpu_data{
+    uint8_t len;//设置数据的长度一般是1/2/4
+    uint8_t info;
+    int32_t cur;
+    int32_t max;
+    int32_t min;
+    int32_t def;
+    int32_t step;
+}__attribute__((__packed__));
+
+struct xu_data{
+    int32_t cur_xu;
+    int32_t max_xu;
+    int32_t min_xu;
+    int32_t def_xu;
+    int32_t step_xu;
+};
+
+//orbbec stream_type 
+enum stream_type {
+    STREAM_TYPE_UNDEFINE = 0,
+    STREAM_TYPE_GPM = 1,
+    STREAM_TYPE_DEPTH = 2,
+    STREAM_TYPE_MONO_L = 3,
+    STREAM_TYPE_MONO_R = 4,
+    STREAM_TYPE_RGB = 5,
+    STREAM_TYPE_MAX = 6,
+} stream_type_t;
+
+//orbbec Resolutions
+enum resolution {
+    RESOLUTION_CUSTOM = -1,
+    RESOLUTION_256_144 = 0,
+    RESOLUTION_320_180,
+    RESOLUTION_320_240,
+    RESOLUTION_424_240,
+    RESOLUTION_480_270,
+    RESOLUTION_640_360,
+    RESOLUTION_640_400,
+    RESOLUTION_640_480,
+    RESOLUTION_848_100,
+    RESOLUTION_848_480,
+    RESOLUTION_967_16,
+    RESOLUTION_960_540,
+    RESOLUTION_1280_720,
+    RESOLUTION_1280_800,
+    RESOLUTION_1920_1080,
+	RESOLUTION_1280_960,
+    RESOLUTION_MAX,
+} Resolution_t;
+
+static int resolution_map[16]={
+	256*144,
+    320*180,
+   	320*240,
+    424*240,
+    480*270,
+    640*360,
+    640*400,
+    640*480,
+    848*100,
+    848*480,
+    967*16,
+    960*540,
+    1280*720,
+    1280*800,
+    1920*1080,
+	1280*960,
+};
+
+enum _PixFmt
+{
+    PIXEL_FORMAT_UNDEFINED    = -1,
+    PIXEL_FORMAT_PACKED_8BIT  = 8,
+    PIXEL_FORMAT_PACKED_10BIT = 10,
+    PIXEL_FORMAT_PACKED_12BIT = 12,
+    PIXEL_FORMAT_PACKED_14BIT = 14,
+    PIXEL_FORMAT_PACKED_16BIT = 16,
+    PIXEL_FORMAT_YUV422 = 16,
+    PIXEL_FORMAT_MJPEG = 8,
+} PixFmt;
+
+
+struct orbbec_frame_profile_data {
+	uint32_t orbbec_sensor_type;
+    uint32_t orbbec_pixel_format;
+    uint32_t width;
+    uint32_t height;
+    uint32_t max_rate;
+};
+
+
+enum orb_sensor_type {
+    SENSOR_UNKNOWN = 0,
+    SENSOR_IR      = 1,
+    SENSOR_COLOR   = 2,
+    SENSOR_DEPTH   = 3,
+    SENSOR_ACCEL   = 4,
+    SENSOR_GYRO    = 5,
+    SENSOR_LEFT_IR = 6,
+    SENSOR_RIGHT_IR = 7,
+} orb_sensor_type_t;
+
+enum orb_pixel_format {
+    OB_PIXEL_FORMAT_YUYV = 0,    /**< YUYV */
+    OB_PIXEL_FORMAT_YUY2 = 1,    /**< YUY2 (same as YUYV)*/
+    OB_PIXEL_FORMAT_UYVY = 2,    /**< UYVY */
+    OB_PIXEL_FORMAT_NV12 = 3,    /**< NV12 */
+    OB_PIXEL_FORMAT_NV21 = 4,    /**< NV21 */
+    OB_PIXEL_FORMAT_MJPG = 5,    /**< MJPG */
+    OB_PIXEL_FORMAT_H264 = 6,    /**< H.264 */
+    OB_PIXEL_FORMAT_H265 = 7,    /**< H.265 */
+    OB_PIXEL_FORMAT_Y16 = 8,    /**< Y16, single channel 16bit Depth */
+    OB_PIXEL_FORMAT_Y8 = 9,    /**< Y8, single channel 8bit Depth */
+    OB_PIXEL_FORMAT_Y10 = 10,   /**< Y10, single channel 10bit Depth, Parse to Y16 by SDK */
+    OB_PIXEL_FORMAT_Y11 = 11,   /**< Y11, single channel 11bit Depth, Parse to Y16 by SDK */
+    OB_PIXEL_FORMAT_Y12 = 12,   /**< Y12, single channel 12bit Depth, Parse to Y16 by SDK */
+    OB_PIXEL_FORMAT_GRAY = 13,   /**< GRAY (same as YUYV)*/
+    OB_PIXEL_FORMAT_HEVC = 14,   /**< HEVC (same as H265)*/
+    OB_PIXEL_FORMAT_I420 = 15,   /**< I420 */
+    OB_PIXEL_FORMAT_ACCEL = 16,   /**< ACCEL */
+    OB_PIXEL_FORMAT_GYRO = 17,   /**< GYRO */
+    OB_PIXEL_FORMAT_POINT = 19,   /**< x-y-z 3D point */
+    OB_PIXEL_FORMAT_RGB_POINT = 20,   /**< RGB colored x-y-z 3d point */
+    OB_PIXEL_FORMAT_RLE = 21,   /**< RLE lostless encoded Depth, Parse to Y16 by SDK*/
+    OB_PIXEL_FORMAT_RGB888 = 22,   /**< RGB888 */
+    OB_PIXEL_FORMAT_BGR = 23,   /**< BGR (same as BRG888)*/
+    OB_PIXEL_FORMAT_Y14 = 24,   /**< Y14, single channel 14bit Depth, Parse to Y16 by SDK */
+    OB_PIXEL_FORMAT_UNKNOWN = 0xff, /**< Unknown format */
+} orb_pixel_format_t;
+
+
+/*************************/
+
+struct orb_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct {
+		struct v4l2_ctrl *log;
+		struct v4l2_ctrl *fw_version;
+		struct v4l2_ctrl *gvd;
+		struct v4l2_ctrl *get_depth_calib;
+		struct v4l2_ctrl *set_depth_calib;
+		struct v4l2_ctrl *get_coeff_calib;
+		struct v4l2_ctrl *set_coeff_calib;
+		struct v4l2_ctrl *ae_roi_get;
+		struct v4l2_ctrl *ae_roi_set;
+		struct v4l2_ctrl *ae_setpoint_get;
+		struct v4l2_ctrl *ae_setpoint_set;
+		struct v4l2_ctrl *erb;
+		struct v4l2_ctrl *ewb;
+		struct v4l2_ctrl *hwmc;
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+		/* in ORB manual gain only works with manual exposure */
+		struct v4l2_ctrl *gain;
+		struct v4l2_ctrl *backlight;
+		struct v4l2_ctrl *brightness;
+		struct v4l2_ctrl *contrast;
+		struct v4l2_ctrl *gamma;
+		struct v4l2_ctrl *hue;
+		struct v4l2_ctrl *saturation;
+		struct v4l2_ctrl *sharpness;
+		struct v4l2_ctrl *whitebalance;
+		struct v4l2_ctrl *autowhitebalance;
+		struct v4l2_ctrl *powerlinefreq;
+		struct v4l2_ctrl *aepriority;
+		//struct v4l2_ctrl *focus_absolute;
+
+		struct v4l2_ctrl *set_date;
+		struct v4l2_ctrl *reset_device_link;
+		struct v4l2_ctrl *reset_device;
+		struct v4l2_ctrl *set_datelen;
+		struct v4l2_ctrl *get_date;
+		struct v4l2_ctrl *get_pid_sn;
+		struct v4l2_ctrl *get_version;
+		struct v4l2_ctrl *get_imu_fps;
+		//struct v4l2_ctrl *get_imu_stock;
+		struct v4l2_ctrl *get_imu_data;
+		struct v4l2_ctrl *get_link_state;
+		
+	};
+};
+
+struct orb_resolution {
+	u16 width;
+	u16 height;
+	u8 n_framerates;
+	const u16 *framerates;
+};
+
+struct orb_format {
+	unsigned int n_resolutions;
+	struct orb_resolution *resolutions;
+	u32 mbus_code;
+	u8 data_type;
+};
+
+struct orb_sensor {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+	struct {
+		struct orb_format *format;
+		struct orb_resolution *resolution;
+		u16 framerate;
+	} config;
+	bool streaming;
+	/*struct orb_vchan *vchan;*/
+	struct orb_format *formats;
+	unsigned int n_formats;
+	int pipe_id;
+};
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define orb_mux_subdev camera_common_data
+#else
+struct orb_mux_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+enum {
+	ORB_ORBU,
+	ORB_ASR,
+	ORB_AWG,
+};
+struct orbbec_device_info {
+	uint16_t vid;
+	uint16_t pid;
+	uint8_t  sn[16];
+    uint8_t  asic_sn[16];
+	uint16_t video_type;
+	uint16_t sub_num;
+	uint32_t cam_num;
+};
+
+struct orb {
+	struct {
+		struct orb_sensor sensor;
+	} depth;
+	struct {
+		struct orb_sensor sensor;
+	} ir_l;
+	struct {
+		struct orb_sensor sensor;
+	} ir_r;
+	struct {
+		struct orb_sensor sensor;
+	} rgb;
+	struct {
+		struct orb_mux_subdev sd;
+		struct media_pad pads[ORB_MUX_PAD_COUNT];
+		struct orb_sensor *last_set;
+	} mux;
+	struct orb_ctrls ctrls;
+	bool power;
+	struct i2c_client *client;
+	/*struct orb_vchan virtual_channels[CSI2_MAX_VIRTUAL_CHANNELS];*/
+	/* All below pointers are used for writing, cannot be const */
+	struct mutex lock;
+	struct regmap *regmap;
+	struct regulator *vcc;
+	//const struct orb_variant *variant;
+	struct gmsl_link_ctx	g_ctx;
+	struct device		*ser_dev;
+	struct device		*dser_dev;
+	struct i2c_client *ser_i2c;
+	struct i2c_client *dser_i2c;
+	
+	struct orbbec_device_info device_info;
+	int is_depth;
+	int is_ir_l;
+	int is_ir_r;
+	int is_rgb;
+	int imu_fps;
+	int embedded_metadata_height;
+};
+
+#define orb_from_depth_sd(sd) container_of(sd, struct orb, depth.sd)
+#define orb_from_ir_l_sd(sd) container_of(sd, struct orb, ir_l.sd)
+#define orb_from_ir_r_sd(sd) container_of(sd, struct orb, ir_r.sd)
+#define orb_from_rgb_sd(sd) container_of(sd, struct orb, rgb.sd)
+
+
+/* Pad ops */
+
+static const u16 orb_default_framerate = 30;
+
+// **********************
+// FIXME: D16 width must be doubled, because an 8-bit format is used. Check how
+// the Tegra driver propagates resolutions and formats.
+// **********************
+
+//TODO: keep 6, till 5 is supported by FW
+static const u16 orb_framerates[] = {5, 30};
+
+#define ORB_FRAMERATE_DEFAULT_IDX 1
+
+static const u16 orb_framerate_30 = 30;
+
+static const u16 orb_framerate_10_30[] = {10, 15, 20, 30};
+
+static const u16 orb_framerate_25 = 25;
+
+static const u16 orb_depth_framerate_to_30[] = {5, 15, 30};
+static const u16 orb_framerate_to_30[] = {5, 10, 15, 30};
+static const u16 orb_framerate_to_60[] = {5, 10, 15, 30, 60};
+static const u16 orb_framerate_to_90[] = {5, 10, 15, 30, 60, 90};
+static const u16 orb_framerate_100[] = {100};
+static const u16 orb_framerate_90[] = {90};
+static const u16 orb_imu_framerates[] = {0, 1, 3, 6, 12, 25, 50, 100, 200, 500, 1000, 2000, 4000, 8000, 16000, 32000, 400, 800};
+
+static struct orb_resolution orb_depth_sizes[15];
+static struct orb_resolution orb_depth_sizes1[15];
+
+static struct orb_resolution orb_mono_sizes[15];
+static struct orb_resolution orb_mono_sizes1[15];
+
+static struct orb_resolution orb_rgb_sizes[15];
+static struct orb_resolution orb_rgb_sizes1[15];
+
+struct orb_mbus_type_map{
+	uint32_t map_mbus_code;
+	uint8_t map_data_type;
+};
+
+static struct orb_mbus_type_map orb_mbus_code_map[25] ={
+	{MEDIA_BUS_FMT_YUYV8_1X16, PIXEL_FORMAT_YUV422},   		/**< YUYV */
+	{MEDIA_BUS_FMT_YUYV8_1X16, PIXEL_FORMAT_YUV422},		/**< YUY2 (same as YUYV)*/
+	{MEDIA_BUS_FMT_UYVY8_1X16, PIXEL_FORMAT_YUV422},		/**< UYVY */
+	{MEDIA_BUS_FMT_SGRBG12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< SGRBG12_1X12 map to NV12 */
+	{MEDIA_BUS_FMT_SGBRG12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< SGBRG12_1X12 map to NV21 */
+	{MEDIA_BUS_FMT_SBGGR8_1X8, PIXEL_FORMAT_MJPEG},					/**<SBGGR8_1X8 map to MJPG */
+	{MEDIA_BUS_FMT_SBGGR12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< SBGGR12_1X12 map to H.264 */
+	{MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< H.265 */
+	{MEDIA_BUS_FMT_VYUY8_1X16, PIXEL_FORMAT_PACKED_16BIT},  /**< Y16,single channel 16bit Depth */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< Y8, single channel 8bit Depth */
+	{MEDIA_BUS_FMT_Y10_1X10, PIXEL_FORMAT_PACKED_10BIT},	/**< Y10, single channel 10bit Depth, Parse to Y16 by SDK */
+	{MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< Y11, single channel 11bit Depth, Parse to Y16 by SDK */
+	{MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< Y12, single channel 12bit Depth, Parse to Y16 by SDK */
+	{MEDIA_BUS_FMT_UYVY8_1X16, PIXEL_FORMAT_YUV422},   		/**< No use GRAY (same as YUYV)*/
+	{MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< No use HEVC (same as H265)*/
+	{MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< No use I420 */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use ACCEL */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use GYRO */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use  */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use x-y-z 3D point */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use RGB colored x-y-z 3d point */
+	{MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use RLE lostless encoded Depth, Parse to Y16 by SDK*/
+	{MEDIA_BUS_FMT_RGB888_1X24, PIXEL_FORMAT_UNDEFINED},	/**< RGB888 */
+	{MEDIA_BUS_FMT_RGB888_1X24,	PIXEL_FORMAT_UNDEFINED}, 	/**< No use BGR (same as RBG888)*/
+	{MEDIA_BUS_FMT_Y14_1X14, PIXEL_FORMAT_UNDEFINED}		/**< Y14, single channel 14bit Depth, Parse to Y16 by SDK */
+};
+
+static int orb_depth_formats_num = 0;
+static struct orb_format orb_depth_formats[2] = { //use this
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = PIXEL_FORMAT_PACKED_16BIT,	// Z16 
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = 0,
+		.resolutions = orb_depth_sizes,
+	}, {
+		.data_type = PIXEL_FORMAT_PACKED_14BIT,	// Y8 
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = 0,
+		.resolutions = orb_depth_sizes1,
+	}, 
+};
+
+//#define ORB_DEPTH_N_FORMATS 1
+static int orb_mono_formats_num = 0;
+static struct orb_format orb_mono_formats[2] = {
+	{
+		// First format: default 
+		.data_type = PIXEL_FORMAT_PACKED_8BIT,	// Y8 
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = 0,
+		.resolutions = orb_mono_sizes,
+	}, {
+		.data_type = PIXEL_FORMAT_PACKED_12BIT,	// Y8I 
+		.mbus_code = MEDIA_BUS_FMT_VYUY8_1X16,
+		.n_resolutions = 0,
+		.resolutions = orb_mono_sizes1,
+	},
+};
+
+static int orb_rgb_formats_num = 0;
+static struct orb_format orb_rgb_formats[2]= { //use this
+	{
+		.data_type = PIXEL_FORMAT_YUV422,	// UYVY 
+		.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16, //Different from depth in MEDIA_BUS_FMT_UYVY8_1X16(map to Z16)
+		// .data_type = 0x2b, // RAW10 
+		// .mbus_code = MEDIA_BUS_FMT_Y10_1X10, //MEDIA_BUS_FMT_SRGGB10_1X10
+		.n_resolutions = 0,
+		.resolutions = orb_rgb_sizes,
+	}, {
+		.data_type = PIXEL_FORMAT_MJPEG,	//RGB888 
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	// FIXME 
+		.n_resolutions = 0,
+		.resolutions = orb_rgb_sizes1,
+	}, 
+};
+
+static struct v4l2_mbus_framefmt orb_mbus_framefmt_template = {
+	.width = 0,
+	.height = 0,
+	.code = MEDIA_BUS_FMT_FIXED,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+static int read_property_u32(
+	struct device_node *node, const char *name, u32 *value)
+{
+	const char *str;
+	int err = 0;
+
+	err = of_property_read_string(node, name, &str);
+	if (err)
+		return -ENODATA;
+
+	err = kstrtou32(str, 10, value);
+	if (err)
+		return -EFAULT;
+
+	return 0;
+}
+
+/* Get readable sensor name */
+static const char *orb_get_sensor_name(struct orb *state)
+{
+	static const char *sensor_name[] = {"unknown", "RGB", "DEPTH", "IR_L", "IR_R"};
+	int sensor_id = state->is_rgb * 1 + state->is_depth * 2 + \
+			state->is_ir_l * 3 + state->is_ir_r * 4 ;
+	if (sensor_id >= (sizeof(sensor_name)/sizeof(*sensor_name)))
+		sensor_id = 0;
+
+	return sensor_name[sensor_id];
+}
+
+/* This is needed for .get_fmt()
+ * and if streaming is started without .set_fmt() */
+static void orb_sensor_format_init(struct orb_sensor *sensor)
+{
+	struct orb_format *fmt;
+	struct v4l2_mbus_framefmt *ffmt;
+	unsigned int i;
+
+	if (sensor->config.format)
+		return;
+
+	dev_dbg(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
+
+	ffmt = &sensor->format;
+	*ffmt = orb_mbus_framefmt_template;
+	/* Use the first format */
+	fmt = sensor->formats;
+	ffmt->code = fmt->mbus_code;
+	/* and the first resolution */
+	ffmt->width = fmt->resolutions->width;
+	ffmt->height = fmt->resolutions->height;
+
+	sensor->config.format = fmt;
+	sensor->config.resolution = fmt->resolutions;
+	/* Set default framerate to 30, or to 1st one if not supported */
+	for (i = 0; i < fmt->resolutions->n_framerates;i++) {
+		if (fmt->resolutions->framerates[i] == orb_framerate_30 /* fps */) {
+			sensor->config.framerate = orb_framerate_30;
+			return;
+		}
+	}
+	sensor->config.framerate = fmt->resolutions->framerates[0];
+}
+
+/* No locking needed for enumeration methods */
+static int orb_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd);
+
+	if (mce->pad)
+		return -EINVAL;
+
+	if (mce->index >= sensor->n_formats)
+		return -EINVAL;
+
+	mce->code = sensor->formats[mce->index].mbus_code;
+
+	return 0;
+}
+
+static int orb_sensor_enum_frame_size(struct v4l2_subdev *sd,
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+		#else
+		struct v4l2_subdev_state *v4l2_state,
+		#endif
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd);
+	struct orb_format *fmt;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fse->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	if (fse->index >= fmt->n_resolutions)
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = fmt->resolutions[fse->index].width;
+	fse->min_height = fse->max_height = fmt->resolutions[fse->index].height;
+
+	return 0;
+}
+
+static int orb_sensor_enum_frame_interval(struct v4l2_subdev *sd,
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd);
+	struct orb_format *fmt;
+	struct orb_resolution *res;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fie->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++)
+		if (res->width == fie->width && res->height == fie->height)
+			break;
+
+	if (i == fmt->n_resolutions)
+		return -EINVAL;
+
+	if (fie->index >= res->n_framerates)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = res->framerates[fie->index];
+
+	return 0;
+}
+
+static int orb_sensor_get_fmt(struct v4l2_subdev *sd,
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_format *fmt)
+{
+	struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd);
+	struct orb *state = v4l2_get_subdevdata(sd);
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+#else
+		fmt->format = *v4l2_subdev_get_try_format(sd, v4l2_state, fmt->pad);
+#endif
+	else
+		fmt->format = sensor->format;
+
+	mutex_unlock(&state->lock);
+
+	dev_dbg(sd->dev, "%s(): pad %x, code %x, res %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+/* Called with lock held */
+static struct orb_format *orb_sensor_find_format(
+		struct orb_sensor *sensor,
+		struct v4l2_mbus_framefmt *ffmt,
+		struct orb_resolution **best)
+{
+	struct orb_resolution *res;
+	struct orb_format *fmt;
+	unsigned long best_delta = ~0;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++) {
+		if (fmt->mbus_code == ffmt->code)
+			break;
+	}
+	dev_dbg(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n",
+			__func__, fmt->mbus_code, ffmt->code);
+
+	if (i == sensor->n_formats)
+		/* Not found, use default */
+		fmt = sensor->formats;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
+		unsigned long delta = abs(ffmt->width * ffmt->height -
+				res->width * res->height);
+		if (delta < best_delta) {
+			best_delta = delta;
+			*best = res;
+		}
+	}
+
+	ffmt->code = fmt->mbus_code;
+	ffmt->width = (*best)->width;
+	ffmt->height = (*best)->height;
+
+	ffmt->field = V4L2_FIELD_NONE;
+	/* Should we use V4L2_COLORSPACE_RAW for Y12I? */
+	ffmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return fmt;
+}
+
+static int __orb_sensor_set_fmt(struct orb *state, struct orb_sensor *sensor,
+			#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				struct v4l2_subdev_pad_config *cfg,
+			#else
+				struct v4l2_subdev_state *v4l2_state,
+			#endif
+				struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *mf;// = &fmt->format;
+	//unsigned r;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	dev_dbg(sensor->sd.dev, "%s(): state %p, "
+			"sensor %p, cfg %p, fmt %p, fmt->format %p\n",
+			__func__, state, sensor, cfg, fmt,  &fmt->format);
+#else
+	dev_dbg(sensor->sd.dev, "%s(): state %p, "
+			"sensor %p, cfg %p, fmt %p, fmt->format %p\n",
+			__func__, state, sensor, v4l2_state, fmt,  &fmt->format);
+#endif
+	mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	sensor->config.format = orb_sensor_find_format(sensor, mf,
+						&sensor->config.resolution);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	if (cfg && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		*v4l2_subdev_get_try_format(&sensor->sd, cfg, fmt->pad) = *mf;
+#else
+	if (v4l2_state && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		*v4l2_subdev_get_try_format(&sensor->sd, v4l2_state, fmt->pad) = *mf;
+#endif
+
+	else
+// FIXME: use this format in .s_stream()
+		sensor->format = *mf;
+
+	state->mux.last_set = sensor;
+
+	mutex_unlock(&state->lock);
+
+	dev_dbg(sensor->sd.dev, "%s(): pad: %x, code: %x, %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+static int orb_sensor_set_fmt(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+#else
+		struct v4l2_subdev_state *v4l2_state,
+#endif
+		struct v4l2_subdev_format *fmt)
+{
+	struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd);
+	struct orb *state = v4l2_get_subdevdata(sd);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	return __orb_sensor_set_fmt(state, sensor, cfg, fmt);
+#else
+	return __orb_sensor_set_fmt(state, sensor, v4l2_state, fmt);
+#endif
+}
+
+static int orb_setup_pipeline(struct orb *state, u8 data_type1, u8 data_type2,
+			      int pipe_id, u32 srcvc_id, u32 dstvc_id)
+{
+	int ret = 0;
+	dev_dbg(&state->client->dev,
+			 "set pipe %d, data_type1: 0x%x, \
+			 data_type2: 0x%x,srcvc_id: %u, dstvc_id: %u\n",
+			 pipe_id, data_type1, data_type2, srcvc_id, dstvc_id);
+	ret |= max9295_set_pipe(state->ser_dev, pipe_id,
+				data_type1, data_type2, srcvc_id);
+	ret |= max9296_set_pipe(state->dser_dev, pipe_id,
+				data_type1, data_type2, srcvc_id, dstvc_id);
+	if (ret)
+		dev_warn(&state->client->dev,
+			 "failed to set pipe %d, data_type1: 0x%x, \
+			 data_type2: 0x%x, srcvc_id: %u, dstvc_id: %u\n",
+			 pipe_id, data_type1, data_type2, srcvc_id, dstvc_id);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_pad_ops orb_depth_pad_ops = {
+	.enum_mbus_code		= orb_sensor_enum_mbus_code,
+	.enum_frame_size	= orb_sensor_enum_frame_size,
+	.enum_frame_interval	= orb_sensor_enum_frame_interval,
+	.get_fmt		= orb_sensor_get_fmt,
+	.set_fmt		= orb_sensor_set_fmt,
+};
+
+static int orb_sensor_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd);
+	dev_dbg(sensor->sd.dev,
+			"%s(): sensor: name=%s state=%d\n",
+			__func__, sensor->sd.name, on);
+
+	sensor->streaming = on;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops orb_sensor_video_ops = {
+	.s_stream		= orb_sensor_s_stream,
+};
+
+static const struct v4l2_subdev_ops orb_depth_subdev_ops = {
+	.pad = &orb_depth_pad_ops,
+	.video = &orb_sensor_video_ops,
+};
+
+/* Motion detection */
+
+/* FIXME: identical to orb_depth_pad_ops, use one for both */
+static const struct v4l2_subdev_pad_ops orb_ir_l_pad_ops = {
+	.enum_mbus_code		= orb_sensor_enum_mbus_code,
+	.enum_frame_size	= orb_sensor_enum_frame_size,
+	.enum_frame_interval	= orb_sensor_enum_frame_interval,
+	.get_fmt		= orb_sensor_get_fmt,
+	.set_fmt		= orb_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops orb_ir_l_subdev_ops = {
+	.pad = &orb_ir_l_pad_ops,
+	.video = &orb_sensor_video_ops,
+};
+
+static const struct v4l2_subdev_pad_ops orb_ir_r_pad_ops = {
+	.enum_mbus_code		= orb_sensor_enum_mbus_code,
+	.enum_frame_size	= orb_sensor_enum_frame_size,
+	.enum_frame_interval	= orb_sensor_enum_frame_interval,
+	.get_fmt		= orb_sensor_get_fmt,
+	.set_fmt		= orb_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops orb_ir_r_subdev_ops = {
+	.pad = &orb_ir_r_pad_ops,
+	.video = &orb_sensor_video_ops,
+};
+
+/* FIXME: identical to orb_depth_pad_ops, use one for both? */
+static const struct v4l2_subdev_pad_ops orb_rgb_pad_ops = {
+	.enum_mbus_code		= orb_sensor_enum_mbus_code,
+	.enum_frame_size	= orb_sensor_enum_frame_size,
+	.enum_frame_interval	= orb_sensor_enum_frame_interval,
+	.get_fmt		= orb_sensor_get_fmt,
+	.set_fmt		= orb_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops orb_rgb_subdev_ops = {
+	.pad = &orb_rgb_pad_ops,
+	.video = &orb_sensor_video_ops,
+};
+
+
+#define ORB_CAMERA_CID  0x4000
+#define ORB_CAMERA_CID_BASE	(V4L2_CTRL_CLASS_CAMERA | ORB_CAMERA_CID)
+
+#define ORBBEC_CAMERA_CID_SET_DATA				(ORB_CAMERA_CID_BASE+33)
+#define ORBBEC_CAMERA_CID_GET_VERSION_DATA		(ORB_CAMERA_CID_BASE+34)
+//#define ORBBEC_CAMERA_CID_GET_IMU_STOCK			(ORB_CAMERA_CID_BASE+35)
+#define ORBBEC_CAMERA_CID_GET_IMU_DATA			(ORB_CAMERA_CID_BASE+36)
+#define ORBBEC_CAMERA_CID_GET_IMU_FPS			(ORB_CAMERA_CID_BASE+37)
+#define ORBBEC_CAMERA_CID_SET_DATA_LEN			(ORB_CAMERA_CID_BASE+38)
+#define ORBBEC_CAMERA_CID_GET_DATA          	(ORB_CAMERA_CID_BASE+39)
+//#define ORBBEC_CAMERA_CID_SET_GPIO		    	(ORB_CAMERA_CID_BASE+40)
+#define ORBBEC_CAMERA_CID_RESET_DEVICE_LINK			(ORB_CAMERA_CID_BASE+41)
+#define ORBBEC_CAMERA_CID_GET_PID_SN			(ORB_CAMERA_CID_BASE+42)
+#define ORBBEC_CAMERA_CID_GET_LINK_STATE		(ORB_CAMERA_CID_BASE+43)
+#define ORBBEC_CAMERA_CID_RESET_DEVICE		    (ORB_CAMERA_CID_BASE+44)
+
+#define G2R_IMU_STOCK_MAX_SIZE   				9
+
+#define G2R_I2C_RESPONSE_HEARD_LEN				8
+#define G2R_GET_FIRMWARE_DATA_CMD_LEN			8
+#define G2R_GET_IMU_STOCK_CMD_LEN				10
+#define G2R_GET_IMU_DATA_CMD_LEN				18
+#define G2R_GET_FRAME_PROFILE_LEN_CMD_LEN		10
+#define G2R_GET_FRAME_PROFILE_DATA_CMD_LEN		18
+#define G2R_STREAM_START_CMD_LEN				10
+#define G2R_STREAM_STOP_CMD_LEN					8
+#define G2R_SET_PROPERTY_CMD_LEN				14
+#define G2R_GET_PROPERTY_CMD_LEN				10
+#define G2R_SET_IMU_CMD_LEN						14
+#define G2R_GET_PU_CMD_LEN 8
+#define G2R_GET_PU_INIT_LEN 30 //8+sizeof(ctpu_data)
+//I2C command to read data length
+#define G2R_GET_DATA_NOMAL_LEN	10 
+#define G2R_GET_VERSION_DATA_LEN	172
+#define G2R_RW_DATA_LEN	        256
+#define G2R_GET_IMU_DATA_LEN	24
+#define G2R_GET_IMU_STOCK_LEN	14 
+#define G2R_GET_PROPERTY_DATA_LEN	28
+#define G2R_GET_FRAME_PROFILE_LEN_LEN	14 
+#define G2R_GET_SN_DATA_LEN				24 
+//I2C command operation code
+#define G2R_SET_PROPERTY_CODE		2
+#define G2R_GET_PROPERTY_CODE		1
+#define G2R_GET_FIRMWARE_DATA_CODE		3
+#define G2R_GET_IMU_DATA_CODE	    30
+#define G2R_GET_IMU_STOCK_CODE	        29 
+#define G2R_GET_FRAME_PROFILE_LEN_CORE	        29
+#define G2R_GET_FRAME_PROFILE_DATA_CORE 30
+#define G2R_GET_CTPU_INIT_CODE          200
+#define G2R_GET_CTPU_CODE               201
+#define G2R_SET_CTPU_CODE               202
+
+#define G2R_GET_PID_PRO_ID  			111
+#define G2R_GET_SN_PRO_ID  				1035
+#define G2R_GET_ASIC_SN_PRO_ID  		1063
+
+#define CTPU_PROID_LEN                        2
+#define IR_CONTROL_SELECT                     1
+#define RGB_CONTROL_SELECT                    0
+#define CT_CONTROL_SELECT                     0x00
+#define PU_CONTROL_SELECT                     0x80
+
+#define CT_AE_MANUL_MODE					  (1 << 0)
+#define CT_AE_AUTO_MODE					  	  (1 << 1)
+#define CT_AE_SHUTTER_MODE					  (1 << 2)
+#define CT_AE_APERTURE_MODE					  (1 << 3)
+
+/* A.9.4. Camera Terminal Control Selectors */
+#define CT_CONTROL_UNDEFINED                       0x00
+#define CT_SCANNING_MODE_CONTROL                   0x01
+#define CT_AE_MODE_CONTROL                         0x02
+#define CT_AE_PRIORITY_CONTROL                     0x03
+#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL          0x04
+#define CT_EXPOSURE_TIME_RELATIVE_CONTROL          0x05
+#define CT_FOCUS_ABSOLUTE_CONTROL                  0x06
+#define CT_FOCUS_RELATIVE_CONTROL                  0x07
+#define CT_FOCUS_AUTO_CONTROL                      0x08
+#define CT_IRIS_ABSOLUTE_CONTROL                   0x09
+#define CT_IRIS_RELATIVE_CONTROL                   0x0A
+#define CT_ZOOM_ABSOLUTE_CONTROL                   0x0B
+#define CT_ZOOM_RELATIVE_CONTROL                   0x0C
+#define CT_PANTILT_ABSOLUTE_CONTROL                0x0D
+#define CT_PANTILT_RELATIVE_CONTROL                0x0E
+#define CT_ROLL_ABSOLUTE_CONTROL                   0x0F
+#define CT_ROLL_RELATIVE_CONTROL                   0x10
+#define CT_PRIVACY_CONTROL                         0x11
+#define CT_FOCUS_SIMPLE_CONTROL                    0x12
+#define CT_WINDOW_CONTROL                          0x13
+#define CT_REGION_OF_INTEREST_CONTROL              0x14
+#define CT_CONTROL_NUM              			   0x15
+
+/* Processing Unit Control Selectors */
+#define PU_CONTROL_UNDEFINED                       0x00
+#define PU_BACKLIGHT_COMPENSATION_CONTROL          0x01
+#define PU_BRIGHTNESS_CONTROL                      0x02
+#define PU_CONTRAST_CONTROL                        0x03
+#define PU_GAIN_CONTROL                            0x04
+#define PU_POWER_LINE_FREQUENCY_CONTROL            0x05
+#define PU_HUE_CONTROL                             0x06
+#define PU_SATURATION_CONTROL                      0x07
+#define PU_SHARPNESS_CONTROL                       0x08
+#define PU_GAMMA_CONTROL                           0x09
+#define PU_WHITE_BALANCE_TEMPERATURE_CONTROL       0x0A
+#define PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL  0x0B
+#define PU_WHITE_BALANCE_COMPONENT_CONTROL         0x0C
+#define PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL    0x0D
+#define PU_DIGITAL_MULTIPLIER_CONTROL              0x0E
+#define PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL        0x0F
+#define PU_HUE_AUTO_CONTROL                        0x10
+#define PU_ANALOG_VIDEO_STANDARD_CONTROL           0x11
+#define PU_ANALOG_LOCK_STATUS_CONTROL              0x12
+#define PU_CONTROL_NUM              			   0x13
+
+uint8_t ct_ctl_len[CT_CONTROL_NUM] = {0};
+uint8_t pu_ctl_len[PU_CONTROL_NUM] = {0};
+
+/*通过i2c 向orbbec写入数据,直接写数据不写寄存器地址
+*orbbec_client：orbbec的i2c_client结构体。
+*data：要写入的数据
+*length：写长度
+*返回值，错误，-1。成功，0  
+*/
+static int i2c_write_orbbec(struct i2c_client *orbbec_client,void *data, u32 length)
+{
+	int error = 0;
+	struct i2c_msg send_msg; //要发送的数据结构体
+
+	/*发送 iic要写入的地址 reg*/
+	send_msg.addr = orbbec_client->addr; //orbbec在 iic 总线上的地址
+	send_msg.flags = 0;					  //标记为发送数据
+	send_msg.buf = (uint8_t*)data;			  //写入的首地址
+	send_msg.len = length;					  //reg长度
+
+	/*执行发送*/
+	error = i2c_transfer(orbbec_client->adapter, &send_msg, 1);
+	if (error != 1)
+	{
+		printk(KERN_DEBUG "\n i2c_transfer error \n");
+		return -1;
+	}
+	return 0;
+}
+
+/*通过i2c 向orbbec读入数据，直接读数据不写寄存器地址
+*orbbec_client：orbbec的i2c_client结构体。
+*data，保存读取得到的数据
+*length，读长度
+*返回值，错误，-1。成功，0
+*/
+static int i2c_read_orbbec(struct i2c_client *orbbec_client, void *data, u32 length)
+{
+	int error = 0;
+	struct i2c_msg orbbec_msg;
+
+	/*设置读取位置msg*/
+	orbbec_msg.addr = orbbec_client->addr;  //orbbec在 iic 总线上的地址
+	orbbec_msg.flags = I2C_M_RD;			//标记为读取数据
+	orbbec_msg.buf = data;					//读取得到的数据保存位置
+	orbbec_msg.len = length;				//读取长度
+
+	error = i2c_transfer(orbbec_client->adapter, &orbbec_msg, 1);
+
+	if (error != 1)
+	{
+		printk(KERN_DEBUG "\n i2c_read_orbbec error \n");
+		return -1;
+	}
+	return 0;
+}
+
+/*通过i2c 向orbbec读取设备信息
+*state：orbbec的i2c_client结构体。
+*data: 保存读取得到的数据
+*cmd_len: 命令长度
+*opcode: 操作符
+*pro_id： pro_id
+*data_len： 获取的数据长度
+*返回值：错误，-1。成功，0
+*/
+static int orbbec_get_deviceinfo(struct orb *state, void * data, uint16_t cmd_len, uint16_t opcode, uint16_t pro_id, uint32_t data_len){
+	int ret = 0;
+	struct orbbec_cmd *get_info_cmd;
+	get_info_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_info_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_info_cmd->header.len = cmd_len;
+	get_info_cmd->header.code = opcode;
+	get_info_cmd->header.index = index++;
+	get_info_cmd->_data[0] = pro_id;
+	get_info_cmd->_data[1] = pro_id >>8;
+
+
+	ret = i2c_write_orbbec(state->client,get_info_cmd, cmd_len);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_11;
+	}
+	udelay(10);
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_info_cmd, data_len);
+	memcpy(data, get_info_cmd->msg_body1.data, data_len-G2R_I2C_RESPONSE_HEARD_LEN);
+	err_11:
+	devm_kfree(&state->client->dev, get_info_cmd);
+	return ret;
+}
+
+/*通过i2c 向orbbec读取版本信息
+*state：orbbec的i2c_client结构体。
+*data，保存读取得到的数据
+*返回值，错误，-1。成功，0
+*/
+static int orbbec_get_version(struct orb *state, void * data){
+	int ret = 0;
+	struct orbbec_cmd *get_version_cmd;
+	get_version_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_version_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_version_cmd->header.len = G2R_GET_FIRMWARE_DATA_CMD_LEN;
+	get_version_cmd->header.code = G2R_GET_FIRMWARE_DATA_CODE;
+	get_version_cmd->header.index = index++;
+	get_version_cmd->_data[0] = 0xe8;
+	get_version_cmd->_data[1] = 0x03;
+
+
+	ret = i2c_write_orbbec(state->client,get_version_cmd, G2R_GET_FIRMWARE_DATA_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_10;
+	}
+	udelay(10);
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_version_cmd, G2R_GET_VERSION_DATA_LEN);
+	memcpy(data, get_version_cmd, G2R_GET_VERSION_DATA_LEN);
+	err_10:
+	devm_kfree(&state->client->dev, get_version_cmd);
+	return ret;
+}
+
+static int orbbec_get_imu_stock(struct orb *state, int *data){
+	int ret = 0, i = 0;
+	u16 cmd_index;
+	struct orbbec_cmd *get_imu_stock_cmd;
+	get_imu_stock_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_imu_stock_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_imu_stock_cmd->header.len = G2R_GET_IMU_STOCK_CMD_LEN;
+	get_imu_stock_cmd->header.code = G2R_GET_IMU_STOCK_CODE;
+	get_imu_stock_cmd->header.index = index++;
+	get_imu_stock_cmd->_data[0] = 0xcd;
+	get_imu_stock_cmd->_data[1] = 0x0f;
+
+	cmd_index = get_imu_stock_cmd->header.index;
+	ret = i2c_write_orbbec(state->client,get_imu_stock_cmd, G2R_GET_IMU_STOCK_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write get_imu_stock cmd err \n");
+		goto err_5;
+	}
+	//udelay(10);
+	for(i = 0; i <= I2C_RETRY_TIME; i++){
+		usleep_range(100,120);
+		ret = i2c_read_orbbec(state->client, get_imu_stock_cmd, G2R_GET_IMU_STOCK_LEN);
+		if(ret < 0){
+			printk(KERN_DEBUG "\n i2c read  get_imu_stock data err \n");
+			goto err_5;
+		}
+		
+		if(get_imu_stock_cmd->header.len != G2R_GET_IMU_STOCK_LEN || get_imu_stock_cmd->header.code != G2R_GET_IMU_STOCK_CODE || get_imu_stock_cmd->header.index != cmd_index){
+			dev_dbg(&state->client->dev, "retry get_imustock\n");
+			continue;
+		}
+		else break;
+	}
+	memcpy(data, get_imu_stock_cmd->msg_body.data, 4);
+	*data = *data/G2R_GET_IMU_DATA_LEN;
+	err_5:
+	devm_kfree(&state->client->dev, get_imu_stock_cmd);
+	return ret;
+}
+
+static int orbbec_get_imu_data(struct orb *state, void * data){
+	int ret = 0, stock_size =0, get_imu_date_len = 0, i = 0;
+	u16 cmd_index;
+	struct orbbec_cmd *get_imudata_cmd;
+	get_imudata_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_imudata_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = orbbec_get_imu_stock(state, &stock_size);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n orbbec_get_imu_stock err \n");
+		goto err_9;
+	}
+
+	get_imu_date_len = G2R_GET_IMU_DATA_LEN*stock_size;
+	get_imudata_cmd->header.len = G2R_GET_IMU_DATA_CMD_LEN;
+	get_imudata_cmd->header.code = G2R_GET_IMU_DATA_CODE;
+	get_imudata_cmd->header.index = index++;
+	get_imudata_cmd->_data[0] = 0xcd;
+	get_imudata_cmd->_data[1] = 0x0f;
+	get_imudata_cmd->_data[2] = 0x0;
+	get_imudata_cmd->_data[3] = 0x0;
+	get_imudata_cmd->_data[4] = 0x0;
+	get_imudata_cmd->_data[5] = 0x0;
+	get_imudata_cmd->_data[6] = 0x0;
+	get_imudata_cmd->_data[7] = 0x0;
+	get_imudata_cmd->_data[8] = get_imu_date_len;
+	get_imudata_cmd->_data[9] = get_imu_date_len >> 8;
+	get_imudata_cmd->_data[10] = get_imu_date_len >> 16;
+	get_imudata_cmd->_data[11] = get_imu_date_len >> 24;
+
+	cmd_index = get_imudata_cmd->header.index;
+
+	if(stock_size == 0 || stock_size < 0 || stock_size > G2R_IMU_STOCK_MAX_SIZE){
+		get_imudata_cmd->header.len = G2R_I2C_RESPONSE_HEARD_LEN;
+		get_imudata_cmd->_data[0] = 0;
+		get_imudata_cmd->_data[1] = 0;
+		get_imu_date_len = 0;
+		dev_dbg(&state->client->dev, " stock_size = %d \n",stock_size);
+		printk(KERN_DEBUG "\n orbbec stock size err\n");
+	}else{
+		ret = i2c_write_orbbec(state->client,get_imudata_cmd, G2R_GET_IMU_DATA_CMD_LEN);
+		if(ret < 0){
+			printk(KERN_DEBUG "\n i2c write get_imudata_cmd cmd err \n");
+			goto err_9;
+		}
+		//udelay(10);
+		for(i = 0; i <= I2C_RETRY_TIME; i++){
+			usleep_range(100,120);
+			ret = i2c_read_orbbec(state->client, get_imudata_cmd, G2R_I2C_RESPONSE_HEARD_LEN + get_imu_date_len);
+			if(ret < 0){
+				printk(KERN_DEBUG "\n i2c write get_imudata_cmd data err \n");
+				goto err_9;
+			}
+
+			if(get_imudata_cmd->header.len == 0 && get_imudata_cmd->header.code == 0 && get_imudata_cmd->header.index == 0){
+				dev_dbg(&state->client->dev, "retry get_imudata\n");
+				continue;
+			}
+			else if(get_imudata_cmd->header.len != G2R_I2C_RESPONSE_HEARD_LEN + get_imu_date_len || get_imudata_cmd->header.code != G2R_GET_IMU_DATA_CODE || get_imudata_cmd->header.index != cmd_index){
+				get_imudata_cmd->header.len = G2R_I2C_RESPONSE_HEARD_LEN;
+				get_imudata_cmd->_data[0] = 0;
+				get_imudata_cmd->_data[1] = 0;
+				get_imu_date_len = 0;
+				dev_dbg(&state->client->dev, " get_imudata data err\n");
+				break;
+			} else {
+				break;
+			}
+		}
+	}
+	
+	memcpy(data, get_imudata_cmd, G2R_I2C_RESPONSE_HEARD_LEN + get_imu_date_len);
+	err_9:
+	devm_kfree(&state->client->dev, get_imudata_cmd);
+	return ret;
+}
+
+static int orbbec_get_frame_profile_len(struct orb *state, void * data){
+	int ret = 0;
+	struct orbbec_cmd *get_frame_profile_len_cmd;
+	get_frame_profile_len_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_frame_profile_len_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_frame_profile_len_cmd->header.len = G2R_GET_FRAME_PROFILE_LEN_CMD_LEN;
+	get_frame_profile_len_cmd->header.code = G2R_GET_FRAME_PROFILE_LEN_CORE;
+	get_frame_profile_len_cmd->header.index = index++;
+	get_frame_profile_len_cmd->_data[0] = 0xc3;
+	get_frame_profile_len_cmd->_data[1] = 0x0f;
+	get_frame_profile_len_cmd->_data[2] = 0x00;
+	get_frame_profile_len_cmd->_data[3] = 0x00;
+	
+
+
+	ret = i2c_write_orbbec(state->client,get_frame_profile_len_cmd, G2R_GET_FRAME_PROFILE_LEN_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_8;
+	}
+	//udelay(10);
+	usleep_range(500,800);
+	ret = i2c_read_orbbec(state->client, get_frame_profile_len_cmd, G2R_GET_FRAME_PROFILE_LEN_LEN);
+	memcpy(data, get_frame_profile_len_cmd->msg_body.data, 4);
+	err_8:
+	devm_kfree(&state->client->dev, get_frame_profile_len_cmd);
+	return ret;
+}
+
+
+static int orbbec_get_frame_profile_data(struct orb *state, void * data, int offset,int length){
+	int ret = 0;
+	struct orbbec_cmd *get_frame_profile_data_cmd;
+	get_frame_profile_data_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_frame_profile_data_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_frame_profile_data_cmd->header.len = G2R_GET_FRAME_PROFILE_DATA_CMD_LEN;
+	get_frame_profile_data_cmd->header.code = G2R_GET_FRAME_PROFILE_DATA_CORE;
+	get_frame_profile_data_cmd->header.index = index++;
+	get_frame_profile_data_cmd->_data[0] = 0xc3;
+	get_frame_profile_data_cmd->_data[1] = 0x0f;
+	get_frame_profile_data_cmd->_data[2] = 0x00;
+	get_frame_profile_data_cmd->_data[3] = 0x00;
+	get_frame_profile_data_cmd->_data[4] = offset;
+	get_frame_profile_data_cmd->_data[5] = offset >> 8;
+	get_frame_profile_data_cmd->_data[6] = offset >> 16;
+	get_frame_profile_data_cmd->_data[7] = offset >> 24;
+	get_frame_profile_data_cmd->_data[8] = length;
+	get_frame_profile_data_cmd->_data[9] = length >> 8;
+	get_frame_profile_data_cmd->_data[10] = length >> 16;
+	get_frame_profile_data_cmd->_data[11] = length >> 24;
+
+
+	ret = i2c_write_orbbec(state->client,get_frame_profile_data_cmd, G2R_GET_FRAME_PROFILE_DATA_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_7;
+	}
+	//udelay(10);
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_frame_profile_data_cmd, G2R_GET_DATA_NOMAL_LEN+length);
+	memcpy(data,get_frame_profile_data_cmd->msg_body1.data, length);
+	err_7:
+	devm_kfree(&state->client->dev, get_frame_profile_data_cmd);
+	return ret;
+}
+
+
+static int orbbec_get_frame_profile(struct orb *state){
+	int ret = 0;
+	int size = 0;
+	int i = 0;
+	int n = 0;
+	int f = 0;
+	int num = 0;
+	int get_ir_frame_profile_flag = 0;
+	//struct orbbec_frame_profile_data (*orbbec_frame_profile_t)[10];
+	struct orbbec_frame_profile_data *orbbec_frame_profile_t;
+	struct orb_format *orbbec_format_t;
+	struct orb_resolution *orbbec_resolutions_t;
+	int *orb_formats_num; 
+	int *orb_resolutions_num;
+	orbbec_frame_profile_t = devm_kzalloc(&state->client->dev,10*sizeof(struct orbbec_frame_profile_data), GFP_KERNEL); 
+	ret = orbbec_get_frame_profile_len(state, &size);
+	if(size == 0){
+		dev_err(&state->client->dev, "get frame_profile size =0 retry \n");
+		ret = orbbec_get_frame_profile_len(state, &size);
+		if(size == 0) {
+			dev_err(&state->client->dev, " err get frame_profile size =0  \n");
+			ret = -1;
+			goto err_6;
+		}
+	} 
+	if(ret <0 ){
+		dev_err(&state->client->dev, "get frame_profile size err \n");
+		goto err_6;
+	}
+	size = size / sizeof(struct orbbec_frame_profile_data);
+	dev_info(&state->client->dev, "frame_profile size = %d \n",size);
+	while (i < size)
+	{
+		if(size - i >= 10){
+			num =10;
+			ret = orbbec_get_frame_profile_data(state, orbbec_frame_profile_t, i*sizeof(struct orbbec_frame_profile_data),num*sizeof(struct orbbec_frame_profile_data));
+			i += 10;
+		}else {
+			num = size - i;
+			ret = orbbec_get_frame_profile_data(state, orbbec_frame_profile_t, i*sizeof(struct orbbec_frame_profile_data),num*sizeof(struct orbbec_frame_profile_data));
+			i += size - i;
+		}
+		
+		for (n =0; n < num;n++){
+			switch ((orbbec_frame_profile_t+n)->orbbec_sensor_type)
+			{
+				case SENSOR_IR:
+				case SENSOR_LEFT_IR:
+				case SENSOR_RIGHT_IR:
+					orbbec_format_t = orb_mono_formats;
+					orb_formats_num = &orb_mono_formats_num;
+					if(get_ir_frame_profile_flag == 0) get_ir_frame_profile_flag = (orbbec_frame_profile_t+n)->orbbec_sensor_type;
+					break;	
+				case SENSOR_COLOR:
+					orbbec_format_t = orb_rgb_formats;
+					orb_formats_num = &orb_rgb_formats_num;
+					break;
+				case SENSOR_DEPTH:
+					orbbec_format_t = orb_depth_formats;
+					orb_formats_num = &orb_depth_formats_num;
+					break;
+				default :
+					break;
+			}
+
+			dev_dbg(&state->client->dev, "n = %d \n",n);
+			dev_dbg(&state->client->dev, "sensor_type = %d \n",(orbbec_frame_profile_t+n)->orbbec_sensor_type);
+			dev_dbg(&state->client->dev, "pixel_format = %d \n",(orbbec_frame_profile_t+n)->orbbec_pixel_format);
+			dev_dbg(&state->client->dev, "height = %d \n",(orbbec_frame_profile_t+n)->height);
+			dev_dbg(&state->client->dev, "width = %d \n",(orbbec_frame_profile_t+n)->width);
+			dev_dbg(&state->client->dev, "max_rate = %d \n",(orbbec_frame_profile_t+n)->max_rate);
+			dev_dbg(&state->client->dev, "formats_num = %d \n",*orb_formats_num);
+			if(state->device_info.pid == 0x80b && orbbec_format_t == orb_rgb_formats ) {
+				if((orbbec_frame_profile_t+n)->width == 1920 || (orbbec_frame_profile_t+n)->width == 960 || (orbbec_frame_profile_t+n)->width == 320) continue;
+			}
+			if(orbbec_format_t == orb_mono_formats && get_ir_frame_profile_flag != (orbbec_frame_profile_t+n)->orbbec_sensor_type) continue;
+			if(*orb_formats_num > 2) continue;
+
+			if(*orb_formats_num == 0){
+				(orbbec_format_t+*orb_formats_num)->mbus_code = orb_mbus_code_map[(orbbec_frame_profile_t+n)->orbbec_pixel_format].map_mbus_code;
+				(orbbec_format_t+*orb_formats_num)->data_type = orb_mbus_code_map[(orbbec_frame_profile_t+n)->orbbec_pixel_format].map_data_type;
+				orbbec_resolutions_t = (orbbec_format_t+*orb_formats_num)->resolutions;
+				orb_resolutions_num = &(orbbec_format_t+*orb_formats_num)->n_resolutions;
+				*orb_formats_num=*orb_formats_num + 1; 
+			}else{
+				
+				for(f = 0;f < *orb_formats_num;f++){
+					if((orbbec_format_t+f)->mbus_code == orb_mbus_code_map[(orbbec_frame_profile_t+n)->orbbec_pixel_format].map_mbus_code){
+						orbbec_resolutions_t = (orbbec_format_t+f)->resolutions;
+						orb_resolutions_num = &(orbbec_format_t+f)->n_resolutions;
+						break;
+					}
+				}
+				
+				
+				if(f == *orb_formats_num && (orbbec_format_t+f-1)->mbus_code != orb_mbus_code_map[(orbbec_frame_profile_t+n)->orbbec_pixel_format].map_mbus_code){
+					(orbbec_format_t+*orb_formats_num)->mbus_code = orb_mbus_code_map[(orbbec_frame_profile_t+n)->orbbec_pixel_format].map_mbus_code;
+					(orbbec_format_t+*orb_formats_num)->data_type = orb_mbus_code_map[(orbbec_frame_profile_t+n)->orbbec_pixel_format].map_data_type;
+					orbbec_resolutions_t = (orbbec_format_t+*orb_formats_num)->resolutions;
+					orb_resolutions_num = &(orbbec_format_t+*orb_formats_num)->n_resolutions;
+					*orb_formats_num=*orb_formats_num + 1; 
+				}
+								
+			}
+			if(*orb_resolutions_num == 10) continue;
+			(orbbec_resolutions_t+*orb_resolutions_num)->width = (uint16_t)(orbbec_frame_profile_t+n)->width;
+			(orbbec_resolutions_t+*orb_resolutions_num)->height = (uint16_t)(orbbec_frame_profile_t+n)->height;
+			
+			switch((orbbec_frame_profile_t+n)->max_rate){
+				case 30:
+					if(state->device_info.pid == 0xA13 || state->device_info.pid == 0x813){
+						(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_10_30;
+					    (orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_10_30);
+					}else{
+						(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_30;
+					    (orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_30);
+					}
+					break;
+
+				case 60:
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_60;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_60);
+					break;
+
+				case 90:
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_90;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_90);
+					break;
+				case 100:
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_100;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_100);
+					break;
+				default:
+					break;
+			}
+
+			*orb_resolutions_num = *orb_resolutions_num + 1;
+		}
+		
+	}
+	err_6:
+	devm_kfree(&state->client->dev, orbbec_frame_profile_t);
+	return ret;
+}
+
+static int orb_board_setup(struct orb *state)
+{
+	struct device *dev = &state->client->dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *ser_node;
+	struct i2c_client *ser_i2c = NULL;
+	struct device_node *dser_node;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *gmsl;
+	struct device_node *mode;
+	int value = 0xFFFF;
+	const char *str_value;
+	int err = 0;
+	const char *str;
+
+
+	err = of_property_read_u32(node, "reg", &state->g_ctx.sdev_reg);
+	if (err < 0) {
+		dev_err(dev, "reg not found\n");
+		goto error;
+	}
+
+	err = of_property_read_u32(node, "def-addr",
+					&state->g_ctx.sdev_def);
+	if (err < 0) {
+		dev_err(dev, "def-addr not found\n");
+		goto error;
+	}
+
+	ser_node = of_parse_phandle(node, "maxim,gmsl-ser-device", 0);
+	if (ser_node == NULL) {
+		/* check compatibility with jetpack */
+		ser_node = of_parse_phandle(node, "nvidia,gmsl-ser-device", 0);
+		if (ser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "[maxim|nvidia],gmsl-ser-device");
+			goto error;
+		}
+	}
+	err = of_property_read_u32(ser_node, "reg", &state->g_ctx.ser_reg);
+	if (err < 0) {
+		dev_err(dev, "serializer reg not found\n");
+		goto error;
+	}
+
+	if(state->g_ctx.ser_reg == 0x42){
+		dev_dbg(&state->client->dev,"state->client->addr ori=0x%02x\n", state->client->addr);
+		state->g_ctx.sdev_reg = 0x1a;
+		state->client->addr = 0x1a;
+		dev_dbg(&state->client->dev,"state->client->addr change to 0x%02x\n", state->client->addr);
+	}else if(state->g_ctx.ser_reg == 0x60){
+		dev_dbg(&state->client->dev,"state->client->addr ori=0x%02x\n", state->client->addr);
+		state->g_ctx.sdev_reg = 0x1b;
+		state->client->addr = 0x1b;
+		dev_dbg(&state->client->dev,"state->client->addr change to 0x%02x\n", state->client->addr);
+	}
+
+	ser_i2c = of_find_i2c_device_by_node(ser_node);
+	of_node_put(ser_node);
+
+	if (ser_i2c == NULL) {
+		err = -EPROBE_DEFER;
+		goto error;
+	}
+	if (ser_i2c->dev.driver == NULL) {
+		dev_err(dev, "missing serializer driver\n");
+		goto error;
+	}
+
+	state->ser_dev = &ser_i2c->dev;
+
+	dser_node = of_parse_phandle(node, "maxim,gmsl-dser-device", 0);
+	if (dser_node == NULL) {
+		dser_node = of_parse_phandle(node, "nvidia,gmsl-dser-device", 0);
+		if (dser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "[maxim|nvidia],gmsl-dser-device");
+			goto error;
+		}
+	}
+
+	dser_i2c = of_find_i2c_device_by_node(dser_node);
+	of_node_put(dser_node);
+
+	if (dser_i2c == NULL) {
+		err = -EPROBE_DEFER;
+		goto error;
+	}
+	if (dser_i2c->dev.driver == NULL) {
+		dev_err(dev, "missing deserializer driver\n");
+		goto error;
+	}
+
+	state->dser_dev = &dser_i2c->dev;
+
+	/* populate g_ctx from DT */
+	gmsl = of_get_child_by_name(node, "gmsl-link");
+	if (gmsl == NULL) {
+		dev_err(dev, "missing gmsl-link device node\n");
+		err = -EINVAL;
+	}
+
+	err = of_property_read_string(gmsl, "dst-csi-port", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No dst-csi-port found\n");
+		goto error;
+	}
+	state->g_ctx.dst_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+	err = of_property_read_string(gmsl, "src-csi-port", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No src-csi-port found\n");
+		goto error;
+	}
+	state->g_ctx.src_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+	err = of_property_read_string(gmsl, "csi-mode", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No csi-mode found\n");
+		goto error;
+	}
+
+	if (!strcmp(str_value, "1x4")) {
+		state->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+	} else if (!strcmp(str_value, "2x4")) {
+		state->g_ctx.csi_mode = GMSL_CSI_2X4_MODE;
+	} else if (!strcmp(str_value, "4x2")) {
+		state->g_ctx.csi_mode = GMSL_CSI_4X2_MODE;
+	} else if (!strcmp(str_value, "2x2")) {
+		state->g_ctx.csi_mode = GMSL_CSI_2X2_MODE;
+	} else {
+		dev_err(dev, "invalid csi mode\n");
+		goto error;
+	}
+
+	err = of_property_read_string(gmsl, "serdes-csi-link", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No serdes-csi-link found\n");
+		goto error;
+	}
+	state->g_ctx.serdes_csi_link =
+		(!strcmp(str_value, "a")) ?
+			GMSL_SERDES_CSI_LINK_A : GMSL_SERDES_CSI_LINK_B;
+
+	err = of_property_read_u32(gmsl, "st-vc", &value);
+	if (err < 0) {
+		dev_err(dev, "No st-vc info\n");
+		goto error;
+	}
+	state->g_ctx.st_vc = value;
+
+	err = of_property_read_u32(gmsl, "vc-id", &value);
+	if (err < 0) {
+		dev_err(dev, "No vc-id info\n");
+		goto error;
+	}
+	state->g_ctx.dst_vc = value;
+
+	err = of_property_read_u32(gmsl, "num-lanes", &value);
+	if (err < 0) {
+		dev_err(dev, "No num-lanes info\n");
+		goto error;
+	}
+	state->g_ctx.num_csi_lanes = value;
+	state->g_ctx.s_dev = dev;
+
+	mode = of_get_child_by_name(node, "mode0");
+	if (gmsl == NULL) {
+		dev_err(dev, "missing mode0 device node\n");
+		err = -EINVAL;
+	}
+
+	/* embedded_metadata_height is optional */
+	err = read_property_u32(mode, "embedded_metadata_height", &value);
+	if (err)
+		state->embedded_metadata_height = 0;
+	else
+		state->embedded_metadata_height = value;
+
+	state->is_depth = 0;
+	state->is_ir_l = 0;
+	state->is_ir_r = 0;
+	state->is_rgb = 0;
+
+	err = of_property_read_string(node, "cam-type",	&str);
+
+	if (!err && !strncmp(str, "Depth", strlen("Depth"))){
+		state->is_depth = 1;
+		state->device_info.video_type = ORB_MUX_PAD_DEPTH;
+		orbbec_communicate_finish_flag = 0;
+	}
+	if (!err && !strncmp(str, "IR_L", strlen("IR_L"))){
+		state->is_ir_l = 1;
+		state->device_info.video_type = ORB_MUX_PAD_IR_L_T;
+	}
+	if (!err && !strncmp(str, "IR_R", strlen("IR_R"))){
+		state->is_ir_r = 1;
+		state->device_info.video_type = ORB_MUX_PAD_IR_R_T;
+	}
+	if (!err && !strncmp(str, "RGB", strlen("RGB"))){
+		state->is_rgb = 1;
+		state->device_info.video_type = ORB_MUX_PAD_RGB;
+	}
+
+	state->device_info.vid = 0x2bc5;
+	err = of_property_read_u32(node, "orbbec_cam_num", &state->device_info.cam_num);
+	if (err < 0) {
+		dev_err(dev, "orbbec_cam_num not found\n");
+		goto error;
+	}
+
+error:
+	return err;
+}
+
+static struct mutex serdes_lock__;
+
+static int orb_gmsl_serdes_setup(struct orb *state)
+{
+	int err = 0;
+	int des_err = 0;
+	struct device *dev;
+
+	if (!state || !state->ser_dev || !state->dser_dev || !state->client)
+		return -EINVAL;
+
+	dev = &state->client->dev;
+
+	mutex_lock(&serdes_lock__);
+
+	max9296_power_on(state->dser_dev);
+
+	dev_dbg(dev, "Setup SERDES addressing and control pipeline\n");
+	/* setup serdes addressing and control pipeline */
+	err = max9296_setup_link(state->dser_dev, &state->client->dev);
+	if (err) {
+		dev_err(dev, "gmsl deserializer link config failed\n");
+		goto error;
+	}
+	msleep(100);
+	err = max9295_setup_control(state->ser_dev);
+
+	/* proceed even if ser setup failed, to setup deser correctly */
+	if (err)
+		dev_err(dev, "gmsl serializer setup failed\n");
+
+	des_err = max9296_setup_control(state->dser_dev, &state->client->dev);
+	if (des_err) {
+		dev_err(dev, "gmsl deserializer setup failed\n");
+		/* overwrite err only if deser setup also failed */
+		err = des_err;
+	}
+
+error:
+	mutex_unlock(&serdes_lock__);
+	return err;
+}
+
+static int orb_serdes_setup(struct orb *state)
+{
+	int ret = 0;
+	struct i2c_client *c = state->client;
+	ret = orb_board_setup(state);
+	if (ret) {
+		dev_err(&c->dev, "board setup failed\n");
+		return ret;
+	}
+	if(probe_cam_num == state->device_info.cam_num) 
+		return 0;
+	else 
+		probe_cam_num = state->device_info.cam_num;
+
+	/* Pair sensor to serializer dev */
+	ret = max9295_sdev_pair(state->ser_dev, &state->g_ctx);
+	if (ret) {
+		dev_err(&c->dev, "gmsl ser pairing failed\n");
+		return ret;
+	}
+
+	/* Register sensor to deserializer dev */
+	ret = max9296_sdev_register(state->dser_dev, &state->g_ctx);
+	if (ret) {
+		dev_err(&c->dev, "gmsl deserializer register failed\n");
+		goto err_unpair;
+	}
+
+	ret = orb_gmsl_serdes_setup(state);
+	if (ret) {
+		dev_err(&c->dev, "%s gmsl serdes setup failed\n", __func__);
+		goto err_register;
+	}
+
+	ret = max9295_init_settings(state->ser_dev);
+
+	if (ret) {
+		dev_err(&c->dev, "%s, failed to init max9295 settings\n",
+			__func__);
+		goto err_register;
+	}
+	/*reset Orbbec cammera*/
+	ret = max9295_set_orbbec_off(state->ser_dev);
+	msleep(3000);
+	ret = max9295_set_orbbec_on(state->ser_dev);
+	if (ret) {
+		dev_err(&c->dev, "%s, failed to max9295 set_orbbec_on\n",
+			__func__);
+		goto err_register;
+	}
+	msleep(10);
+	ret = max9296_init_settings(state->dser_dev);
+	if (ret) {
+		dev_err(&c->dev, "%s, failed to init max9296 settings\n",
+			__func__);
+		goto err_register;
+	}
+
+	return ret;
+	err_register:
+	max9296_sdev_unregister(state->dser_dev, state->g_ctx.s_dev);
+	err_unpair:
+	max9295_sdev_unpair(state->ser_dev, state->g_ctx.s_dev);
+
+	return ret;
+}
+
+static int orbbec_reset_device_link(struct orb *state, s32 value){
+	int ret = 0;
+	struct i2c_client *c = state->client;
+	
+	if(state->ser_dev){
+		if(value == 0) {
+			ret = max9295_set_orbbec_off(state->ser_dev);
+			if(state->is_depth){
+				ret = max9296_reset_control(state->dser_dev, state->g_ctx.s_dev);
+				if (ret)
+					dev_warn(&c->dev,  "failed in 9296 reset control\n");
+				max9295_sdev_unpair(state->ser_dev, state->g_ctx.s_dev);
+				max9296_sdev_unregister(state->dser_dev, state->g_ctx.s_dev);
+			}
+		}
+		else {
+			if(state->is_depth){
+				ret = max9295_sdev_pair(state->ser_dev, &state->g_ctx);
+				if (ret) {
+					dev_err(&c->dev, "gmsl ser pairing failed\n");
+					return ret;
+				}
+
+				/* Register sensor to deserializer dev */
+				ret = max9296_sdev_register(state->dser_dev, &state->g_ctx);
+				if (ret) {
+					dev_err(&c->dev, "gmsl deserializer register failed\n");
+					goto err_unpair;
+				}
+
+				ret = orb_gmsl_serdes_setup(state);
+				if (ret) {
+					dev_err(&c->dev, "%s gmsl serdes setup failed\n", __func__);
+					goto err_register;
+				}
+				
+				ret = max9295_init_settings(state->ser_dev);
+				if (ret) {
+					dev_err(&c->dev, "%s, failed to init max9295 settings\n",
+						__func__);
+					goto err_register;
+				}
+
+				ret = max9296_init_settings(state->dser_dev);
+				if (ret) {
+					dev_err(&c->dev, "%s, failed to init max9296 settings\n",
+						__func__);
+					goto err_register;
+				}
+			}
+
+			ret = max9295_set_orbbec_on(state->ser_dev);
+			if (ret) {
+				dev_err(&c->dev, "%s, failed to max9295 set_orbbec_on\n",
+					__func__);
+				goto err_register;
+			}
+		}
+	}else{
+		return -1;
+	}
+	return 0;
+	err_register:
+	max9296_sdev_unregister(state->dser_dev, state->g_ctx.s_dev);
+	err_unpair:
+	max9295_sdev_unpair(state->ser_dev, state->g_ctx.s_dev);
+	return ret;
+}
+
+static int orbbec_set_exposure(struct orb *state, s32 data){
+	int ret;
+	int prop_id;
+	struct orbbec_cmd *set_exposure_cmd;
+	set_exposure_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!set_exposure_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+
+		return ret;
+	}
+	if(state->is_depth){
+		prop_id = 2017;
+	}
+	if(state->is_rgb){
+		prop_id = 2001;
+	}
+	if(state->is_ir_l || state->is_ir_r){
+		prop_id = 2026;
+	}
+	set_exposure_cmd->header.len = G2R_SET_PROPERTY_CMD_LEN;
+	set_exposure_cmd->header.code = G2R_SET_PROPERTY_CODE;
+	set_exposure_cmd->header.index = index++;
+	set_exposure_cmd->_data[0] = prop_id;
+	set_exposure_cmd->_data[1] = prop_id >>8;
+	set_exposure_cmd->_data[2] = prop_id >>16;
+	set_exposure_cmd->_data[3] = prop_id >>24;
+	set_exposure_cmd->_data[4] = data;
+	set_exposure_cmd->_data[5] = data >>8;
+	set_exposure_cmd->_data[6] = data >>16;
+	set_exposure_cmd->_data[7] = data >>24;
+	
+	ret = i2c_write_orbbec(state->client,set_exposure_cmd, G2R_SET_PROPERTY_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_2;
+	}
+err_2:
+	devm_kfree(&state->client->dev, set_exposure_cmd);
+	return ret;
+}
+
+static int orbbec_get_exposure(struct orb *state, void * data){
+	int ret;
+	int prop_id;
+	struct orbbec_cmd *get_exposure_cmd;
+	get_exposure_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_exposure_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	if(state->is_depth){
+		prop_id = 2017;
+	}
+	if(state->is_rgb){
+		prop_id = 2001;
+	}
+	if(state->is_ir_l || state->is_ir_r){
+		prop_id = 2026;
+	}
+	get_exposure_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+	get_exposure_cmd->header.code = G2R_GET_PROPERTY_CODE;
+	get_exposure_cmd->header.index = index++;
+	get_exposure_cmd->_data[0] = prop_id;
+	get_exposure_cmd->_data[1] = prop_id >>8;
+	get_exposure_cmd->_data[2] = prop_id >>16;
+	get_exposure_cmd->_data[3] = prop_id >>24;
+	
+	ret = i2c_write_orbbec(state->client,get_exposure_cmd, G2R_GET_PROPERTY_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_1;
+	}
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_exposure_cmd, sizeof(struct orbbec_header)+6);
+	memcpy(data, get_exposure_cmd->msg_body1.data, 4);
+err_1:
+	devm_kfree(&state->client->dev, get_exposure_cmd);
+	return ret;
+}
+
+static int orbbec_get_exposure_init(struct orb *state, void * data){
+	int ret;
+	int prop_id;
+	struct orbbec_cmd *get_exposure_cmd;
+	get_exposure_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_exposure_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	if(state->is_depth){
+		prop_id = 2017;
+	}
+	if(state->is_rgb){
+		prop_id = 2001;
+	}
+	if(state->is_ir_l || state->is_ir_r){
+		prop_id = 2026;
+	}
+	get_exposure_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+	get_exposure_cmd->header.code = G2R_GET_PROPERTY_CODE;
+	get_exposure_cmd->header.index = index++;
+	get_exposure_cmd->_data[0] = prop_id;
+	get_exposure_cmd->_data[1] = prop_id >>8;
+	get_exposure_cmd->_data[2] = prop_id >>16;
+	get_exposure_cmd->_data[3] = prop_id >>24;
+	
+	ret = i2c_write_orbbec(state->client,get_exposure_cmd, G2R_GET_PROPERTY_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_1;
+	}
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_exposure_cmd, G2R_GET_PROPERTY_DATA_LEN);
+	memcpy(data, get_exposure_cmd->msg_body1.data, 20);
+err_1:
+	devm_kfree(&state->client->dev, get_exposure_cmd);
+	return ret;
+}
+
+static int orbbec_get_ctpu_init(struct orb *state,uint8_t ctpu_select, uint8_t irrgb_select, uint8_t ctpu_id, void * data){
+	int ret;
+	struct orbbec_cmd *get_pu_cmd;
+	get_pu_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_pu_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_pu_cmd->header.len = G2R_GET_PU_CMD_LEN;
+	get_pu_cmd->header.code = G2R_GET_CTPU_INIT_CODE;
+	get_pu_cmd->header.index = index++;
+	get_pu_cmd->_data[0] = ctpu_select+ctpu_id;
+	get_pu_cmd->_data[1] = irrgb_select;
+
+	ret = i2c_write_orbbec(state->client,get_pu_cmd, G2R_GET_PU_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		return ret;
+	}
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_pu_cmd, G2R_GET_PU_INIT_LEN);
+	memcpy(data, get_pu_cmd->msg_body1.data, sizeof(struct ctpu_data));
+	devm_kfree(&state->client->dev, get_pu_cmd);
+	return ret;
+}
+
+static int orbbec_get_ctpu(struct orb *state, uint8_t ctpu_select, uint8_t irrgb_select, uint8_t ctpu_id, void * data, uint8_t len){
+	int ret;
+	struct orbbec_cmd *get_pu_cmd;
+	get_pu_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_pu_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_pu_cmd->header.len = G2R_GET_PU_CMD_LEN;
+	get_pu_cmd->header.code = G2R_GET_CTPU_CODE;
+	get_pu_cmd->header.index = index++;
+	get_pu_cmd->_data[0] = ctpu_select+ctpu_id;
+	get_pu_cmd->_data[1] = irrgb_select;
+
+	ret = i2c_write_orbbec(state->client,get_pu_cmd, G2R_GET_PU_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		return ret;
+	}
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_pu_cmd, G2R_I2C_RESPONSE_HEARD_LEN+len);
+	memcpy(data, get_pu_cmd->msg_body1.data, len);
+	devm_kfree(&state->client->dev, get_pu_cmd);
+	return ret;
+}
+
+static int orbbec_set_autoexposure(struct orb *state, s32 data){
+	int ret;
+	struct orbbec_cmd *set_autoexposure_cmd;
+	set_autoexposure_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!set_autoexposure_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	set_autoexposure_cmd->header.len = G2R_SET_PROPERTY_CMD_LEN;
+	set_autoexposure_cmd->header.code = G2R_SET_PROPERTY_CODE;
+	set_autoexposure_cmd->header.index = index++;
+	set_autoexposure_cmd->_data[0] = 0xE0;
+	set_autoexposure_cmd->_data[1] = 0x07;
+	set_autoexposure_cmd->_data[2] = 0x00;
+	set_autoexposure_cmd->_data[3] = 0x00;
+	if(data == V4L2_EXPOSURE_AUTO){
+		set_autoexposure_cmd->_data[4] = 1;
+		set_autoexposure_cmd->_data[5] = 0;
+	}
+	else if(data == V4L2_EXPOSURE_MANUAL){
+		set_autoexposure_cmd->_data[4] = 0;
+		set_autoexposure_cmd->_data[5] = 0;
+	}
+
+	ret = i2c_write_orbbec(state->client,set_autoexposure_cmd, G2R_SET_PROPERTY_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		goto err_3;
+	}
+err_3:
+	devm_kfree(&state->client->dev, set_autoexposure_cmd);
+	return ret;
+}
+
+static int orbbec_get_autoexposure(struct orb *state, void * data){
+	int ret;
+	struct orbbec_cmd *get_autoexposure_cmd;
+	get_autoexposure_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!get_autoexposure_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	get_autoexposure_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+	get_autoexposure_cmd->header.code = G2R_GET_PROPERTY_CODE;
+	get_autoexposure_cmd->header.index = index++;
+	get_autoexposure_cmd->_data[0] = 0xE0;
+	get_autoexposure_cmd->_data[1] = 0x07;
+	get_autoexposure_cmd->_data[2] = 0x00;
+	get_autoexposure_cmd->_data[3] = 0x00;
+
+
+	ret = i2c_write_orbbec(state->client,get_autoexposure_cmd, G2R_GET_PROPERTY_CMD_LEN);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		return ret;
+	}
+	usleep_range(100,120);
+	ret = i2c_read_orbbec(state->client, get_autoexposure_cmd, G2R_GET_PROPERTY_DATA_LEN);
+	memcpy(data, get_autoexposure_cmd->msg_body1.data, 2);
+	devm_kfree(&state->client->dev, get_autoexposure_cmd);
+	return ret;
+}
+
+static int orbbec_set_ctpu(struct orb *state,uint8_t ctpu_select, uint8_t irrgb_select, uint8_t ctpu_id, int value, uint8_t len){
+	int ret;
+	struct orbbec_cmd *set_pu_cmd;
+	set_pu_cmd = devm_kzalloc(&state->client->dev,
+	sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!set_pu_cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	set_pu_cmd->header.len = sizeof(struct orbbec_header)+CTPU_PROID_LEN+len;
+	set_pu_cmd->header.code = G2R_SET_CTPU_CODE;
+	set_pu_cmd->header.index = index++;
+	set_pu_cmd->_data[0] = ctpu_select+ctpu_id;
+	set_pu_cmd->_data[1] = irrgb_select;
+	set_pu_cmd->_data[2] = value;
+	set_pu_cmd->_data[3] = value >> 8;
+	set_pu_cmd->_data[4] = value >> 16;
+	set_pu_cmd->_data[5] = value >> 24;
+
+	ret = i2c_write_orbbec(state->client,set_pu_cmd, sizeof(struct orbbec_header)+CTPU_PROID_LEN+len);
+	if(ret < 0){
+		printk(KERN_DEBUG "\n i2c write cmd err \n");
+		return ret;
+	}
+	devm_kfree(&state->client->dev, set_pu_cmd);
+	return ret;
+}
+
+static int orb_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct orb *state = container_of(ctrl->handler, struct orb,
+					 ctrls.handler);
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret = 0;
+	struct orbbec_cmd *get_cmd = NULL;
+
+	mutex_lock(&state->lock);
+
+	get_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+	dev_dbg(&state->client->dev, "%s(): ctrl: %s \n",
+		__func__, ctrl->name);
+
+	v4l2_dbg(3, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_GAIN:
+		if (state->is_depth || state->is_ir_l || state->is_ir_r) {
+			orbbec_set_ctpu(state, PU_CONTROL_SELECT, IR_CONTROL_SELECT, PU_GAIN_CONTROL, ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+		}else if (state->is_rgb){
+			orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAIN_CONTROL, ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+		}
+		break;
+	case V4L2_CID_BACKLIGHT_COMPENSATION:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BACKLIGHT_COMPENSATION_CONTROL, ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+		break;
+
+	case V4L2_CID_BRIGHTNESS:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BRIGHTNESS_CONTROL, ctrl->val, pu_ctl_len[PU_BRIGHTNESS_CONTROL]);
+		break;	
+	
+	case V4L2_CID_CONTRAST:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_CONTRAST_CONTROL, ctrl->val, pu_ctl_len[PU_CONTRAST_CONTROL]);
+		break;
+		
+	case V4L2_CID_EXPOSURE_AUTO:
+		if (state->is_rgb) {
+			if(ctrl->val == V4L2_EXPOSURE_AUTO){
+				orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_AUTO_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+			}
+			else if(ctrl->val == V4L2_EXPOSURE_MANUAL){
+				orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_MANUL_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+			}
+		}
+		if (state->is_ir_l || state->is_ir_r){
+			if(ctrl->val == V4L2_EXPOSURE_AUTO){
+				orbbec_set_ctpu(state, CT_CONTROL_SELECT, IR_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_AUTO_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+			}
+			else if(ctrl->val == V4L2_EXPOSURE_MANUAL){
+				orbbec_set_ctpu(state, CT_CONTROL_SELECT, IR_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_MANUL_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+			}
+		}
+		if (state->is_depth){
+			ret = orbbec_set_autoexposure(state, ctrl->val);
+		}
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		if (state->is_depth || state->is_ir_l || state->is_ir_r){
+			ret = orbbec_set_exposure(state, ctrl->val);
+		}else if(state->is_rgb){
+			orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, ctrl->val, ct_ctl_len[CT_EXPOSURE_TIME_ABSOLUTE_CONTROL]);	
+		}
+		break;
+
+	case V4L2_CID_GAMMA:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAMMA_CONTROL, ctrl->val, pu_ctl_len[PU_GAMMA_CONTROL]);	
+		break;
+
+	case V4L2_CID_HUE:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_HUE_CONTROL, ctrl->val, pu_ctl_len[PU_HUE_CONTROL]);	
+		break;
+
+	case V4L2_CID_SATURATION:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SATURATION_CONTROL, ctrl->val, pu_ctl_len[PU_SATURATION_CONTROL]);	
+		break;
+
+	case V4L2_CID_SHARPNESS:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SHARPNESS_CONTROL, ctrl->val, pu_ctl_len[PU_SHARPNESS_CONTROL]);	
+		break;
+
+	case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_CONTROL, ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_CONTROL]);	
+		break;
+
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL, ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL]);	
+		break;
+
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_POWER_LINE_FREQUENCY_CONTROL, ctrl->val, pu_ctl_len[PU_POWER_LINE_FREQUENCY_CONTROL]);	
+		break;
+	
+	case V4L2_CID_EXPOSURE_AUTO_PRIORITY:
+		orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_PRIORITY_CONTROL, ctrl->val, ct_ctl_len[CT_AE_PRIORITY_CONTROL]);	
+		break;
+
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_FOCUS_ABSOLUTE_CONTROL, ctrl->val, ct_ctl_len[CT_FOCUS_ABSOLUTE_CONTROL]);	
+		break;
+
+	case ORBBEC_CAMERA_CID_SET_DATA:
+		dev_dbg(&state->client->dev,"%s(): G2R set size \n",__func__);
+		if (ctrl->p_new.p_u8) {
+			memcpy(get_cmd, ctrl->p_new.p_u8, sizeof(struct orbbec_header)+8);
+			dev_dbg(&state->client->dev,
+					"%s(): G2R set opcode=%d, proid=%d\n",
+					__func__, get_cmd->header.code, get_cmd->set_imu_cmd.prop_code0);
+			//save imu_fps
+			if(get_cmd->header.code == 2 && get_cmd->set_imu_cmd.prop_code0 == 2021){
+				state->imu_fps = orb_imu_framerates[get_cmd->set_imu_cmd.value0];
+				dev_dbg(&state->client->dev,"%s(): imu_fps=%d \n",
+					__func__, state->imu_fps);
+			}  
+			ret = i2c_write_orbbec(state->client,(u8*)ctrl->p_new.p_u8, get_cmd->header.len);
+		}
+		break;
+
+	case ORBBEC_CAMERA_CID_SET_DATA_LEN:
+		if (ctrl->val) {
+			get_data_len = ctrl->val;
+			dev_dbg(&state->client->dev,
+					"%s(): G2R set get data len= %d\n",
+					__func__, get_data_len);
+		}
+		break;
+	
+	case ORBBEC_CAMERA_CID_RESET_DEVICE_LINK:
+		dev_dbg(&state->client->dev,"%s(): G2R reset device link\n",
+			__func__);
+		ret = orbbec_reset_device_link(state, 0);
+		msleep_range(3000);
+		ret = orbbec_reset_device_link(state, 1);
+		msleep_range(3000);
+		dev_dbg(&state->client->dev,"%s(): G2R reset device link finish\n",
+			__func__);
+		
+		break;
+
+	case ORBBEC_CAMERA_CID_RESET_DEVICE:
+		dev_dbg(&state->client->dev,"%s(): G2R reset device\n",
+			__func__);
+		ret = max9295_set_orbbec_off(state->ser_dev);
+		msleep_range(3000);
+		ret = max9295_set_orbbec_on(state->ser_dev);
+		msleep_range(3000);
+		dev_dbg(&state->client->dev,"%s(): G2R reset device finish\n",
+			__func__);
+		
+		break;
+
+	}
+	
+	devm_kfree(&state->client->dev, get_cmd);
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+static int orb_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct orb *state = container_of(ctrl->handler, struct orb,
+			ctrls.handler);
+	int16_t temp;
+	int ret = 0, err = 0;
+	u16 reg;
+
+	dev_dbg(&state->client->dev, "%s(): ctrl: %s \n",
+		__func__, ctrl->name);
+	mutex_lock(&state->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_GAIN:
+		if (state->is_depth || state->is_ir_l || state->is_ir_r) {
+			orbbec_get_ctpu(state, PU_CONTROL_SELECT, IR_CONTROL_SELECT, PU_GAIN_CONTROL, &ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+		}else if (state->is_rgb){
+			orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAIN_CONTROL, &ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+		}	
+		break;
+
+	case V4L2_CID_BACKLIGHT_COMPENSATION:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BACKLIGHT_COMPENSATION_CONTROL, &ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+		break;
+
+	case V4L2_CID_BRIGHTNESS:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BRIGHTNESS_CONTROL, &temp, pu_ctl_len[PU_BRIGHTNESS_CONTROL]);
+		ctrl->val = temp;
+		break;	
+	
+	case V4L2_CID_CONTRAST:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_CONTRAST_CONTROL, &ctrl->val, pu_ctl_len[PU_CONTRAST_CONTROL]);
+		break;	
+	case V4L2_CID_EXPOSURE_AUTO:
+		if(state->is_depth){
+			orbbec_get_autoexposure(state, &reg);
+			if (reg == 1) ctrl->val = V4L2_EXPOSURE_AUTO;
+			else if (reg == 0) ctrl->val = V4L2_EXPOSURE_MANUAL;
+		}else if(state->is_rgb || state->is_ir_l || state->is_ir_r){
+			if(state->is_rgb){
+				orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, &ctrl->val, ct_ctl_len[CT_AE_MODE_CONTROL]);
+			}else {
+				orbbec_get_ctpu(state, CT_CONTROL_SELECT, IR_CONTROL_SELECT, CT_AE_MODE_CONTROL, &ctrl->val, ct_ctl_len[CT_AE_MODE_CONTROL]);
+			}
+			if(ctrl->val == CT_AE_AUTO_MODE || ctrl->val == CT_AE_APERTURE_MODE) ctrl->val = V4L2_EXPOSURE_AUTO;
+			else if(ctrl->val == CT_AE_MANUL_MODE || ctrl->val == CT_AE_SHUTTER_MODE) ctrl->val = V4L2_EXPOSURE_MANUAL;
+		}
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		if (state->is_depth || state->is_ir_l || state->is_ir_r){
+			ret = orbbec_get_exposure(state, &ctrl->val);
+		}else if(state->is_rgb){
+			ret = orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, &ctrl->val, ct_ctl_len[CT_EXPOSURE_TIME_ABSOLUTE_CONTROL]);
+		}
+		break;
+
+	case V4L2_CID_GAMMA:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAMMA_CONTROL, &ctrl->val, pu_ctl_len[PU_GAMMA_CONTROL]);	
+		break;
+
+	case V4L2_CID_HUE:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_HUE_CONTROL, &temp, pu_ctl_len[PU_HUE_CONTROL]);
+		ctrl->val = temp;
+		break;
+
+	case V4L2_CID_SATURATION:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SATURATION_CONTROL, &ctrl->val, pu_ctl_len[PU_SATURATION_CONTROL]);	
+		break;
+
+	case V4L2_CID_SHARPNESS:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SHARPNESS_CONTROL, &ctrl->val, pu_ctl_len[PU_SHARPNESS_CONTROL]);	
+		break;
+
+	case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_CONTROL, &ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_CONTROL]);	
+		break;
+
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL, &ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL]);	
+		break;
+
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_POWER_LINE_FREQUENCY_CONTROL, &ctrl->val, pu_ctl_len[PU_POWER_LINE_FREQUENCY_CONTROL]);	
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO_PRIORITY:
+		orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_PRIORITY_CONTROL, &ctrl->val, ct_ctl_len[CT_AE_PRIORITY_CONTROL]);	
+		break;
+
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_FOCUS_ABSOLUTE_CONTROL, &ctrl->val, ct_ctl_len[CT_FOCUS_ABSOLUTE_CONTROL]);	
+		break;
+
+	case ORBBEC_CAMERA_CID_GET_VERSION_DATA:
+		if (ctrl->p_new.p_u8) {
+			ret =orbbec_get_version(state, ctrl->p_new.p_u8);	
+		}
+		break;
+
+	case ORBBEC_CAMERA_CID_GET_IMU_FPS:
+		if (ctrl->p_new.p_u32) {
+			*ctrl->p_new.p_u32 = state->imu_fps;
+		}
+		break;
+
+	case ORBBEC_CAMERA_CID_GET_IMU_DATA:
+		if (ctrl->p_new.p_u8) {
+		ret =orbbec_get_imu_data(state, ctrl->p_new.p_u8);		
+		}
+		break;
+		
+	case ORBBEC_CAMERA_CID_GET_DATA:
+		dev_dbg(&state->client->dev,"%s(): G2R getdata\n",__func__);
+		if (ctrl->p_new.p_u8) {
+			ret = i2c_read_orbbec(state->client,(u8*)ctrl->p_new.p_u8 , get_data_len);
+		}
+		break;
+
+	case ORBBEC_CAMERA_CID_GET_PID_SN:
+		dev_dbg(&state->client->dev,"%s(): G2R getpidsn\n",__func__);
+		if (ctrl->p_new.p_u8) {
+			memcpy(ctrl->p_new.p_u8,&state->device_info, sizeof(struct orbbec_device_info));
+		}
+		break;
+
+	case ORBBEC_CAMERA_CID_GET_LINK_STATE:
+		/*
+		dev_dbg(&state->client->dev,"%s(): G2R get link state\n",__func__);
+		err = max9295_set_orbbec_on(state->ser_dev);
+		if (err) {
+			dev_err(&state->client->dev, "%s, failed to max9295 set_orbbec_on\n",
+				__func__);
+			ctrl->val = 0;
+		}else
+			ctrl->val = 1;
+		*/
+		err = max9296_get_link_state(state->dser_dev, &ctrl->val);
+		break;
+			
+	}
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops orb_ctrl_ops = {
+	.s_ctrl	= orb_s_ctrl,
+	.g_volatile_ctrl = orb_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_imu_fps = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_GET_IMU_FPS,
+	.name = "GET_IMU_FPS",
+	.type = V4L2_CTRL_TYPE_U32,
+	.dims = {1},
+	.elem_size = sizeof(u32),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 0,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};	
+	
+static const struct v4l2_ctrl_config g2r_ctrl_set_data = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_SET_DATA,
+	.name = "G2R_W",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {G2R_RW_DATA_LEN},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};	
+
+static const struct v4l2_ctrl_config g2r_ctrl_set_datalen = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_SET_DATA_LEN,
+	.name = "SET G2R_R LEN",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 256,
+	.step = 1,
+	.def = 256,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};	
+
+static const struct v4l2_ctrl_config g2r_ctrl_reset_device_link = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_RESET_DEVICE_LINK,
+	.name = "G2R_RESET_DEVICE_LINK",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_reset_device = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_RESET_DEVICE,
+	.name = "G2R_RESET_DEVICE",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_version_data = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_GET_VERSION_DATA,
+	.name = "G2R_GET_VERSION",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {G2R_GET_VERSION_DATA_LEN},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_data = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_GET_DATA,
+	.name = "G2R_R",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {G2R_RW_DATA_LEN},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 1,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+static const struct v4l2_ctrl_config g2r_ctrl_get_pid_sn = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_GET_PID_SN,
+	.name = "G2R_R_PID_SN",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {sizeof(struct orbbec_device_info)},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 1,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE |V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_imu_data = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_GET_IMU_DATA,
+	.name = "G2R_GET_IMU_DATA",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {G2R_I2C_RESPONSE_HEARD_LEN + G2R_GET_IMU_DATA_LEN * G2R_IMU_STOCK_MAX_SIZE},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_link_state = {
+	.ops = &orb_ctrl_ops,
+	.id = ORBBEC_CAMERA_CID_GET_LINK_STATE,
+	.name = "GET LINK STATE",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};	
+
+static int orb_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	return 0;
+};
+
+static int orb_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	return 0;
+};
+
+static const struct v4l2_subdev_internal_ops orb_sensor_internal_ops = {
+	.open = orb_mux_open,
+	.close = orb_mux_close,
+};
+
+static int orb_ctrl_init(struct orb *state)
+{
+	const struct v4l2_ctrl_ops *ops = &orb_ctrl_ops;
+	struct orb_ctrls *ctrls = &state->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct ctpu_data *ctpu_data_t = devm_kzalloc(&state->client->dev, sizeof(struct ctpu_data), GFP_KERNEL);
+	struct xu_data *xu_data_t = devm_kzalloc(&state->client->dev, sizeof(struct xu_data), GFP_KERNEL);
+	int ret;
+	ret = v4l2_ctrl_handler_init(hdl, ORB_N_CONTROLS);
+	if (ret < 0) {
+		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
+		goto err_ctl;
+	}
+
+	/* Total gain */
+	if (state->is_depth || state->is_ir_l || state->is_ir_r) {
+		orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, IR_CONTROL_SELECT, PU_GAIN_CONTROL, ctpu_data_t);
+		pu_ctl_len[PU_GAIN_CONTROL] = ctpu_data_t->len;
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_GAIN,
+						ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+		if (ctrls->gain){
+			switch (ctpu_data_t->info)
+			{
+			case 3:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+				break;
+			case 2:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+				break;
+			case 1:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+				break;
+			default:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+				break;
+			}
+		}
+	} else if (state->is_rgb) {
+		orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAIN_CONTROL, ctpu_data_t);
+		pu_ctl_len[PU_GAIN_CONTROL] = ctpu_data_t->len;
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_GAIN,
+						ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+		if (ctrls->gain){
+			switch (ctpu_data_t->info)
+			{
+			case 3:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+				break;
+			case 2:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+				break;
+			case 1:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+				break;
+			default:
+				ctrls->gain->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+				break;
+			}
+		}
+	}
+
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BACKLIGHT_COMPENSATION_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_BACKLIGHT_COMPENSATION_CONTROL] = ctpu_data_t->len;
+	ctrls->backlight = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_BACKLIGHT_COMPENSATION,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->backlight){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->backlight->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->backlight->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->backlight->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->backlight->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+	
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BRIGHTNESS_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_BRIGHTNESS_CONTROL] = ctpu_data_t->len;
+	ctrls->brightness = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_BRIGHTNESS,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->brightness){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->brightness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->brightness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->brightness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->brightness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_CONTRAST_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_CONTRAST_CONTROL] = ctpu_data_t->len;
+	ctrls->contrast = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_CONTRAST,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->contrast){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->contrast->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->contrast->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->contrast->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->contrast->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, ctpu_data_t);
+	ct_ctl_len[CT_AE_MODE_CONTROL] = ctpu_data_t->len;
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+			V4L2_CID_EXPOSURE_AUTO,
+			V4L2_EXPOSURE_MANUAL,
+			~((1 << V4L2_EXPOSURE_AUTO) |
+					(1 << V4L2_EXPOSURE_MANUAL)), 
+					V4L2_EXPOSURE_AUTO);
+	if (ctrls->auto_exp)
+		ctrls->auto_exp->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	/* Exposure time: V4L2_CID_EXPOSURE_ABSOLUTE default unit: 100 us. */
+	if (state->is_depth || state->is_ir_l || state->is_ir_r) {
+		orbbec_get_exposure_init(state,xu_data_t);
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					xu_data_t->min_xu, xu_data_t->max_xu, xu_data_t->step_xu, xu_data_t->def_xu);
+	} else if (state->is_rgb) {
+		orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, ctpu_data_t);
+		ct_ctl_len[CT_EXPOSURE_TIME_ABSOLUTE_CONTROL] = ctpu_data_t->len;
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	}
+
+	if (ctrls->exposure) {
+		ctrls->exposure->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+		/* override default int type to u32 to match SKU & UVC */
+		//ctrls->exposure->type = V4L2_CTRL_TYPE_U32;
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAMMA_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_GAMMA_CONTROL] = ctpu_data_t->len;
+	ctrls->gamma = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_GAMMA,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->gamma){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->gamma->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->gamma->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->gamma->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->gamma->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_HUE_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_HUE_CONTROL] = ctpu_data_t->len;
+	ctrls->hue = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_HUE,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->hue){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->hue->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->hue->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->hue->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->hue->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SATURATION_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_SATURATION_CONTROL] = ctpu_data_t->len;
+	ctrls->saturation = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_SATURATION,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->saturation){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->saturation->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->saturation->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->saturation->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->saturation->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SHARPNESS_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_SHARPNESS_CONTROL] = ctpu_data_t->len;
+	ctrls->sharpness = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_SHARPNESS,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->sharpness){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->sharpness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->sharpness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->sharpness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->sharpness->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_CONTROL] = ctpu_data_t->len;
+	ctrls->whitebalance = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->whitebalance){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->whitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->whitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->whitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->whitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL] = ctpu_data_t->len;
+	ctrls->autowhitebalance = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_AUTO_WHITE_BALANCE,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->autowhitebalance){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->autowhitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->autowhitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->autowhitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->autowhitebalance->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+	
+	orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_POWER_LINE_FREQUENCY_CONTROL, ctpu_data_t);
+	pu_ctl_len[PU_POWER_LINE_FREQUENCY_CONTROL] = ctpu_data_t->len;
+	ctrls->powerlinefreq = v4l2_ctrl_new_std_menu(hdl, ops,
+					V4L2_CID_POWER_LINE_FREQUENCY,
+					ctpu_data_t->max, ~((1 << V4L2_CID_POWER_LINE_FREQUENCY_AUTO) |
+					(1 << V4L2_CID_POWER_LINE_FREQUENCY_60HZ) | (1 << V4L2_CID_POWER_LINE_FREQUENCY_50HZ) | 
+					(1 << V4L2_CID_POWER_LINE_FREQUENCY_DISABLED)), ctpu_data_t->def);
+	if (ctrls->powerlinefreq){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->powerlinefreq->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->powerlinefreq->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->powerlinefreq->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->powerlinefreq->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+	
+	orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_PRIORITY_CONTROL, ctpu_data_t);
+	ct_ctl_len[CT_AE_PRIORITY_CONTROL] = ctpu_data_t->len;
+	ctrls->aepriority = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_AUTO_PRIORITY,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->aepriority){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->aepriority->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->aepriority->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->aepriority->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->aepriority->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+
+	/*
+	orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_FOCUS_ABSOLUTE_CONTROL, ctpu_data_t);
+	ct_ctl_len[CT_FOCUS_ABSOLUTE_CONTROL] = ctpu_data_t->len;
+	ctrls->focus_absolute = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_FOCUS_ABSOLUTE,
+					ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+	if (ctrls->focus_absolute){
+		switch (ctpu_data_t->info)
+		{
+		case 3:
+			ctrls->focus_absolute->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		case 2:
+			ctrls->focus_absolute->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+			break;
+		case 1:
+			ctrls->focus_absolute->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+			break;
+		default:
+			ctrls->focus_absolute->flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			break;
+		}
+	}
+	*/
+
+	if (hdl->error) {
+		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
+		ret = hdl->error;
+		v4l2_ctrl_handler_free(hdl);
+		goto err_ctl;
+	}
+	/*
+	//During the initialization of the V4L2 device, the setup control will be set to the default values of the current control parameters.
+	ret = v4l2_ctrl_handler_setup(hdl);
+	if (ret < 0) {
+		dev_err(&state->client->dev,
+			"failed to set default values for controls\n");
+		v4l2_ctrl_handler_free(hdl);
+		return ret;
+	}
+	*/
+	ctrls->set_date = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_set_data, NULL);
+	ctrls->set_datelen = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_set_datalen, NULL);
+	ctrls->reset_device_link = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_reset_device_link, NULL);
+	ctrls->reset_device = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_reset_device, NULL);
+	ctrls->get_link_state = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_link_state, NULL);
+	ctrls->get_date = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_data, NULL);
+	ctrls->get_pid_sn = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_pid_sn, NULL);
+	ctrls->get_imu_fps = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_imu_fps, NULL);
+	ctrls->get_version = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_version_data , NULL);
+	ctrls->get_imu_data = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_imu_data, NULL);
+
+	state->mux.sd.subdev.ctrl_handler = hdl;
+	err_ctl:
+	devm_kfree(&state->client->dev, xu_data_t);
+	devm_kfree(&state->client->dev, ctpu_data_t);
+	return 0;
+}
+
+static int orb_sensor_init(struct i2c_client *c, struct orb *state,
+		struct orb_sensor *sensor, const struct v4l2_subdev_ops *ops,
+		const char *name)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	struct media_pad *pad = &sensor->pad;
+	dev_t *dev_num = &state->client->dev.devt;
+
+	dev_dbg(sd->dev, "%s(): %p %s %p %p",
+			__func__, c, c->name, state, state->client);
+
+	v4l2_i2c_subdev_init(sd, c, ops);
+	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &orb_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+	/*Format the string and store the result in the variable sd->name, resulting in the final format of sd->name = "G2XX name adapter_id-addr".*/
+	snprintf(sd->name, sizeof(sd->name), "G2XX %s %d-%04x",
+		 name, i2c_adapter_id(c->adapter), c->addr);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pad->flags = MEDIA_PAD_FL_SOURCE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 1, pad);
+}
+
+static int orb_sensor_register(struct orb *state, struct orb_sensor *sensor)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	int ret;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = media_create_pad_link(entity, 0,
+			&state->mux.sd.subdev.entity, sensor->mux_pad,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		goto e_sd;
+	}
+
+	dev_dbg(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+
+static void orb_sensor_remove(struct orb_sensor *sensor)
+{
+	v4l2_device_unregister_subdev(&sensor->sd);
+
+	media_entity_cleanup(&sensor->sd.entity);
+}
+
+static int orb_depth_init(struct i2c_client *c, struct orb *state)
+{
+	/* Which mux pad we're connecting to */
+	state->depth.sensor.mux_pad = ORB_MUX_PAD_DEPTH;
+	return orb_sensor_init(c, state, &state->depth.sensor,
+			&orb_depth_subdev_ops, "depth");
+}
+
+static int orb_ir_l_init(struct i2c_client *c, struct orb *state)
+{
+	state->ir_l.sensor.mux_pad = ORB_MUX_PAD_IR_L_T;
+	return orb_sensor_init(c, state, &state->ir_l.sensor,
+			&orb_ir_l_subdev_ops, "motion detection");
+}
+
+static int orb_ir_r_init(struct i2c_client *c, struct orb *state)
+{
+	state->ir_r.sensor.mux_pad = ORB_MUX_PAD_IR_R_T;
+	return orb_sensor_init(c, state, &state->ir_r.sensor,
+			&orb_ir_r_subdev_ops, "motion detection");
+}
+
+static int orb_rgb_init(struct i2c_client *c, struct orb *state)
+{
+	state->rgb.sensor.mux_pad = ORB_MUX_PAD_RGB;
+	return orb_sensor_init(c, state, &state->rgb.sensor,
+			&orb_rgb_subdev_ops, "rgb");
+}
+
+/* No locking needed */
+static int orb_mux_enum_mbus_code(struct v4l2_subdev *sd,
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct v4l2_subdev_mbus_code_enum tmp = *mce;
+	struct v4l2_subdev *remote_sd;
+	int ret;
+
+	switch (mce->pad) {
+	case ORB_MUX_PAD_IR_L_T:
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	case ORB_MUX_PAD_IR_R_T:
+		remote_sd = &state->ir_r.sensor.sd;
+		break;
+	case ORB_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case ORB_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case ORB_MUX_PAD_EXTERNAL:
+		if (mce->index >= state->ir_l.sensor.n_formats + state->ir_r.sensor.n_formats + 
+				state->depth.sensor.n_formats)
+			return -EINVAL;
+
+		/*
+		 * First list Left node / Motion Tracker formats, then depth.
+		 * This should also help because D16 doesn't have a direct
+		 * analog in MIPI CSI-2.
+		 */
+		if (mce->index < state->ir_l.sensor.n_formats) {
+			remote_sd = &state->ir_l.sensor.sd;
+		} else if (mce->index < state->ir_l.sensor.n_formats + state->ir_r.sensor.n_formats) {
+			tmp.index = mce->index - state->ir_l.sensor.n_formats;
+			remote_sd = &state->ir_r.sensor.sd;
+		} else {
+			tmp.index = mce->index - (state->ir_l.sensor.n_formats + state->ir_r.sensor.n_formats);
+			remote_sd = &state->depth.sensor.sd;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+	if (state->is_rgb)
+		remote_sd = &state->rgb.sensor.sd;
+	if (state->is_depth)
+		remote_sd = &state->depth.sensor.sd;
+	if (state->is_ir_l)
+		remote_sd = &state->ir_l.sensor.sd;
+	if (state->is_ir_r)
+		remote_sd = &state->ir_r.sensor.sd;
+
+	/* Locks internally */
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	ret = orb_sensor_enum_mbus_code(remote_sd, cfg, &tmp);
+	#else
+	ret = orb_sensor_enum_mbus_code(remote_sd, v4l2_state, &tmp);
+	#endif
+	if (!ret)
+		mce->code = tmp.code;
+
+	dev_dbg(state->depth.sensor.sd.dev,
+			"%s()orb_mux_enum_mbus_code: code %x \n",
+			__func__, tmp.code);
+
+	return ret;
+}
+
+/* No locking needed */
+static int orb_mux_enum_frame_size(struct v4l2_subdev *sd,
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct v4l2_subdev_frame_size_enum tmp = *fse;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fse->pad;
+	int ret;
+
+	tmp.pad = 0;
+	
+	if (state->is_depth)
+		pad = ORB_MUX_PAD_DEPTH;
+	if (state->is_ir_l)
+		pad = ORB_MUX_PAD_IR_L_T;
+	if (state->is_ir_r)
+		pad = ORB_MUX_PAD_IR_R_T;
+	if (state->is_rgb)
+		pad = ORB_MUX_PAD_RGB;
+	switch (pad) {
+	case ORB_MUX_PAD_IR_L_T:
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	case ORB_MUX_PAD_IR_R_T:
+		remote_sd = &state->ir_r.sensor.sd;
+		break;
+	case ORB_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case ORB_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case ORB_MUX_PAD_EXTERNAL:
+		/*
+		 * Assume, that different sensors don't support the same formats
+		 * Try the Depth sensor first, then the Motion Tracker
+		 */
+		remote_sd = &state->depth.sensor.sd;
+		ret = orb_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fse = tmp;
+			fse->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = orb_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fse = tmp;
+		fse->pad = pad;
+	}
+	
+	dev_dbg(state->depth.sensor.sd.dev,
+			"%s()orb_mux_enum_frame_size: pad %d code %x \n",
+			__func__, pad, tmp.code);
+
+	return ret;
+}
+
+/* No locking needed */
+static int orb_mux_enum_frame_interval(struct v4l2_subdev *sd,
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct v4l2_subdev_frame_interval_enum tmp = *fie;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fie->pad;
+	int ret;
+
+	tmp.pad = 0;
+
+
+	if (state->is_depth)
+		pad = ORB_MUX_PAD_DEPTH;
+	if (state->is_ir_l)
+		pad = ORB_MUX_PAD_IR_L_T;
+	if (state->is_ir_r)
+		pad = ORB_MUX_PAD_IR_R_T;
+	if (state->is_rgb)
+		pad = ORB_MUX_PAD_RGB;
+	switch (pad) {
+	case ORB_MUX_PAD_IR_L_T:
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	case ORB_MUX_PAD_IR_R_T:
+		remote_sd = &state->ir_r.sensor.sd;
+		break;
+	case ORB_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case ORB_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case ORB_MUX_PAD_EXTERNAL:
+		/* Similar to orb_mux_enum_frame_size() above */
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else if(state->is_ir_l)
+			remote_sd = &state->ir_l.sensor.sd;
+		else //if(state->is_ir_r)
+			remote_sd = &state->ir_r.sensor.sd;
+		ret = orb_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fie = tmp;
+			fie->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = orb_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fie = tmp;
+		fie->pad = pad;
+	}
+
+	dev_dbg(state->depth.sensor.sd.dev,
+			"%s()orb_mux_enum_frame_interval: pad %d code %x width %d height %d\n",
+			__func__, pad, tmp.code, tmp.width, tmp.height);
+
+	return ret;
+}
+
+/* No locking needed */
+static int orb_mux_set_fmt(struct v4l2_subdev *sd, 
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_format *fmt)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct v4l2_subdev_format tmp = *fmt;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fmt->pad;
+	int ret = 0;
+
+	if (state->is_depth)
+		pad = ORB_MUX_PAD_DEPTH;
+	if (state->is_ir_l)
+		pad = ORB_MUX_PAD_IR_L_T;
+	if (state->is_ir_r)
+		pad = ORB_MUX_PAD_IR_R_T;
+	if (state->is_rgb)
+		pad = ORB_MUX_PAD_RGB;
+	//if (!state->is_rgb)
+	//	if (fmt->format.code == MEDIA_BUS_FMT_UYVY8_1X16)
+	//		pad = ORB_MUX_PAD_DEPTH;
+	//	else
+	//		pad = ORB_MUX_PAD_MOTION_T;
+	//else
+	//	pad = ORB_MUX_PAD_RGB;
+
+	dev_dbg(sd->dev, "%s(): pad: %x %x: %ux%u\n",
+			__func__, pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	switch (pad) {
+	case ORB_MUX_PAD_IR_L_T:
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	case ORB_MUX_PAD_IR_R_T:
+		remote_sd = &state->ir_r.sensor.sd;
+		break;
+	case ORB_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case ORB_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case ORB_MUX_PAD_EXTERNAL:
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->mux.last_set->sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+
+	/* Locks internally */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	ret = orb_sensor_set_fmt(remote_sd, cfg, &tmp);
+#else
+	ret = orb_sensor_set_fmt(remote_sd, v4l2_state, &tmp);
+#endif
+	if (!ret) {
+		*fmt = tmp;
+		fmt->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int orb_mux_get_fmt(struct v4l2_subdev *sd, 
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+	#else
+		struct v4l2_subdev_state *v4l2_state,
+	#endif
+		struct v4l2_subdev_format *fmt)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct v4l2_subdev_format tmp = *fmt;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fmt->pad;
+	int ret;
+
+	dev_dbg(sd->dev, "%s(): %u %p\n", __func__, pad, state->mux.last_set);
+
+	if (state->is_depth)
+		pad = ORB_MUX_PAD_DEPTH;
+	if (state->is_ir_l)
+		pad = ORB_MUX_PAD_IR_L_T;
+	if (state->is_ir_r)
+		pad = ORB_MUX_PAD_IR_R_T;
+	if (state->is_rgb)
+		pad = ORB_MUX_PAD_RGB;
+
+	switch (pad) {
+	case ORB_MUX_PAD_IR_L_T:
+		remote_sd = &state->ir_l.sensor.sd;
+		break;
+	case ORB_MUX_PAD_IR_R_T:
+		remote_sd = &state->ir_r.sensor.sd;
+		break;
+	case ORB_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case ORB_MUX_PAD_EXTERNAL:
+		remote_sd = &state->mux.last_set->sd;
+		break;
+	case ORB_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	/* Locks internally */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	ret = orb_sensor_get_fmt(remote_sd, cfg, &tmp);
+#else
+	ret = orb_sensor_get_fmt(remote_sd, v4l2_state, &tmp);
+#endif
+	if (!ret) {
+		*fmt = tmp;
+		fmt->pad = pad;
+	}
+
+	return ret;
+}
+
+/* Video ops */
+static int orb_mux_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct orb_sensor *sensor = NULL;
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static u16 __orb_probe_framerate(const struct orb_resolution *res, u16 target)
+{
+	int i;
+	u16 framerate;
+
+	for (i = 0; i < res->n_framerates; i++) {
+		framerate = res->framerates[i];
+		if (target <= framerate)
+			return framerate;
+	}
+
+	return res->framerates[res->n_framerates - 1];
+}
+
+static int orb_mux_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct orb_sensor *sensor = NULL;
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __orb_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+static int orb_mux_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct orb *state = container_of(sd, struct orb, mux.sd.subdev);
+	struct orb_sensor *sensor;
+	int ret = 0 ,i = 0 ,res_product = 0;
+	int restore_val = 0;
+	uint8_t stream_id = 0, stream_fmt = 0, stream_fmt_index = 0, stream_res = 0, md_fmt = 0;
+	uint16_t data_type1, data_type2, srcvc_id, dstvc_id;
+
+	struct orbbec_cmd *cmd;
+	cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+	if (!cmd) {
+		dev_err(&state->client->dev,
+				"%s(): Can't allocate memory \n",
+				__func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	if (state->is_depth) {
+		sensor = &state->depth.sensor;
+		stream_id = STREAM_TYPE_DEPTH;
+		md_fmt = GMSL_CSI_DT_EMBED;
+	} else if (state->is_rgb) {
+		sensor = &state->rgb.sensor;
+		stream_id = STREAM_TYPE_RGB;
+		md_fmt = GMSL_CSI_DT_EMBED;
+	} else if (state->is_ir_l) {
+		sensor = &state->ir_l.sensor;
+		stream_id = STREAM_TYPE_MONO_L;
+		md_fmt = GMSL_CSI_DT_EMBED;
+	} else if (state->is_ir_r) {
+		sensor = &state->ir_r.sensor;
+		stream_id = STREAM_TYPE_MONO_R;
+		md_fmt = GMSL_CSI_DT_EMBED;
+	} else {
+		return -EINVAL;
+	}
+	
+	stream_fmt_index = sensor->config.format->data_type;
+	switch (stream_fmt_index) {
+		case PIXEL_FORMAT_PACKED_8BIT:
+			stream_fmt = GMSL_CSI_DT_RAW_8;
+			break;
+		case PIXEL_FORMAT_PACKED_10BIT:
+			stream_fmt = GMSL_CSI_DT_RAW_10;
+			break;
+		case PIXEL_FORMAT_PACKED_12BIT:
+			stream_fmt = GMSL_CSI_DT_RAW_12;
+			break;
+		case PIXEL_FORMAT_PACKED_14BIT:
+			stream_fmt = GMSL_CSI_DT_RAW_14;
+			break;
+		case PIXEL_FORMAT_YUV422:
+			stream_fmt = GMSL_CSI_DT_YUV422_8;
+			break;
+		default:
+			dev_err(&state->client->dev, "Invail format");
+			return -EINVAL;
+	}
+	srcvc_id = state->g_ctx.st_vc;
+	dstvc_id = state->g_ctx.dst_vc;
+
+	dev_dbg(&state->client->dev, "s_stream for stream %s,vc:%d, on = %d,format =%d ,fps =%d\n",
+			state->mux.last_set->sd.name,dstvc_id, on, stream_fmt_index, sensor->config.framerate);
+
+	restore_val = state->mux.last_set->streaming;
+	state->mux.last_set->streaming = on;
+
+	if (on) {
+		sensor->pipe_id =
+			max9296_get_available_pipe_id(state->dser_dev,
+					(int)state->g_ctx.dst_vc);
+		if (sensor->pipe_id < 0) {
+			dev_err(&state->client->dev,
+				"No free pipe in max9296\n");
+			ret = 0;
+			goto restore_s_state;
+		}
+
+		data_type1 = stream_fmt;
+		if(state->embedded_metadata_height) {
+			data_type2 = md_fmt;
+		} else {
+			data_type2 = 0;
+		}
+
+		ret = orb_setup_pipeline(state, data_type1, data_type2, sensor->pipe_id, srcvc_id, dstvc_id);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "setup_pipeline err\n");
+			goto restore_s_state;
+		}
+
+		res_product = sensor->config.resolution->width *sensor->config.resolution->height;
+		for(i = 0;i < ARRAY_SIZE(resolution_map); i++){
+			if(res_product == resolution_map[i]){
+				stream_res = i;
+				break;
+			} 
+		}
+		if(i == ARRAY_SIZE(resolution_map) && res_product != resolution_map[i-1]) stream_res = -1;
+		cmd->header.len = G2R_STREAM_START_CMD_LEN;
+		cmd->header.code = OPCODE_OPEN_STREAM;
+		cmd->header.index = index++;
+		cmd->set_stream_cmd.stream_type = stream_id;
+		cmd->set_stream_cmd.format = stream_fmt_index;
+		cmd->set_stream_cmd.res = stream_res;
+		cmd->set_stream_cmd.fps = sensor->config.framerate;
+
+		ret = i2c_write_orbbec(state->client, cmd, G2R_STREAM_START_CMD_LEN);
+		if(ret < 0){
+			printk(KERN_ERR "\n i2c write open stream cmd err \n");
+			goto restore_s_state;
+		}
+
+		msleep(300);
+
+	} else {
+
+		if (max9296_release_pipe(state->dser_dev, sensor->pipe_id) < 0)
+			dev_warn(&state->client->dev, "release pipe failed\n");
+		sensor->pipe_id = -1;
+
+		cmd->header.len = G2R_STREAM_STOP_CMD_LEN;
+		cmd->header.code = OPCODE_CLOSE_STREAM;
+		cmd->header.index = index++;
+		cmd->set_stream_cmd.stream_type = stream_id;
+		ret = i2c_write_orbbec(state->client, cmd, G2R_STREAM_STOP_CMD_LEN);
+		if(ret < 0){
+			printk(KERN_ERR "\n i2c write close stream cmd err \n");
+		}
+
+		msleep(300);
+	}
+	devm_kfree(&state->client->dev, cmd);
+	return 0;
+restore_s_state:
+
+	if (on && sensor->pipe_id >= 0) {
+		if (max9296_release_pipe(state->dser_dev, sensor->pipe_id) < 0)
+			dev_warn(&state->client->dev, "release pipe failed\n");
+		sensor->pipe_id = -1;
+	}
+
+	dev_err(&state->client->dev,
+			"%s stream toggle failed! %x \n",
+			orb_get_sensor_name(state) ,restore_val);
+	devm_kfree(&state->client->dev, cmd);
+	state->mux.last_set->streaming = restore_val;
+
+	return ret;
+}
+
+static const struct v4l2_subdev_pad_ops orb_mux_pad_ops = {
+	.enum_mbus_code		= orb_mux_enum_mbus_code,
+	.enum_frame_size	= orb_mux_enum_frame_size,
+	.enum_frame_interval	= orb_mux_enum_frame_interval,
+	.get_fmt		= orb_mux_get_fmt,
+	.set_fmt		= orb_mux_set_fmt,
+};
+
+static const struct v4l2_subdev_core_ops orb_mux_core_ops = {
+	//.s_power = orb_mux_set_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+};
+
+static const struct v4l2_subdev_video_ops orb_mux_video_ops = {
+	.g_frame_interval	= orb_mux_g_frame_interval,
+	.s_frame_interval	= orb_mux_s_frame_interval,
+	.s_stream		= orb_mux_s_stream,
+};
+
+static const struct v4l2_subdev_ops orb_mux_subdev_ops = {
+	.core = &orb_mux_core_ops,
+	.pad = &orb_mux_pad_ops,
+	.video = &orb_mux_video_ops,
+};
+
+
+static int orb_mux_registered(struct v4l2_subdev *sd)
+{
+	struct orb *state = v4l2_get_subdevdata(sd);
+	int ret = orb_sensor_register(state, &state->depth.sensor);
+	if (ret < 0)
+		return ret;
+
+	ret = orb_sensor_register(state, &state->ir_l.sensor);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = orb_sensor_register(state, &state->ir_r.sensor);
+	if (ret < 0)
+		goto e_ir_l;
+
+	ret = orb_sensor_register(state, &state->rgb.sensor);
+	if (ret < 0)
+		goto e_ir_r;
+
+	return 0;
+
+e_ir_r:
+	v4l2_device_unregister_subdev(&state->ir_r.sensor.sd);
+
+e_ir_l:
+	v4l2_device_unregister_subdev(&state->ir_l.sensor.sd);
+
+e_depth:
+	v4l2_device_unregister_subdev(&state->depth.sensor.sd);
+
+	return ret;
+}
+
+static void orb_mux_unregistered(struct v4l2_subdev *sd)
+{
+	struct orb *state = v4l2_get_subdevdata(sd);
+	orb_sensor_remove(&state->rgb.sensor);
+	orb_sensor_remove(&state->ir_r.sensor);
+	orb_sensor_remove(&state->ir_l.sensor);
+	orb_sensor_remove(&state->depth.sensor);
+}
+
+static const struct v4l2_subdev_internal_ops orb_mux_internal_ops = {
+	.open = orb_mux_open,
+	.close = orb_mux_close,
+	.registered = orb_mux_registered,
+	.unregistered = orb_mux_unregistered,
+};
+
+static int orb_mux_register(struct i2c_client *c, struct orb *state)
+{
+	return v4l2_async_register_subdev(&state->mux.sd.subdev);
+}
+
+static int orb_mux_init(struct i2c_client *c, struct orb *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct media_entity *entity = &state->mux.sd.subdev.entity;
+	struct media_pad *pads = state->mux.pads, *pad;
+	unsigned int i;
+	int ret;
+
+	v4l2_i2c_subdev_init(sd, c, &orb_mux_subdev_ops);
+	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &orb_mux_internal_ops;  //The internal operation function set for V4L2 sub-devices:open、close、registered、unregistered
+	v4l2_set_subdevdata(sd, state);
+	snprintf(sd->name, sizeof(sd->name), "ORB mux %d-%04x",
+		 i2c_adapter_id(c->adapter), c->addr);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	for (i = 1, pad = pads + 1; i < ARRAY_SIZE(state->mux.pads); i++, pad++)
+		pad->flags = MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(entity, ARRAY_SIZE(state->mux.pads), pads);
+	if (ret < 0)
+		return ret;
+
+	ret = orb_ctrl_init(state);
+	if (ret < 0)
+		goto e_entity;
+
+	if (state->is_depth)
+		state->mux.last_set = &state->depth.sensor;
+	else if (state->is_rgb)
+		state->mux.last_set = &state->rgb.sensor;
+	else if (state->is_ir_l)
+		state->mux.last_set = &state->ir_l.sensor;
+	else if (state->is_ir_r)
+		state->mux.last_set = &state->ir_r.sensor;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	state->mux.sd.dev = &c->dev;
+	ret = camera_common_initialize(&state->mux.sd, "g2xx");
+	if (ret) {
+		dev_err(&c->dev, "Failed to initialize g2xx.\n");
+		goto e_ctrl;
+	}
+#endif
+
+	return 0;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+e_ctrl:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+#endif
+e_entity:
+	media_entity_cleanup(entity);
+
+	return ret;
+}
+
+#define USE_Y
+
+static int orb_fixed_configuration(struct i2c_client *client, struct orb *state)
+{
+	struct orb_sensor *sensor;
+	sensor = &state->depth.sensor;
+	sensor->formats = orb_depth_formats;
+	sensor->n_formats = orb_depth_formats_num;
+	sensor->mux_pad = ORB_MUX_PAD_DEPTH;
+
+	sensor = &state->ir_l.sensor;
+	sensor->formats = orb_mono_formats;
+	sensor->n_formats = orb_mono_formats_num;
+	sensor->mux_pad = ORB_MUX_PAD_IR_L_T;
+
+	sensor = &state->ir_r.sensor;
+	sensor->formats = orb_mono_formats;
+	sensor->n_formats = orb_mono_formats_num;
+	sensor->mux_pad = ORB_MUX_PAD_IR_R_T;
+
+	sensor = &state->rgb.sensor;
+	sensor->formats = orb_rgb_formats;
+	sensor->n_formats = orb_rgb_formats_num;
+	sensor->mux_pad = ORB_MUX_PAD_RGB;
+
+	return 0;
+}
+
+static int orb_parse_cam(struct i2c_client *client, struct orb *state)
+{
+	int ret = orb_fixed_configuration(client, state);
+	if (ret < 0)
+		return ret;
+
+	orb_sensor_format_init(&state->depth.sensor);
+	orb_sensor_format_init(&state->ir_l.sensor);
+	orb_sensor_format_init(&state->ir_r.sensor);
+	orb_sensor_format_init(&state->rgb.sensor);
+
+	return 0;
+}
+
+static void orb_mux_remove(struct orb *state)
+{
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_async_unregister_subdev(&state->mux.sd.subdev);
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+}
+
+
+static int orb_v4l_init(struct i2c_client *c, struct orb *state)
+{
+	int ret;
+
+	ret = orb_parse_cam(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = orb_depth_init(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = orb_ir_l_init(c, state);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = orb_ir_r_init(c, state);
+	if (ret < 0)
+		goto e_ir_l;
+
+	ret = orb_rgb_init(c, state);
+	if (ret < 0)
+		goto e_ir_r;
+
+	ret = orb_mux_init(c, state); //orb_ctrl_init
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = orb_mux_register(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	return 0;
+e_mux:
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+e_rgb:
+	media_entity_cleanup(&state->rgb.sensor.sd.entity);
+e_ir_r:
+	media_entity_cleanup(&state->ir_r.sensor.sd.entity);
+e_ir_l:
+	media_entity_cleanup(&state->ir_l.sensor.sd.entity);
+e_depth:
+	media_entity_cleanup(&state->depth.sensor.sd.entity);
+	return ret;
+}
+
+
+static int orb_probe(struct i2c_client *c, const struct i2c_device_id *id)
+{
+	struct orb *state = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);
+	int ret = 0;
+	int size;
+	int i = 0;
+
+	if (!state)
+		return -ENOMEM;
+	mutex_init(&state->lock);
+
+	state->client = c;
+	dev_info(&c->dev, "Probing new driver for orbbec camera\n");
+	//state->variant = orb_variants + id->driver_data;
+
+	state->vcc = devm_regulator_get(&c->dev, "vcc");
+	if (IS_ERR(state->vcc)) {
+		ret = PTR_ERR(state->vcc);
+		dev_warn(&c->dev, "failed %d to get vcc regulator\n", ret);
+		return ret;
+	}
+
+	if (state->vcc) {
+		ret = regulator_enable(state->vcc); 
+		if (ret < 0) {
+			dev_warn(&c->dev, "failed %d to enable the vcc regulator\n", ret);
+			return ret;
+		}
+	}
+
+	ret = orb_serdes_setup(state);
+	if (ret < 0)
+		goto e_regulator;
+	// wait after power on firmware init finish 
+	if(orbbec_communicate_finish_flag == 0) msleep_range(3000);
+	for (i = 0; i < 10 ; i++){
+		ret = orbbec_get_frame_profile_len(state, &size);
+		if(ret == 0 && size > 0) {
+			dev_info(&c->dev, "communicate with G2XX\n");
+			orbbec_communicate_finish_flag = 1;
+			break;
+		}
+		msleep_range(100);
+	}
+	if (ret < 0) {
+		dev_err(&c->dev, "%s(): cannot communicate with G2XX: %d\n",
+			__func__, ret);
+		goto e_regulator;
+	}
+	
+	orbbec_get_deviceinfo(state, &state->device_info.pid, G2R_GET_PROPERTY_CMD_LEN, G2R_GET_PROPERTY_CODE, G2R_GET_PID_PRO_ID,G2R_GET_DATA_NOMAL_LEN);
+	orbbec_get_deviceinfo(state, &state->device_info.sn, G2R_GET_FIRMWARE_DATA_CMD_LEN, G2R_GET_FIRMWARE_DATA_CODE, G2R_GET_SN_PRO_ID,G2R_GET_SN_DATA_LEN);
+	orbbec_get_deviceinfo(state, &state->device_info.asic_sn, G2R_GET_FIRMWARE_DATA_CMD_LEN, G2R_GET_FIRMWARE_DATA_CODE, G2R_GET_ASIC_SN_PRO_ID,G2R_GET_SN_DATA_LEN);
+
+	if(orbbec_get_frame_profile_flag == 0 || state->is_depth){
+		ret = orbbec_get_frame_profile(state);
+		if(ret <0 ) {
+			dev_err(&c->dev, "%s(): orbbec_get_frame_profile err: %d\n" , __func__, ret);
+			goto e_regulator;
+		}
+		orbbec_get_frame_profile_flag = 1;	
+	}
+	
+	ret = orb_v4l_init(c, state);
+	if (ret < 0)
+		goto e_regulator;
+	// wait video pipeline bound finish 
+	while(state->mux.sd.subdev.devnode == NULL) msleep_range(5);
+	state->device_info.sub_num = state->mux.sd.subdev.devnode->num;
+	if(state->is_depth)
+		dev_info(&c->dev, "success probe orbbec camera num %d\n", state->device_info.cam_num);
+	return 0;
+
+e_regulator:
+	if (state->vcc)
+		regulator_disable(state->vcc);
+	return ret;
+}
+
+static int orb_remove(struct i2c_client *c)
+{	
+	struct orb *state = NULL;
+	if (c != NULL) {
+		struct v4l2_subdev *sd = i2c_get_clientdata(c);
+		state = container_of(sd, struct orb, mux.sd.subdev);
+		//state= v4l2_get_subdevdata(sd);
+		if(state != NULL && sd != NULL){
+			int ret;
+			if (state->is_depth) {
+				mutex_lock(&serdes_lock__);
+
+				ret = max9295_reset_control(state->ser_dev);
+				if (ret)
+					dev_warn(&c->dev,"failed in 9295 reset control\n");
+
+				ret = max9296_reset_control(state->dser_dev, state->g_ctx.s_dev);
+				if (ret)
+					dev_warn(&c->dev,  "failed in 9296 reset control\n");
+
+				ret = max9295_sdev_unpair(state->ser_dev, state->g_ctx.s_dev);
+				if (ret)
+					dev_warn(&c->dev, "failed to unpair sdev\n");
+
+				ret = max9296_sdev_unregister(state->dser_dev,
+					state->g_ctx.s_dev);
+				if (ret)
+					dev_warn(&c->dev, "failed to sdev unregister sdev\n");
+				max9296_power_off(state->dser_dev);
+
+				mutex_unlock(&serdes_lock__);
+			}
+			
+			dev_info(&c->dev, "G2XX remove %s\n", orb_get_sensor_name(state));
+			if (state->vcc) regulator_disable(state->vcc);
+			mutex_destroy(&state->lock);
+			orb_mux_remove(state);
+		}
+	
+	}
+	
+	return 0;
+}
+
+static const struct i2c_device_id orb_id[] = {
+	{ ORB_DRIVER_NAME, ORB_ORBU },
+	{ ORB_DRIVER_NAME_ASR, ORB_ASR },
+	{ ORB_DRIVER_NAME_AWG, ORB_AWG },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, orb_id);
+
+static const struct of_device_id g2xx_of_match[] = {
+	{ .compatible = "orbbec,g2xx", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, g2xx_of_match);
+
+static struct i2c_driver orb_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = ORB_DRIVER_NAME,
+		.of_match_table = of_match_ptr(g2xx_of_match),
+	},
+	.probe		= orb_probe,
+	.remove		= orb_remove,
+	.id_table	= orb_id,
+};
+
+module_i2c_driver(orb_i2c_driver);
+
+MODULE_DESCRIPTION("Orbbec G2XX Camera Driver");
+MODULE_AUTHOR("yezhenhao <yanxiao@orbbec.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.02");
\ No newline at end of file
diff --git a/kernel/nvidia-oot/drivers/media/i2c/max9295.c b/kernel/nvidia-oot/drivers/media/i2c/max9295.c
index b363d5f67..cfa080682 100644
--- a/kernel/nvidia-oot/drivers/media/i2c/max9295.c
+++ b/kernel/nvidia-oot/drivers/media/i2c/max9295.c
@@ -1,11 +1,21 @@
-// SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2018-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 /*
  * max9295.c - max9295 GMSL Serializer driver
+ *
+ * Copyright (c) 2018-2022, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <nvidia/conftest.h>
-
 #include <media/camera_common.h>
 #include <linux/module.h>
 #include <media/max9295.h>
@@ -88,6 +98,9 @@
 
 #define MAX9295_MAX_PIPES 0x4
 
+#define ORBBEC_POWER_GPIOA_ADDR 0x2D6
+#define ORBBEC_POWER_GPIOB_ADDR 0x2D7
+
 struct max9295_client_ctx {
 	struct gmsl_link_ctx *g_ctx;
 	bool st_done;
@@ -98,12 +111,11 @@ struct max9295 {
 	struct regmap *regmap;
 	struct max9295_client_ctx g_client;
 	struct mutex lock;
+	struct device *prim_ser_dev;
 	/* primary serializer properties */
 	__u32 def_addr;
-	__u32 pst2_ref;
 };
 
-static struct max9295 *prim_priv__;
 
 struct map_ctx {
 	u8 dt;
@@ -301,9 +313,9 @@ int max9295_setup_control(struct device *dev)
 
 	g_ctx = priv->g_client.g_ctx;
 
-	if (prim_priv__) {
+	if (priv->prim_ser_dev) {
 		/* update address reassingment */
-		max9295_write_reg(&prim_priv__->i2c_client->dev,
+		max9295_write_reg(priv->prim_ser_dev,
 				MAX9295_DEV_ADDR, (g_ctx->ser_reg << 1));
 	}
 
@@ -340,16 +352,13 @@ int max9295_setup_control(struct device *dev)
 		i2c_ovrd[i+1] += (i < 4) ? offset1 : offset2;
 
 		/* i2c passthrough2 must be configured once for all devices */
-		if ((i2c_ovrd[i] == 0x8B) && prim_priv__ &&
-				prim_priv__->pst2_ref)
+		if ((i2c_ovrd[i] == 0x8B) && priv->prim_ser_dev && g_ctx->serdes_csi_link == GMSL_SERDES_CSI_LINK_A)
 			continue;
 
 		max9295_write_reg(dev, i2c_ovrd[i], i2c_ovrd[i+1]);
 	}
 
 	/* dev addr pass-through2 ref */
-	if (prim_priv__)
-		prim_priv__->pst2_ref++;
 
 	max9295_write_reg(dev, MAX9295_I2C4_ADDR, (g_ctx->sdev_reg << 1));
 	max9295_write_reg(dev, MAX9295_I2C5_ADDR, (g_ctx->sdev_def << 1));
@@ -380,15 +389,8 @@ int max9295_reset_control(struct device *dev)
 
 	priv->g_client.st_done = false;
 
-	if (prim_priv__) {
-		prim_priv__->pst2_ref--;
-
-		max9295_write_reg(dev, MAX9295_DEV_ADDR,
-					(prim_priv__->def_addr << 1));
-
-		max9295_write_reg(&prim_priv__->i2c_client->dev,
-					MAX9295_CTRL0_ADDR, MAX9295_RESET_ALL);
-	}
+	if (priv->prim_ser_dev)
+		max9295_write_reg(dev, MAX9295_DEV_ADDR, (priv->def_addr << 1));
 
 error:
 	mutex_unlock(&priv->lock);
@@ -417,6 +419,7 @@ int max9295_sdev_pair(struct device *dev, struct gmsl_link_ctx *g_ctx)
 	priv->g_client.st_done = false;
 
 	priv->g_client.g_ctx = g_ctx;
+	priv->g_client.g_ctx->serdev_found = false;
 
 error:
 	mutex_unlock(&priv->lock);
@@ -465,16 +468,284 @@ static  struct regmap_config max9295_regmap_config = {
 	.cache_type = REGCACHE_RBTREE,
 };
 
-#if defined(NV_I2C_DRIVER_STRUCT_PROBE_WITHOUT_I2C_DEVICE_ID_ARG) /* Linux 6.3 */
-static int max9295_probe(struct i2c_client *client)
-#else
+
+struct reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+static struct reg_pair map_fsync_trigger[] = {
+	/* MFP6, SYNC IN, RX */
+	{0x02D0, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]，GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+	{0x02D1, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02D2, 0x1F}, // GPIO_RX_ID[4:0]
+
+};
+
+static struct reg_pair map_wake[] = {
+	/* MFP3, wake, RX */
+	{0x02C7, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]，GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+	{0x02C8, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02C9, 0x1E}, // GPIO_RX_ID[4:0]
+};
+
+static struct reg_pair map_pps[] = {
+	/* MFP7, pps, RX */
+	{0x02D3, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]，GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+	{0x02D4, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->7no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02D5, 0x1D}, // GPIO_RX_ID[4:0]
+};
+
+static struct reg_pair map_sync_out[] = {
+	/* MFP9, SYNC OUT, TX */
+	{0x02D9, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]，GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+	{0x02DA, 0x9C}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02DB, 0x40}, // GPIO_RX_ID[4:0]
+};
+
+static struct reg_pair map_uart_tx[] = {
+	// #MFP11, RX 
+	{0x02DF, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]，GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable;
+	{0x02E0, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02E1, 0x1B},
+};
+
+static struct reg_pair map_uart_rx[] = {
+	// #MFP12, TX 
+	{0x02E2, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]，GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable;
+	{0x02E3, 0x7A}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02E4, 0x40}, // GPIO_RX_ID[4:0]
+};
+
+static int max9295_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	int err = 0;
+	u32 j = 0;
+
+	for (j = 0; j < count; j++) {
+		err = max9295_write_reg(dev, map[j].addr, map[j].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+static int __max9295_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+			      u8 data_type2, u32 vc_id)
+{
+	int err = 0;
+	u8 bpp = 0x30;
+	static u8 pipe_x_val = 0x0;
+	struct reg_pair map_multi_pipe_en[] = {
+		{0x0315, 0x80},
+	};
+	struct reg_pair map_bpp8dbl[] = {
+		{0x0312, 0x0F}, // Send 8-bit pixels as 16-bit on Video Pipe X,Y,Z,U
+	};
+	struct reg_pair map_pipe_control[] = {
+		/* addr, val */
+		{MAX9295_PIPE_X_DT_ADDR, 0x5E}, // Pipe X pulls data_type1
+		{0x0315, 0x52}, // Pipe X pulls data_type2
+		{0x0309, 0x01}, // # Pipe X pulls vc_id
+		{0x030A, 0x00},
+		{0x031C, 0x30}, // BPP in pipe X, raw 16bit
+		{0x0102, 0x0E}, // LIM_HEART Pipe X: Disabled
+	};
+
+	if (data_type1 == GMSL_CSI_DT_RAW_8 || data_type1 == GMSL_CSI_DT_EMBED
+	    || data_type2 == GMSL_CSI_DT_RAW_8 || data_type2 == GMSL_CSI_DT_EMBED) {
+		map_bpp8dbl[0].val |= (1 << pipe_id);
+	} else {
+		map_bpp8dbl[0].val &= ~(1 << pipe_id);
+	}
+	err |= max9295_set_registers(dev, map_bpp8dbl, ARRAY_SIZE(map_bpp8dbl));
+
+	if (data_type1 == GMSL_CSI_DT_RGB_888)
+		bpp = 0x18;
+
+	map_pipe_control[0].addr += 0x2 * pipe_id;
+	map_pipe_control[1].addr += 0x2 * pipe_id;
+	map_pipe_control[2].addr += 0x2 * pipe_id;
+	map_pipe_control[3].addr += 0x2 * pipe_id;
+	map_pipe_control[4].addr += 0x1 * pipe_id;
+	map_pipe_control[5].addr += 0x8 * pipe_id;
+
+	map_pipe_control[0].val = 0x40 | data_type1;
+	map_pipe_control[1].val = 0x40 | data_type2;
+	map_pipe_control[2].val = 1 << vc_id;
+	map_pipe_control[3].val = 0x00;
+	map_pipe_control[4].val = bpp;
+	map_pipe_control[5].val = 0x0E;
+
+	if (pipe_id == 0)
+		pipe_x_val = map_pipe_control[1].val;
+
+	err |= max9295_set_registers(dev, map_pipe_control,
+				     ARRAY_SIZE(map_pipe_control));
+
+	map_multi_pipe_en[0].val = 0x80 | pipe_x_val;
+	err |= max9295_set_registers(dev, map_multi_pipe_en,
+				     ARRAY_SIZE(map_multi_pipe_en));
+
+	return err;
+}
+
+int max9295_init_settings(struct device *dev)
+{
+	int err = 0;
+	int i;
+	struct max9295 *priv = dev_get_drvdata(dev);
+
+	struct reg_pair linka_map_pipe_opt[] = {
+		// Enable all pipes
+		{MAX9295_PIPE_EN_ADDR, 0xF3},
+		// 0x06 -> 2x4,A&B, 0x05 -> 2x4,only B, 0x04 -> 2x4,only A, only for MAX9295D
+		{MAX9295_MIPI_RX0_ADDR, 0x06}, 
+		// Write 0x33 for 4 lanes
+		{MAX9295_MIPI_RX1_ADDR, 0x11},
+		// Enable line info, Enable CSI Port A&B, Pipeline X&Z&U -> Port A ，Y -> Port B ---yanxiao
+		{MAX9295_CSI_PORT_SEL_ADDR, 0x72},
+		// Pipeline X&Z&U from Port A ，Y&U from Port B ---yanxiao
+		{MAX9295_START_PIPE_ADDR, 0x2D},
+	};
+
+	struct reg_pair linkb_map_pipe_opt[] = {
+		// Enable all pipes
+		{MAX9295_PIPE_EN_ADDR, 0xF3},
+		// 0x06 -> 2x4,A&B, 0x05 -> 2x4,only B, 0x04 -> 2x4,only A, only for MAX9295D
+		{MAX9295_MIPI_RX0_ADDR, 0x06}, 
+		// Write 0x33 for 4 lanes
+		{MAX9295_MIPI_RX1_ADDR, 0x11},
+		// Enable line info, Enable CSI Port A&B, Pipeline X&Y&Z -> Port A ，U -> Port B ---yanxiao
+		{MAX9295_CSI_PORT_SEL_ADDR, 0x78},
+		// Pipeline X&Y&Z from Port A ，U from Port B ---yanxiao
+		{MAX9295_START_PIPE_ADDR, 0x87},
+	};
+
+	u8 linka_pipe_datatype[4] = {
+		GMSL_CSI_DT_YUV422_8,
+		GMSL_CSI_DT_YUV422_8, 
+		GMSL_CSI_DT_RAW_8,
+		GMSL_CSI_DT_RAW_8,
+	};
+
+	u8 linkb_pipe_datatype[4] = {
+		GMSL_CSI_DT_RAW_8,
+		GMSL_CSI_DT_RAW_8, 
+		GMSL_CSI_DT_YUV422_8,
+		GMSL_CSI_DT_YUV422_8,
+	};
+
+	mutex_lock(&priv->lock);
+
+	if(priv->g_client.g_ctx->serdes_csi_link == GMSL_SERDES_CSI_LINK_A){
+		err |= max9295_set_registers(dev, linka_map_pipe_opt,
+				     ARRAY_SIZE(linka_map_pipe_opt));
+	}else{
+		err |= max9295_set_registers(dev, linkb_map_pipe_opt,
+				     ARRAY_SIZE(linkb_map_pipe_opt));
+	}
+
+	// Init control
+	for (i = 0; i < MAX9295_MAX_PIPES; i++){
+
+		if(priv->g_client.g_ctx->serdes_csi_link == GMSL_SERDES_CSI_LINK_A){
+			err |= __max9295_set_pipe(dev, i, linka_pipe_datatype[i],
+					  GMSL_CSI_DT_EMBED, i);
+		} else{
+			err |= __max9295_set_pipe(dev, i, linkb_pipe_datatype[i],
+					  GMSL_CSI_DT_EMBED, (i < MAX9295_MAX_PIPES-2) ? (i+2) : (i+2-4));
+		}
+	}	
+
+	// Trigger Depth
+	err |= max9295_set_registers(dev, map_fsync_trigger,
+				     ARRAY_SIZE(map_fsync_trigger));
+	// sync out
+	err |= max9295_set_registers(dev, map_sync_out,
+				     ARRAY_SIZE(map_sync_out));
+	// uart TX
+	err |= max9295_set_registers(dev, map_uart_tx,
+				     ARRAY_SIZE(map_uart_tx));
+	// uart RX
+	err |= max9295_set_registers(dev, map_uart_rx,
+				     ARRAY_SIZE(map_uart_rx));
+	// pps
+	err |= max9295_set_registers(dev, map_pps,
+				     ARRAY_SIZE(map_pps));
+	// wake
+	err |= max9295_set_registers(dev, map_wake,
+				     ARRAY_SIZE(map_wake));
+
+	mutex_unlock(&priv->lock);
+
+	if (err == 0) {
+		dev_info(dev, "%s done\n", __func__);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(max9295_init_settings);
+
+int max9295_set_orbbec_on(struct device *dev)
+{
+	int ret = 0;
+	ret = max9295_write_reg(dev, ORBBEC_POWER_GPIOA_ADDR, 0x00);
+	if (ret)
+		dev_err(dev, "%s:set_orbbec_on fail\n",
+			__func__);
+	
+	return ret;
+}
+EXPORT_SYMBOL(max9295_set_orbbec_on);
+
+int max9295_set_orbbec_off(struct device *dev)
+{
+	int ret = 0;
+	ret = max9295_write_reg(dev, ORBBEC_POWER_GPIOA_ADDR, 0x10);
+	if (ret)
+		dev_err(dev, "%s:set_orbbec_off fail\n",
+			__func__);
+	
+	return ret;
+}
+EXPORT_SYMBOL(max9295_set_orbbec_off);
+
+int max9295_set_pipe(struct device *dev, int pipe_id,
+		     u8 data_type1, u8 data_type2, u32 vc_id)
+{
+	struct max9295 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (pipe_id > (MAX9295_MAX_PIPES - 1)) {
+		dev_info(dev, "%s, input pipe_id: %d exceed max9295 max pipes\n",
+			 __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s pipe_id %d, data_type1 %u, data_type2 %u, vc_id %u\n",
+		__func__, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max9295_set_pipe(dev, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9295_set_pipe);
+
 static int max9295_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
-#endif
 {
 	struct max9295 *priv;
 	int err = 0;
 	struct device_node *node = client->dev.of_node;
+	struct device_node *ser_prim_node;
+	struct i2c_client *prim_ser_i2c = NULL;
 
 	dev_info(&client->dev, "[MAX9295]: probing GMSL Serializer\n");
 
@@ -483,54 +754,66 @@ static int max9295_probe(struct i2c_client *client,
 	priv->regmap = devm_regmap_init_i2c(priv->i2c_client,
 				&max9295_regmap_config);
 	if (IS_ERR(priv->regmap)) {
-		dev_err(&client->dev,
-			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		dev_err(&client->dev, "regmap init failed: %ld\n", PTR_ERR(priv->regmap));
 		return -ENODEV;
 	}
 
 	mutex_init(&priv->lock);
 
 	if (of_get_property(node, "is-prim-ser", NULL)) {
-		if (prim_priv__) {
-			dev_err(&client->dev,
-				"prim-ser already exists\n");
-				return -EEXIST;
-		}
 
 		err = of_property_read_u32(node, "reg", &priv->def_addr);
+
 		if (err < 0) {
 			dev_err(&client->dev, "reg not found\n");
 			return -EINVAL;
 		}
+	} else {
+		ser_prim_node = of_parse_phandle(node, "ser-prim-device", 0);
+		if (ser_prim_node == NULL) {
+			dev_err(&client->dev, "missing %s handle\n", "ser-prim-device");
+			return -ENOENT;
+		}
+		err = of_property_read_u32(ser_prim_node, "reg", &priv->def_addr);
+		if (err < 0) {
+			dev_err(&client->dev, "serializer def reg not found\n");
+			return -EINVAL;
+		}
+		prim_ser_i2c = of_find_i2c_device_by_node(ser_prim_node);
+		of_node_put(ser_prim_node);
+		if (prim_ser_i2c == NULL) {
+			dev_err(&client->dev, "prim_ser_i2c == NULL\n");
+			return -EPROBE_DEFER;
+		}
+		if (prim_ser_i2c->dev.driver == NULL) {
+			dev_err(&client->dev, "prim_ser_i2c->dev.driver == NULL\n");
+			return -EPROBE_DEFER;
+		}
+
+		priv->prim_ser_dev = &prim_ser_i2c->dev;
 
-		prim_priv__ = priv;
 	}
 
 	dev_set_drvdata(&client->dev, priv);
 
 	/* dev communication gets validated when GMSL link setup is done */
-	dev_info(&client->dev, "%s: success\n", __func__);
+	dev_info(&client->dev, "%s:  success\n", __func__);
 
 	return err;
 }
 
-#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
 static int max9295_remove(struct i2c_client *client)
-#else
-static void max9295_remove(struct i2c_client *client)
-#endif
 {
 	struct max9295 *priv;
 
 	if (client != NULL) {
 		priv = dev_get_drvdata(&client->dev);
 		mutex_destroy(&priv->lock);
-		i2c_unregister_device(client);
+		//i2c_unregister_device(client);
 		client = NULL;
 	}
-#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+
 	return 0;
-#endif
 }
 
 static const struct i2c_device_id max9295_id[] = {
@@ -555,8 +838,22 @@ static struct i2c_driver max9295_i2c_driver = {
 	.id_table = max9295_id,
 };
 
-module_i2c_driver(max9295_i2c_driver);
+static int __init max9295_init(void)
+{
+	return i2c_add_driver(&max9295_i2c_driver);
+}
+
+static void __exit max9295_exit(void)
+{
+	i2c_del_driver(&max9295_i2c_driver);
+}
+
+module_init(max9295_init);
+module_exit(max9295_exit);
 
 MODULE_DESCRIPTION("GMSL Serializer driver max9295");
 MODULE_AUTHOR("Sudhir Vyas <svyas@nvidia.com>");
+MODULE_AUTHOR("Dmitry Perchanov <dmitry.perchanov@intel.com>");
+MODULE_AUTHOR("yanxiao <yanxiao@orbbec.com>");
+MODULE_VERSION("1.0.05");
 MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia-oot/drivers/media/i2c/max9296.c b/kernel/nvidia-oot/drivers/media/i2c/max9296.c
index 1ceaf3cd5..edae8c722 100644
--- a/kernel/nvidia-oot/drivers/media/i2c/max9296.c
+++ b/kernel/nvidia-oot/drivers/media/i2c/max9296.c
@@ -1,11 +1,21 @@
-// SPDX-License-Identifier: GPL-2.0
-// Copyright (c) 2018-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 /*
  * max9296.c - max9296 GMSL Deserializer driver
+ *
+ * Copyright (c) 2018-2022, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <nvidia/conftest.h>
-
 #include <linux/gpio.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -34,12 +44,17 @@
 #define MAX9296_PIPE_X_DST_1_MAP_ADDR 0x410
 #define MAX9296_PIPE_X_SRC_2_MAP_ADDR 0x411
 #define MAX9296_PIPE_X_DST_2_MAP_ADDR 0x412
+#define MAX9296_PIPE_X_SRC_3_MAP_ADDR 0x413
+#define MAX9296_PIPE_X_DST_3_MAP_ADDR 0x414
 
 #define MAX9296_PIPE_X_ST_SEL_ADDR 0x50
 
 #define MAX9296_PWDN_PHYS_ADDR 0x332
 #define MAX9296_PHY1_CLK_ADDR 0x320
 #define MAX9296_CTRL0_ADDR 0x10
+#define MAX9296_CTRL3_ADDR 0x13
+
+#define MAX9296_LOCKED_MASK 0x08
 
 /* data defines */
 #define MAX9296_CSI_MODE_4X2 0x1
@@ -94,11 +109,13 @@ struct pipe_ctx {
 	u32 st_id_sel;
 };
 
+
 struct max9296 {
 	struct i2c_client *i2c_client;
 	struct regmap *regmap;
 	u32 num_src;
 	u32 max_src;
+	u32 max_src_flag;
 	u32 num_src_found;
 	u32 src_link;
 	bool splitter_enabled;
@@ -112,8 +129,11 @@ struct max9296 {
 	u8 lane_mp1;
 	u8 lane_mp2;
 	int reset_gpio;
+	int fsync_mfp_x;
+	int pps_mfp_x;
 	int pw_ref;
 	struct regulator *vdd_cam_1v2;
+
 };
 
 static int max9296_write_reg(struct device *dev,
@@ -135,6 +155,44 @@ static int max9296_write_reg(struct device *dev,
 
 	return err;
 }
+static int max9296_read_reg(struct device *dev, u16 addr, int* val)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err;
+
+	err = regmap_read(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s:i2c read failed, 0x%x\n",
+			__func__, addr);
+
+	// delay before next i2c command as required for SERDES link 
+	usleep_range(100, 110);
+
+	return err;
+}
+
+int max9296_get_link_state(struct device *dev,
+			int *value)
+{
+	int temp = 0;
+	int val, err;
+
+	err = max9296_read_reg(dev, MAX9296_CTRL3_ADDR, &val);
+	if (err){
+		dev_err(dev, "%s:failed\n", __func__);
+		return err;
+	}
+		
+	dev_info(dev, "max9296 register 0x%x= 0x%x\n", MAX9296_CTRL3_ADDR, val);
+	if(val & MAX9296_LOCKED_MASK) 
+		temp = 1;
+	else 
+		temp = 0;
+
+	memcpy(value, &temp, 4);
+	return 0;
+}
+EXPORT_SYMBOL(max9296_get_link_state);
 
 static int max9296_get_sdev_idx(struct device *dev,
 			struct device *s_dev, unsigned int *idx)
@@ -209,8 +267,12 @@ int max9296_power_on(struct device *dev)
 	mutex_lock(&priv->lock);
 	if (priv->pw_ref == 0) {
 		usleep_range(1, 2);
-		if (priv->reset_gpio)
-			gpio_set_value(priv->reset_gpio, 0);
+		if (priv->reset_gpio){
+			if(gpio_cansleep(priv->reset_gpio))
+				gpio_set_value_cansleep(priv->reset_gpio, 0);
+			else
+				gpio_set_value(priv->reset_gpio, 0);
+		}
 
 		usleep_range(30, 50);
 
@@ -224,14 +286,20 @@ int max9296_power_on(struct device *dev)
 
 		/*exit reset mode: XCLR */
 		if (priv->reset_gpio) {
-			gpio_set_value(priv->reset_gpio, 0);
+			if(gpio_cansleep(priv->reset_gpio))
+				gpio_set_value_cansleep(priv->reset_gpio, 0);
+			else
+				gpio_set_value(priv->reset_gpio, 0);
 			usleep_range(30, 50);
-			gpio_set_value(priv->reset_gpio, 1);
+			if(gpio_cansleep(priv->reset_gpio))
+				gpio_set_value_cansleep(priv->reset_gpio, 1);
+			else
+				gpio_set_value(priv->reset_gpio, 1);
 			usleep_range(30, 50);
 		}
 
 		/* delay to settle reset */
-		msleep(20);
+		msleep(25);
 	}
 
 	priv->pw_ref++;
@@ -250,12 +318,17 @@ void max9296_power_off(struct device *dev)
 	mutex_lock(&priv->lock);
 	priv->pw_ref--;
 
+	if (priv->pw_ref < 0) priv->pw_ref = 0;
+
 	if (priv->pw_ref == 0) {
 		/* enter reset mode: XCLR */
 		usleep_range(1, 2);
-		if (priv->reset_gpio)
-			gpio_set_value(priv->reset_gpio, 0);
-
+		if (priv->reset_gpio){
+			if(gpio_cansleep(priv->reset_gpio))
+				gpio_set_value_cansleep(priv->reset_gpio, 0);
+			else
+				gpio_set_value(priv->reset_gpio, 0);
+		}
 		if (priv->vdd_cam_1v2)
 			regulator_disable(priv->vdd_cam_1v2);
 	}
@@ -272,7 +345,9 @@ static int max9296_write_link(struct device *dev, u32 link)
 	} else if (link == GMSL_SERDES_CSI_LINK_B) {
 		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x02);
 		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x22);
-	} else {
+	} else if (link == GMSL_SERDES_CSI_LINK_AUTO) {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31);
+	}else {
 		dev_err(dev, "%s: invalid gmsl link\n", __func__);
 		return -EINVAL;
 	}
@@ -336,13 +411,12 @@ int max9296_setup_control(struct device *dev, struct device *s_dev)
 
 	/* Enable splitter mode */
 	if ((priv->max_src > 1U) &&
-		(priv->num_src_found > 0U) &&
+		(priv->num_src_found == priv->max_src) &&
 		(priv->splitter_enabled == false)) {
-		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x03);
 		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x23);
-
+        dev_dbg(dev, "%s: splitter mode enabled\n", __func__);
 		priv->splitter_enabled = true;
-
+		priv->max_src_flag = 1;
 		/* delay to settle link */
 		msleep(100);
 	}
@@ -354,14 +428,11 @@ int max9296_setup_control(struct device *dev, struct device *s_dev)
 
 	/* Reset splitter mode if all devices are not found */
 	if ((priv->sdev_ref == priv->max_src) &&
-		(priv->splitter_enabled == true) &&
-		(priv->num_src_found > 0U) &&
+		(priv->num_src_found >= 0U) &&
 		(priv->num_src_found < priv->max_src)) {
-		err = max9296_write_link(dev, priv->src_link);
+		err = max9296_write_link(dev, GMSL_SERDES_CSI_LINK_AUTO);
 		if (err)
 			goto error;
-
-		priv->splitter_enabled = false;
 	}
 
 error:
@@ -373,6 +444,7 @@ EXPORT_SYMBOL(max9296_setup_control);
 int max9296_reset_control(struct device *dev, struct device *s_dev)
 {
 	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
 
 	mutex_lock(&priv->lock);
 	if (!priv->sdev_ref) {
@@ -380,7 +452,16 @@ int max9296_reset_control(struct device *dev, struct device *s_dev)
 		goto ret;
 	}
 
-	priv->sdev_ref--;
+	if(priv->max_src_flag == 1){
+		priv->sdev_ref --;
+		priv->num_src_found = 0;
+		priv->max_src_flag = 0;
+	}else{
+		priv->sdev_ref--;
+		if (priv->num_src_found > 0) priv->num_src_found--;
+	}
+
+	priv->splitter_enabled = false;
 	if (priv->sdev_ref == 0) {
 		max9296_reset_ctx(priv);
 		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, MAX9296_RESET_ALL);
@@ -392,7 +473,7 @@ int max9296_reset_control(struct device *dev, struct device *s_dev)
 ret:
 	mutex_unlock(&priv->lock);
 
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL(max9296_reset_control);
 
@@ -411,7 +492,7 @@ int max9296_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
 
 	mutex_lock(&priv->lock);
 
-	if (priv->num_src > priv->max_src) {
+	if (priv->num_src >= priv->max_src) {
 		dev_err(dev,
 			"%s: MAX9296 inputs size exhausted\n", __func__);
 		err = -ENOMEM;
@@ -431,6 +512,11 @@ int max9296_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
 	}
 
 	for (i = 0; i < priv->num_src; i++) {
+		if(priv->sources[i].g_ctx == NULL){
+			priv->sources[i].g_ctx = g_ctx;
+			priv->sources[i].st_enabled = false;
+			goto unuse;
+		}
 		if (g_ctx->serdes_csi_link ==
 			priv->sources[i].g_ctx->serdes_csi_link) {
 			dev_err(dev,
@@ -448,7 +534,7 @@ int max9296_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
 		if (g_ctx->num_csi_lanes !=
 				priv->sources[i].g_ctx->num_csi_lanes) {
 			dev_err(dev,
-				"%s: csi num lanes mismatch\n", __func__);
+				"%s: csi num lanes mismatch ,lane =%d\n", __func__, priv->sources[i].g_ctx->num_csi_lanes);
 			err = -EINVAL;
 			goto error;
 		}
@@ -457,6 +543,7 @@ int max9296_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
 	priv->sources[priv->num_src].g_ctx = g_ctx;
 	priv->sources[priv->num_src].st_enabled = false;
 
+unuse:
 	priv->num_src++;
 
 error:
@@ -486,6 +573,9 @@ int max9296_sdev_unregister(struct device *dev, struct device *s_dev)
 	}
 
 	for (i = 0; i < priv->num_src; i++) {
+		if(priv->sources[i].g_ctx == NULL){
+			continue;
+		}
 		if (s_dev == priv->sources[i].g_ctx->s_dev) {
 			priv->sources[i].g_ctx = NULL;
 			break;
@@ -558,7 +648,7 @@ static int max9296_setup_pipeline(struct device *dev,
 	u32 i = 0;
 	u32 j = 0;
 	u32 vc_idx = 0;
-
+	dev_info(dev, "%s: max9296 setup_pipeline\n", __func__);
 	for (i = 0; i < g_ctx->num_streams; i++) {
 		/* Base data type mapping: pipeX/RAW12/CSICNTR1 */
 		struct reg_pair map_pipe_raw12[] = {
@@ -719,7 +809,7 @@ int max9296_setup_streaming(struct device *dev, struct device *s_dev)
 		goto ret;
 
 	/* Derive CSI lane map register */
-	switch (g_ctx->dst_csi_port) {
+	switch(g_ctx->dst_csi_port) {
 	case GMSL_CSI_PORT_A:
 	case GMSL_CSI_PORT_D:
 		lane_ctrl_addr = MAX9296_LANE_CTRL1_ADDR;
@@ -769,6 +859,242 @@ ret:
 }
 EXPORT_SYMBOL(max9296_setup_streaming);
 
+#if 0
+static struct reg_pair map_uart_tx[] = {
+	/* MFP7  uart Tx*/ 
+	{0x02C5, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; 
+	{0x02C6, 0x7B}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02C7, 0x40},
+};
+
+static struct reg_pair map_uart_rx[] = {
+	/* MFP0 uart, RX */
+	{0x02B0, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; 
+	{0x02B1, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	{0x02B2, 0x1A}, // GPIO_RX_ID[4:0]
+};
+#endif
+
+static int max9296_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	int err = 0;
+	u32 j = 0;
+
+	for (j = 0; j < count; j++) {
+		err = max9296_write_reg(dev,
+			map[j].addr, map[j].val);
+		if (err != 0) break;
+	}
+
+	return err;
+}
+
+int max9296_get_available_pipe_id(struct device *dev, int dstvc_id)
+{
+	int i;
+	int pipe_id = -ENOMEM;
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_PIPES; i++) {
+		if (i == dstvc_id && !priv->pipe[i].st_count) {
+			priv->pipe[i].st_count++;
+			pipe_id = i;
+			break;
+		}
+	}
+	mutex_unlock(&priv->lock);
+
+	return pipe_id;
+}
+EXPORT_SYMBOL(max9296_get_available_pipe_id);
+
+int max9296_release_pipe(struct device *dev, int pipe_id)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	if (pipe_id < 0 || pipe_id >= MAX9296_MAX_PIPES)
+		return -EINVAL;
+
+	mutex_lock(&priv->lock);
+	priv->pipe[pipe_id].st_count = 0;
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296_release_pipe);
+
+void max9296_reset_oneshot(struct device *dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	if (priv->splitter_enabled) {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x03);
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x23);
+	} else {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31);
+	}
+	/* delay to settle link */
+	msleep(100);
+	mutex_unlock(&priv->lock);
+}
+EXPORT_SYMBOL(max9296_reset_oneshot);
+
+static int __max9296_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+			      u8 data_type2, u32 srcvc_id, u32 dstvc_id)
+{
+	int err = 0;
+	int i = 0;
+	u8 en_mapping_num = 0x0F;
+	u8 all_mapping_phy = 0x55;
+	
+	struct reg_pair map_pipe_control[] = {
+		// Enable 4 mappings for Pipe X
+		{MAX9296_TX11_PIPE_X_EN_ADDR, 0x0F},
+		// Map data_type1 on vc_id
+		{MAX9296_PIPE_X_SRC_0_MAP_ADDR, 0x1E},
+		{MAX9296_PIPE_X_DST_0_MAP_ADDR, 0x1E},
+		// Map frame_start on vc_id
+		{MAX9296_PIPE_X_SRC_1_MAP_ADDR, 0x00},
+		{MAX9296_PIPE_X_DST_1_MAP_ADDR, 0x00},
+		// Map frame end on vc_id
+		{MAX9296_PIPE_X_SRC_2_MAP_ADDR, 0x01},
+		{MAX9296_PIPE_X_DST_2_MAP_ADDR, 0x01},
+		// Map data_type2 on vc_id
+		{MAX9296_PIPE_X_SRC_3_MAP_ADDR, 0x12},
+		{MAX9296_PIPE_X_DST_3_MAP_ADDR, 0x12},
+		// All mappings to PHY1 (master for port A)
+		{MAX9296_TX45_PIPE_X_DST_CTRL_ADDR, 0x55},
+		// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+		{0x0100, 0x23}, // pipe X
+	};
+
+	for (i = 0; i < 10; i++) {
+		map_pipe_control[i].addr += 0x40 * pipe_id;
+	}
+	map_pipe_control[10].addr += 0x12 * pipe_id;
+
+	if (data_type2 == 0x0) {
+		en_mapping_num = 0x07;
+		all_mapping_phy = 0x15;
+	}
+	map_pipe_control[0].val = en_mapping_num;
+	map_pipe_control[1].val = (srcvc_id << 6) | data_type1;
+	map_pipe_control[2].val = (dstvc_id << 6) | data_type1;
+	map_pipe_control[3].val = (srcvc_id << 6) | 0x00;
+	map_pipe_control[4].val = (dstvc_id << 6) | 0x00;
+	map_pipe_control[5].val = (srcvc_id << 6) | 0x01;
+	map_pipe_control[6].val = (dstvc_id << 6) | 0x01;
+	map_pipe_control[7].val = (srcvc_id << 6) | data_type2;
+	map_pipe_control[8].val = (dstvc_id << 6) | data_type2;
+	map_pipe_control[9].val = all_mapping_phy;
+	map_pipe_control[10].val = 0x23;
+
+	err |= max9296_set_registers(dev, map_pipe_control,
+				     ARRAY_SIZE(map_pipe_control));
+
+	return err;
+}
+
+int max9296_init_settings(struct device *dev)
+{
+	int err = 0;
+	int i;
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	struct reg_pair map_pipe_opt[] = {
+		{0x0302, 0x10}, // Increase CMU regulator voltage
+		{0x1458, 0x28}, // PHY A Optimization
+		{0x1459, 0x68}, // PHY A Optimization
+		{0x1558, 0x28}, // PHY B Optimization
+		{0x1559, 0x68}, // PHY B Optimization
+		// 4 lanes on port A, write 0x50 for 2 lanes,write 0xD0 for 4 lanes
+		{MAX9296_LANE_CTRL1_ADDR, 0xD0},
+		// 1500Mbps/lane on port A
+		{MAX9296_PHY1_CLK_ADDR, 0x2F},
+		// Do not un-double 8bpp (Un-double 8bpp data)
+		//{0x031C, 0x00},
+		// Do not un-double 8bpp
+		//{0x031F, 0x00},
+		// 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8
+		{0x0473, 0x10},
+	};
+	
+	struct reg_pair map_fsync_trigger[] = {
+		/* MFP10 SYNC IN, Tx*/
+		{0x02CE, 0x82}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; 
+		{0x02CF, 0x1F}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	};
+
+	struct reg_pair map_pps_trigger[] = {
+		/* MFP9 pps, TX */
+		{0x02CB, 0x82}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; 
+		{0x02CC, 0x1D}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	};
+
+	u8 pipe_datatype[4] = {
+		GMSL_CSI_DT_YUV422_8,
+		GMSL_CSI_DT_YUV422_8, 
+		GMSL_CSI_DT_RAW_8,
+		GMSL_CSI_DT_RAW_8,
+	};
+	mutex_lock(&priv->lock);
+
+	err |= max9296_set_registers(dev, map_pipe_opt, 
+					ARRAY_SIZE(map_pipe_opt));
+	
+	for (i = 0; i < MAX9296_MAX_PIPES; i++)
+		err |= __max9296_set_pipe(dev, i, pipe_datatype[i],
+					  GMSL_CSI_DT_EMBED, i, i);
+
+	// FSYNC Trigger
+	map_fsync_trigger[0].addr = 0x2B0 + priv->fsync_mfp_x * 3;
+	map_fsync_trigger[1].addr = map_fsync_trigger[0].addr + 1;
+	err |= max9296_set_registers(dev, map_fsync_trigger,
+				     ARRAY_SIZE(map_fsync_trigger));
+	
+	// PPS Trigger
+	map_pps_trigger[0].addr = 0x2B0 + priv->pps_mfp_x * 3;
+	map_pps_trigger[1].addr = map_pps_trigger[0].addr + 1;
+	err |= max9296_set_registers(dev, map_pps_trigger,
+				     ARRAY_SIZE(map_pps_trigger));
+
+	if (err == 0) {
+		dev_info(dev, "%s done\n", __func__);
+	}
+
+	mutex_unlock(&priv->lock);
+	return err;
+}
+EXPORT_SYMBOL(max9296_init_settings);
+
+int max9296_set_pipe(struct device *dev, int pipe_id,
+		     u8 data_type1, u8 data_type2, u32 srcvc_id, u32 dstvc_id)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (pipe_id > (MAX9296_MAX_PIPES - 1)) {
+		dev_err(dev, "%s, input pipe_id: %d exceed max9296 max pipes\n",
+			 __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s pipe_id %d, data_type1 %u, data_type2 %u, srcvc_id %u, dstvc_id %u\n",
+		__func__, pipe_id, data_type1, data_type2, srcvc_id, dstvc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max9296_set_pipe(dev, pipe_id, data_type1, data_type2, srcvc_id, dstvc_id);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_set_pipe);
+
 static const struct of_device_id max9296_of_match[] = {
 	{ .compatible = "maxim,max9296", },
 	{ },
@@ -819,6 +1145,22 @@ static int max9296_parse_dt(struct max9296 *priv,
 	}
 	priv->max_src = value;
 
+	err = of_property_read_u32(node, "fsync_mfp_index", &value);
+	if (err < 0) {
+		priv->fsync_mfp_x = 10;
+		dev_err(&client->dev, "No fsync_mfp_index info\n");
+	} else {
+		priv->fsync_mfp_x = value;
+	}
+
+	err = of_property_read_u32(node, "pps_mfp_index", &value);
+	if (err < 0) {
+		priv->pps_mfp_x = 9;
+		dev_err(&client->dev, "No pps_mfp_index info\n");
+	} else {
+		priv->pps_mfp_x = value;
+	}
+
 	priv->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
 	if (priv->reset_gpio < 0) {
 		dev_err(&client->dev, "reset-gpios not found %d\n", err);
@@ -827,7 +1169,7 @@ static int max9296_parse_dt(struct max9296 *priv,
 
 	/* digital 1.2v */
 	if (of_get_property(node, "vdd_cam_1v2-supply", NULL)) {
-		priv->vdd_cam_1v2 = regulator_get(&client->dev, "vdd_cam_1v2");
+		priv->vdd_cam_1v2 = regulator_get(&client->dev, "vdd_cam_1v2");  //获取电压或电流调节器
 		if (IS_ERR(priv->vdd_cam_1v2)) {
 			dev_err(&client->dev,
 				"vdd_cam_1v2 regulator get failed\n");
@@ -845,15 +1187,11 @@ static int max9296_parse_dt(struct max9296 *priv,
 static struct regmap_config max9296_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
+	.cache_type = REGCACHE_NONE,
 };
 
-#if defined(NV_I2C_DRIVER_STRUCT_PROBE_WITHOUT_I2C_DEVICE_ID_ARG) /* Linux 6.3 */
-static int max9296_probe(struct i2c_client *client)
-#else
 static int max9296_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
-#endif
 {
 	struct max9296 *priv;
 	int err = 0;
@@ -870,7 +1208,7 @@ static int max9296_probe(struct i2c_client *client,
 		return -ENODEV;
 	}
 
-	err = max9296_parse_dt(priv, client);
+	err = max9296_parse_dt(priv, client);   //解析设备树
 	if (err) {
 		dev_err(&client->dev, "unable to parse dt\n");
 		return -EFAULT;
@@ -891,26 +1229,22 @@ static int max9296_probe(struct i2c_client *client,
 	/* dev communication gets validated when GMSL link setup is done */
 	dev_info(&client->dev, "%s:  success\n", __func__);
 
-	return 0;
+	return err;
 }
 
-#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+
 static int max9296_remove(struct i2c_client *client)
-#else
-static void max9296_remove(struct i2c_client *client)
-#endif
 {
 	struct max9296 *priv;
 
 	if (client != NULL) {
 		priv = dev_get_drvdata(&client->dev);
 		mutex_destroy(&priv->lock);
-		i2c_unregister_device(client);
+		//i2c_unregister_device(client);
 		client = NULL;
 	}
-#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+
 	return 0;
-#endif
 }
 
 static const struct i2c_device_id max9296_id[] = {
@@ -931,8 +1265,21 @@ static struct i2c_driver max9296_i2c_driver = {
 	.id_table = max9296_id,
 };
 
-module_i2c_driver(max9296_i2c_driver);
+static int __init max9296_init(void)
+{
+	return i2c_add_driver(&max9296_i2c_driver);
+}
+
+static void __exit max9296_exit(void)
+{
+	i2c_del_driver(&max9296_i2c_driver);
+}
+
+module_init(max9296_init);
+module_exit(max9296_exit);
 
 MODULE_DESCRIPTION("Dual GMSL Deserializer driver max9296");
 MODULE_AUTHOR("Sudhir Vyas <svyas@nvidia.com");
+MODULE_AUTHOR("yezhenhao <yanxiao@orbbec.com");
+MODULE_VERSION("1.0.06");
 MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
index f1a3e19ce..7942a1bb8 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
@@ -943,11 +943,11 @@ int vi_capture_release(
 
 		tegra_camrtc_reboot(chan->rtcpu_dev);
 
-		err = -EIO;
+		//err = -EIO;  //orb modify
 	} else if (resp_msg->channel_release_resp.result != CAPTURE_OK) {
 		dev_err(chan->dev, "%s: control failed, errno %d", __func__,
 			resp_msg->channel_release_resp.result);
-		err = -EIO;
+		//err = -EIO; //orb modify
 	}
 
 	if (capture->requests_memoryinfo) {
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c
index 92cc2fdf9..69139eeed 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c
@@ -267,6 +267,10 @@ static int extract_pixel_format(
 		*format = V4L2_PIX_FMT_UYVY;
 	else if (strncmp(pixel_t, "yuv_vyuy16", size) == 0)
 		*format = V4L2_PIX_FMT_VYUY;
+	else if (strncmp(pixel_t, "grey_y8", size) == 0)
+		*format = V4L2_PIX_FMT_GREY;
+	else if (strncmp(pixel_t, "grey_y16", size) == 0)
+		*format = V4L2_PIX_FMT_Y16;
 	else {
 		pr_err("%s: Need to extend format%s\n", __func__, pixel_t);
 		return -EINVAL;
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c
index 91f8d5f83..735761280 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c
@@ -202,7 +202,8 @@ static void tegra_channel_fmt_align(struct tegra_channel *chan,
 	 * different. Aligned width also may force a sensor mode change other
 	 * than the requested one
 	 */
-	*height = clamp(*height, TEGRA_MIN_HEIGHT, TEGRA_MAX_HEIGHT);
+	*height = clamp(*height, 1U /*TEGRA_MIN_HEIGHT*/, TEGRA_MAX_HEIGHT);
+
 
 	/* Clamp the requested bytes per line value. If the maximum bytes per
 	 * line value is zero, the module doesn't support user configurable line
@@ -503,11 +504,6 @@ void free_ring_buffers(struct tegra_channel *chan, int frames)
 		 * the second buffer is intermittently frame of zeros
 		 * with no error status or padding.
 		 */
-		/* This will drop the first two frames. Disable for now. */
-		if (chan->capture_state != CAPTURE_GOOD ||
-			chan->released_bufs < 2)
-			chan->buffer_state[chan->free_index] =
-						VB2_BUF_STATE_ERROR;
 
 		if (chan->sequence == 1) {
 			/*
@@ -1027,7 +1023,8 @@ tegra_channel_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 
 	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 	cap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;
-	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_META_CAPTURE;
 
 	len = strscpy(cap->driver, "tegra-video", sizeof(cap->driver));
 	if (len < 0)
@@ -2224,6 +2221,62 @@ static long tegra_channel_default_ioctl(struct file *file, void *fh,
 	return ret;
 }
 
+static int
+__tegra_channel_get_parm(struct tegra_channel *chan,
+			  struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+	struct v4l2_subdev_frame_interval interval;
+
+	/* dmipx: fixing G_PARM EINVAL error */
+//	ret = v4l2_subdev_call(sd, video, g_frame_interval, &interval);
+	ret = sd->ops->video->g_frame_interval(sd, &interval);
+
+	a->parm.capture.timeperframe.numerator = interval.interval.numerator;
+	a->parm.capture.timeperframe.denominator = interval.interval.denominator;
+
+	return ret;
+}
+
+static int tegra_channel_get_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	a->parm.capture.timeperframe.numerator = 1;
+	a->parm.capture.timeperframe.denominator = 12;
+
+	return __tegra_channel_get_parm(chan, a);
+}
+
+static int
+__tegra_channel_set_parm(struct tegra_channel *chan,
+			  struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+
+	struct v4l2_subdev_frame_interval interval;
+	interval.pad = 1;
+	interval.interval.numerator = a->parm.capture.timeperframe.numerator;
+	interval.interval.denominator = a->parm.capture.timeperframe.denominator;
+
+	ret = v4l2_subdev_call(sd, video, s_frame_interval, &interval);
+	if (ret == -ENOIOCTLCMD)
+			return -ENOTTY;
+
+	return ret;
+}
+static int tegra_channel_set_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	if (vb2_is_busy(&chan->queue))
+			return -EBUSY;
+
+	return __tegra_channel_set_parm(chan, a);
+}
+
 static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {
 	.vidioc_querycap		= tegra_channel_querycap,
 	.vidioc_enum_framesizes		= tegra_channel_enum_framesizes,
@@ -2255,6 +2308,9 @@ static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {
 	.vidioc_s_input			= tegra_channel_s_input,
 	.vidioc_log_status		= tegra_channel_log_status,
 	.vidioc_default			= tegra_channel_default_ioctl,
+	.vidioc_g_parm			= tegra_channel_get_parm,
+	.vidioc_s_parm			= tegra_channel_set_parm,
+
 };
 
 static int tegra_channel_close(struct file *fp);
@@ -2470,6 +2526,331 @@ static int tegra_channel_csi_init(struct tegra_channel *chan)
 	return ret;
 }
 
+static int tegra_metadata_open(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret;
+
+	mutex_lock(&chan->embedded.lock);
+	ret = v4l2_fh_open(fp);
+	mutex_unlock(&chan->embedded.lock);
+
+	return ret;
+}
+
+static int tegra_metadata_close(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret = _vb2_fop_release(fp, &chan->embedded.lock);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations tegra_metadata_fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.open           = tegra_metadata_open,
+	.release        = tegra_metadata_close,
+	.read           = vb2_fop_read,
+	.poll           = vb2_fop_poll,
+	.mmap           = vb2_fop_mmap,
+};
+
+static int tegra_metadata_querycap(struct file *file, void *fh,
+                                 struct v4l2_capability *cap)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct tegra_channel *chan = video_drvdata(file);
+
+	/* FIXME: why do Device Caps show V4L2_CAP_EXT_PIX_FORMAT? */
+	cap->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_EXT_PIX_FORMAT | V4L2_CAP_VIDEO_CAPTURE;
+
+	strlcpy(cap->driver, "tegra-embedded", sizeof(cap->driver));
+	strlcpy(cap->card, vfh->vdev->name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",
+			dev_name(chan->vi->dev), chan->port[0]);
+
+	return 0;
+}
+
+static int tegra_metadata_enum_format(struct file *file, void *fh,
+                                     struct v4l2_fmtdesc *f)
+{
+	if (f->index)
+		return -EINVAL;
+
+	f->pixelformat = V4L2_META_FMT_G2XX;
+	strlcpy(f->description, "G2XX metadata format", sizeof(f->description));
+
+	return 0;
+}
+
+static int tegra_metadata_get_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct v4l2_meta_format *fmt = &format->fmt.meta;
+
+	if (format->type != vfh->vdev->queue->type)
+		return -EINVAL;
+
+	memset(fmt, 0, sizeof(*fmt));
+
+	fmt->dataformat = V4L2_META_FMT_G2XX;
+	fmt->buffersize = 96; //255, orbbec modify
+
+	return 0;
+}
+static int tegra_metadata_set_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+   return 0;
+}
+
+static int tegra_metadata_try_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+    return 0;
+}
+static const struct v4l2_ioctl_ops tegra_metadata_ioctl_ops = {
+	.vidioc_querycap                = tegra_metadata_querycap,
+	.vidioc_enum_fmt_meta_cap       = tegra_metadata_enum_format,
+	.vidioc_g_fmt_meta_cap          = tegra_metadata_get_format,
+	.vidioc_s_fmt_meta_cap          = tegra_metadata_set_format,
+	.vidioc_try_fmt_meta_cap        = tegra_metadata_try_format,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+};
+
+static int tegra_metadata_queue_setup(struct vb2_queue *vq,
+                    unsigned int *nbuffers, unsigned int *nplanes,
+                    unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+
+	if (*nplanes) {
+		if (*nplanes != 1)
+			return -EINVAL;
+
+		if (sizes[0] < 96) //255, orbbec modify
+			return -EINVAL;
+
+		return 0;
+	}
+
+	*nplanes = 1;
+	sizes[0] = 96; //255, orbbec modify
+	alloc_devs[0] = chan->vi->dev;
+
+
+	return 0;
+}
+
+static int tegra_metadata_buffer_prepare(struct vb2_buffer *vb)
+{
+	if (vb->num_planes != 1)
+		return -EINVAL;
+
+	if (vb2_plane_size(vb, 0) < 96) //255, orbbec modify
+		return -EINVAL;
+
+	return 0;
+}
+
+static void tegra_metadata_buffer_queue(struct vb2_buffer *vb)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vb->vb2_queue);
+
+	spin_lock(&chan->embedded.spin_lock);
+	if (chan->embedded.num_buffers < 16) {
+		chan->embedded.buffers[chan->embedded.head] = vb;
+		chan->embedded.head++;
+		if (chan->embedded.head > 15)
+			chan->embedded.head = chan->embedded.head - 16;
+		chan->embedded.num_buffers++;
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+}
+
+static int tegra_metadata_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	return 0;
+}
+
+static void tegra_metadata_stop_streaming(struct vb2_queue *vq)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	int i = 0;
+
+	spin_lock(&chan->embedded.spin_lock);
+	for (i = 0; i < chan->embedded.num_buffers; i++) {
+		struct vb2_buffer *evb;
+		evb = chan->embedded.buffers[chan->embedded.tail];
+		chan->embedded.buffers[chan->embedded.tail] = NULL;
+		chan->embedded.tail++;
+		if (chan->embedded.tail > 15)
+			chan->embedded.tail = chan->embedded.tail - 16;
+		vb2_buffer_done(evb, VB2_BUF_STATE_ERROR);
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+
+	chan->embedded.head = 0;
+	chan->embedded.tail = 0;;
+	chan->embedded.num_buffers = 0;
+}
+
+static const struct vb2_ops tegra_metadata_qops = {
+	.queue_setup            = tegra_metadata_queue_setup,
+	.buf_prepare            = tegra_metadata_buffer_prepare,
+	.buf_queue              = tegra_metadata_buffer_queue,
+	.wait_prepare           = vb2_ops_wait_prepare,
+	.wait_finish            = vb2_ops_wait_finish,
+	.start_streaming        = tegra_metadata_start_streaming,
+	.stop_streaming         = tegra_metadata_stop_streaming,
+};
+
+int tegra_channel_init_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret;
+
+	mutex_init(&chan->embedded.lock);
+	spin_lock_init(&chan->embedded.spin_lock);
+
+	video = chan->embedded.video = video_device_alloc();
+	chan->embedded.pad.flags = MEDIA_PAD_FL_SINK;
+
+	ret = tegra_media_entity_init(&video->entity, 1,
+									&chan->embedded.pad, false, false);
+	if (ret < 0) {
+		video_device_release(video);
+		dev_err(vi->dev, "%s(): metadata entity init: %d\n",
+				__func__, ret);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_handler_init(&chan->embedded.ctrl_handler,
+									MAX_CID_CONTROLS);
+	if (chan->embedded.ctrl_handler.error) {
+		dev_err(&video->dev, "failed to init control handler\n");
+		return ret;
+	}
+
+	video->fops = &tegra_metadata_fops;
+	video->v4l2_dev = &vi->v4l2_dev;
+	video->queue = queue;
+	snprintf(video->name, sizeof(video->name), "%s-metadata-%u",
+			dev_name(vi->dev), chan->port[0]);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	video->vfl_type = VFL_TYPE_GRABBER;
+#else
+	video->vfl_type = VFL_TYPE_VIDEO;
+	video->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+#endif
+	video->vfl_dir = VFL_DIR_RX;
+	video->release = video_device_release_empty;
+	video->ioctl_ops = &tegra_metadata_ioctl_ops;
+	video->ctrl_handler = &chan->embedded.ctrl_handler;
+	video->lock = &chan->embedded.lock;
+
+	video_set_drvdata(video, chan);
+
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+	ret = tegra_vb2_dma_init(vi->dev, &chan->embedded.alloc_ctx,
+					SZ_64K, &vi->vb2_dma_alloc_refcnt);
+	if (ret < 0)
+		goto ctx_alloc_error;
+
+#endif
+//#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+//     chan->embedded.alloc_ctx = vb2_dma_contig_init_ctx(vi->dev);
+//     if (IS_ERR(chan->embedded.alloc_ctx)) {
+//             dev_err(vi->dev, "%s(): vb2 buffer init: %ld\n", __func__,
+//                     PTR_ERR(chan->embedded.alloc_ctx));
+//             goto ctx_alloc_error;
+//     }
+//#endif
+
+	queue->type = V4L2_BUF_TYPE_META_CAPTURE;
+	queue->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ | VB2_USERPTR;
+	queue->lock = &chan->embedded.lock;
+	queue->drv_priv = chan;
+	queue->buf_struct_size = sizeof(struct tegra_channel_buffer);
+	queue->ops = &tegra_metadata_qops;
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	queue->mem_ops = &vb2_dma_contig_memops;
+#endif
+	queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC |
+			V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	ret = vb2_queue_init(queue);
+	if (ret < 0) {
+		dev_err(vi->dev, "%s(): metadata queue initialize: %d\n",
+				__func__, ret);
+		goto vb2_queue_error;
+	}
+
+	return 0;
+
+vb2_queue_error:
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	tegra_vb2_dma_cleanup(vi->dev, chan->embedded.alloc_ctx,
+			&vi->vb2_dma_alloc_refcnt);
+ctx_alloc_error:
+#endif
+	media_entity_cleanup(&video->entity);
+
+	return ret;
+}
+
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video = chan->embedded.video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	if (!video)
+		return -EINVAL;
+
+	video_unregister_device(video);
+
+	/* release embedded data buffer */
+	if (chan->emb_buf_size > 0) {
+		dma_free_coherent(vi_unit_dev,
+				chan->emb_buf_size,
+				chan->emb_buf_addr, chan->emb_buf);
+		chan->emb_buf_size = 0;
+		vb2_queue_release(queue);
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+		tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+						&chan->vi->vb2_dma_alloc_refcnt);
+#endif
+	}
+
+	v4l2_ctrl_handler_free(&chan->embedded.ctrl_handler);
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&video->entity);
+#endif
+
+	video_device_release(video);
+
+	return 0;
+}
+
 int tegra_channel_init_video(struct tegra_channel *chan)
 {
 	struct tegra_mc_vi *vi = chan->vi;
@@ -2656,6 +3037,13 @@ int tegra_channel_cleanup(struct tegra_channel *chan)
 			chan->emb_buf_size,
 			chan->emb_buf_addr, chan->emb_buf);
 		chan->emb_buf_size = 0;
+		vb2_queue_release(&chan->embedded.queue);
+#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+		tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+			&chan->vi->vb2_dma_alloc_refcnt);
+		//vb2_dma_contig_cleanup_ctx(chan->embedded.alloc_ctx);
+#endif
+		media_entity_cleanup(&chan->embedded.video->entity);
 	}
 
 	tegra_channel_dealloc_buffer_queue(chan);
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c
index 7c2d05e74..5e25cf6ad 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c
@@ -292,6 +292,11 @@ static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
 	struct tegra_channel *chan =
 		container_of(notifier, struct tegra_channel, notifier);
 	struct tegra_vi_graph_entity *entity;
+	struct camera_common_data *s_data;
+	struct device_node *node;
+	struct sensor_mode_properties *sensor_mode = NULL;
+	int idx;
+
 	int ret;
 
 	dev_dbg(chan->vi->dev, "notify complete, all subdevs registered\n");
@@ -325,16 +330,46 @@ static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
 	if (ret < 0)
 		goto graph_error;
 
+	/* Init embedded channel only if embedded is set in DT*/
+	s_data = to_camera_common_data(chan->subdev_on_csi->dev);
+	node = chan->subdev_on_csi->dev->of_node;
+	if (s_data && node) {
+		idx = s_data->mode_prop_idx;
+		if (idx < s_data->sensor_props.num_modes)
+			sensor_mode = &s_data->sensor_props.sensor_modes[idx];
+	}
+
+	if (sensor_mode &&
+		sensor_mode->image_properties.embedded_metadata_height > 0) {
+		ret = tegra_channel_init_video_embedded(chan);
+		if (ret < 0) {
+			dev_err(chan->vi->dev,
+					"failed to initialize embedded channel\n");
+			goto register_embedded_device_error;
+		}
+		ret = video_register_device(chan->embedded.video, VFL_TYPE_VIDEO, -1);
+		if (ret < 0) {
+			dev_err(&chan->video->dev, "failed to register embedded %s: %d\n",
+					chan->embedded.video->name, ret);
+			goto register_embedded_device_error;
+		}
+	}
+
+
 	ret = v4l2_device_register_subdev_nodes(&chan->vi->v4l2_dev);
 	if (ret < 0) {
 		dev_err(chan->vi->dev, "failed to register subdev nodes\n");
-		goto graph_error;
+		goto register_nodes_error;
 	}
 
 	chan->link_status++;
 
 	return 0;
 
+register_nodes_error:
+	video_unregister_device(chan->embedded.video);
+register_embedded_device_error:
+	tegra_vi_graph_remove_links(chan);
 graph_error:
 	video_unregister_device(chan->video);
 register_device_error:
@@ -398,6 +433,7 @@ static void tegra_vi_graph_notify_unbind(struct v4l2_async_notifier *notifier,
 
 	/* cleanup for complete */
 	if (chan->link_status) {
+		tegra_channel_cleanup_video_embedded(chan);
 		tegra_vi_graph_remove_links(chan);
 		tegra_channel_cleanup_video(chan);
 		chan->link_status--;
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/mc_common.c b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/mc_common.c
index ae6b49274..6288d712d 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/mc_common.c
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/mc_common.c
@@ -164,6 +164,10 @@ static int vi_parse_dt(struct tegra_mc_vi *vi, struct platform_device *dev)
 	struct device_node *port;
 	int value = 0xFF;
 	int ret = 0;
+	struct device_node *dser_node = NULL;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *ser_node = NULL;
+	struct i2c_client *ser_i2c = NULL;
 
 	err = of_property_read_u32(node, "num-channels", &num_channels);
 	if (err) {
@@ -173,6 +177,29 @@ static int vi_parse_dt(struct tegra_mc_vi *vi, struct platform_device *dev)
 	}
 	vi->num_channels = num_channels;
 
+	vi->dser_dev = NULL;
+	dser_node = of_parse_phandle(node, "nvidia,gmsl-dser-device", 0);
+	if (dser_node) {
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+		if (dser_i2c) {
+			dev_info(&dev->dev, "dser_i2c->addr 0x%x", dser_i2c->addr);
+			vi->dser_dev = &dser_i2c->dev;
+		}
+	}
+
+	vi->ser_dev = NULL;
+	ser_node = of_parse_phandle(node, "nvidia,gmsl-ser-device", 0);
+	if (ser_node) {
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+		if (ser_i2c) {
+			dev_info(&dev->dev, "ser_i2c->addr 0x%x", ser_i2c->addr);
+			vi->ser_dev = &ser_i2c->dev;
+		}
+	}
+
+	vi->num_channels = num_channels;
 	ports = of_get_child_by_name(node, "ports");
 	if (ports == NULL)
 		ports = node;
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c
index 7b16dcaf3..12b49d306 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c
@@ -426,6 +426,39 @@ static void vi5_setup_surface(struct tegra_channel *chan,
 		chan->capture_descr_sequence += 1;
 }
 
+static void vi5_release_metadata_buffer(struct tegra_channel *chan,
+	struct vb2_v4l2_buffer *vbuf)
+{
+	struct vb2_buffer *evb = NULL;
+	struct vb2_v4l2_buffer *evbuf;
+	void* frm_buffer;
+
+	spin_lock(&chan->embedded.spin_lock);
+	if (0 < chan->embedded.num_buffers) {
+		evb = chan->embedded.buffers[chan->embedded.tail];
+		chan->embedded.buffers[chan->embedded.tail] = NULL;
+		chan->embedded.tail++;
+		if (chan->embedded.tail > 15)
+			chan->embedded.tail = chan->embedded.tail - 16;
+		chan->embedded.num_buffers--;
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+
+	if (!evb)
+		return;
+
+	frm_buffer = vb2_plane_vaddr(evb, 0);
+	if (!frm_buffer)
+		return;
+
+	memcpy(frm_buffer, chan->emb_buf_addr, 96); //255, orbbec modify
+	evbuf = to_vb2_v4l2_buffer(evb);
+	evbuf->sequence = vbuf->sequence;
+	vb2_set_plane_payload(evb, 0, 96); //68, orbbec modify
+	evb->timestamp = vbuf->vb2_buf.timestamp;
+	vb2_buffer_done(evb, VB2_BUF_STATE_DONE);
+}
+
 static void vi5_release_buffer(struct tegra_channel *chan,
 	struct tegra_channel_buffer *buf)
 {
@@ -436,6 +469,9 @@ static void vi5_release_buffer(struct tegra_channel *chan,
 	vb2_set_plane_payload(&vbuf->vb2_buf, 0, chan->format.sizeimage);
 
 	vb2_buffer_done(&vbuf->vb2_buf, buf->vb2_state);
+
+	if (chan->embedded_data_height == 1 && buf->vb2_state == VB2_BUF_STATE_DONE)
+		vi5_release_metadata_buffer(chan, vbuf);
 }
 
 static void vi5_capture_enqueue(struct tegra_channel *chan,
@@ -511,8 +547,8 @@ static void vi5_capture_dequeue(struct tegra_channel *chan,
 		if (err) {
 			if (err == -ETIMEDOUT) {
 				dev_err(vi->dev,
-					"uncorr_err: request timed out after %d ms\n",
-					CAPTURE_TIMEOUT_MS);
+					"uncorr_err: request timed out after %d ms, port=%d, vc-id=%d\n",
+					CAPTURE_TIMEOUT_MS, vi_port, chan->virtual_channel);
 			} else {
 				dev_err(vi->dev, "uncorr_err: request err %d\n", err);
 			}
@@ -526,9 +562,16 @@ static void vi5_capture_dequeue(struct tegra_channel *chan,
 			} else {
 				dev_warn(vi->dev,
 					"corr_err: discarding frame %d, flags: %d, "
-					"err_data %d\n",
+					"err_data %d, vc: %d\n",
 					descr->status.frame_id, descr->status.flags,
-					descr->status.err_data);
+					descr->status.err_data, chan->virtual_channel);
+
+				/* G335Lg: err_data 131072 (20000h) | 64 (40h) | 4194400 (400060h) | 512(200h) |262144(40000) | 256 (100h)leading to channel
+				* timeout. This happens when first frame is corrupted - no md
+				* and less lines than requested. Channel reset time is 6ms */
+				if (descr->status.err_data & 0x460360) {
+					goto uncorr_err;
+				}
 				frame_err = true;
 			}
 		} else if (!vi_port) {
@@ -583,13 +626,15 @@ static int vi5_channel_error_recover(struct tegra_channel *chan,
 	struct tegra_mc_vi *vi = chan->vi;
 	struct v4l2_subdev *csi_subdev;
 
+	dev_info(chan->vi->dev, "%s() vc: %d\n", __func__, chan->virtual_channel);
+
 	/* stop vi channel */
 	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+		if(chan->tegra_vi_channel[vi_port] != NULL)
+			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
 		if (err) {
 			dev_err(&chan->video->dev, "vi capture release failed\n");
-			goto done;
 		}
 		vi_channel_close_ex(chan->vi_channel_id[vi_port],
 					chan->tegra_vi_channel[vi_port]);
@@ -930,10 +975,11 @@ err_set_stream:
 
 err_start_kthreads:
 	if (!chan->bypass)
-		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++)
-			vi_capture_release(chan->tegra_vi_channel[vi_port],
-				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
-
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++){
+			if(chan->tegra_vi_channel[vi_port] != NULL)
+				vi_capture_release(chan->tegra_vi_channel[vi_port],
+					CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+		}
 err_setup:
 	if (!chan->bypass)
 		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
@@ -962,8 +1008,9 @@ static int vi5_channel_stop_streaming(struct vb2_queue *vq)
 
 	if (!chan->bypass) {
 		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+			if(chan->tegra_vi_channel[vi_port] != NULL)
+				err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+					CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
 
 			if (err)
 				dev_err(&chan->video->dev,
diff --git a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h
index 1d0c1133c..044837036 100644
--- a/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h
+++ b/kernel/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h
@@ -82,14 +82,21 @@ static const struct tegra_video_format vi5_video_formats[] = {
 	/* RAW 7: TODO */
 
 	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_R8,
+				RAW8, GREY, "Greyscale 8"),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_R8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_R8,
 				RAW8, SGRBG8, "GRGR.. BGBG.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGBRG8_1X8, 1, 1, T_R8,
 				RAW8, SGBRG8, "GBGB.. RGRG.."),
+#if 0 //orbbec del
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SBGGR8_1X8, 1, 1, T_R8,
-				RAW8, SBGGR8, "BGBG.. GRGR.."),
+				RAW8, SBGGR8, "BGBG.. GRGR.."), 
+#else //orbbec add
+	TEGRA_VIDEO_FORMAT(RAW8, 8, SBGGR8_1X8, 1, 1, T_R8,
+				RAW8, MJPEG, "Motion-JPEG"),
+#endif
 
 	/* RAW 10 */
 	TEGRA_VIDEO_FORMAT(RAW10, 10, SRGGB10_1X10, 2, 1, T_R16,
@@ -100,34 +107,53 @@ static const struct tegra_video_format vi5_video_formats[] = {
 				RAW10, SGBRG10, "GBGB.. RGRG.."),
 	TEGRA_VIDEO_FORMAT(RAW10, 10, SBGGR10_1X10, 2, 1, T_R16,
 				RAW10, SBGGR10, "BGBG.. GRGR.."),
+	//orbbec add
+	TEGRA_VIDEO_FORMAT(RAW10, 10, Y10_1X10, 2, 1, T_R16,
+				RAW10, Y10, "10-bit Greyscale"),
 
 	/* RAW 12 */
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SRGGB12_1X12, 2, 1, T_R16,
 				RAW12, SRGGB12, "RGRG.. GBGB.."),
+
+#if 0 /* orbbec del */
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SGRBG12_1X12, 2, 1, T_R16,
 				RAW12, SGRBG12, "GRGR.. BGBG.."),
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SGBRG12_1X12, 2, 1, T_R16,
 				RAW12, SGBRG12, "GBGB.. RGRG.."),
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SBGGR12_1X12, 2, 1, T_R16,
 				RAW12, SBGGR12, "BGBG.. GRGR.."),
+#else /* orbbec add */
+	TEGRA_VIDEO_FORMAT(RAW12, 12, Y12_1X12, 2, 1, T_R16,
+				RAW12, Y12, "12-bit Greyscale"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SGRBG12_1X12, 2, 1, T_R16,
+				RAW12, NV12, "Y/CbCr 4:2:0"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SGBRG12_1X12, 2, 1, T_R16,
+				RAW12,  NV21, "Y/CbCr 4:2:0"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SBGGR12_1X12, 2, 1, T_R16,
+				RAW12, H264, "H.264"),
+
+	/* RAW 14 */
+	TEGRA_VIDEO_FORMAT(RAW14, 14, Y14_1X14, 2, 1, T_R16,
+				RAW14, Y14, "14-bit Greyscale"),
+#endif
 
 	/* RGB888 */
-	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
-				RGB888, RGBA32, "RGBA-8-8-8-8"),
+	// TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+	// 			RGB888, RGBA32, "RGBA-8-8-8-8"),
 	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X32_PADHI, 4, 1, T_A8B8G8R8,
 				RGB888, RGB32, "RGB-8-8-8-8"),
 
 	/* YUV422 */
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
-				YUV422_8, UYVY, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
-				YUV422_8, VYUY, "YUV 4:2:2"),
+				YUV422_8, UYVY, "YUV 4:2:2"), //orbbec add
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+	// 			YUV422_8, VYUY, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
 				YUV422_8, YUYV, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
-				YUV422_8, NV16, "NV16"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+	// 			YUV422_8, NV16, "NV16"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
@@ -136,6 +162,25 @@ static const struct tegra_video_format vi5_video_formats[] = {
 				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_U8_Y8__V8_Y8, //UYVY8_1X16, orbbec modify
+				YUV422_8, Z16, "Depth 16"),
+
+	/* RAW 16 */
+#if 1 //orbbec add
+	TEGRA_VIDEO_FORMAT(YUV422, 16, Y16_1X16, 2, 1, T_R16,
+				YUV422_8, Y16, "16-bit Greyscale"),
+#else //orbbec del
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, Y8I, "Y8I 16"),
+#endif
+	// TODO: RealSesne calibration format Y12I should be 3-byte,
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4]
+	// but, currently, it's 4-byte, one byte is added as alignment
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4] | ALIGN[7:0]
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+				RGB888, Y12I, "Y12I 24"),
+
 };
 
 #endif
diff --git a/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h b/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
index e503f0af2..2c9b830f4 100644
--- a/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
+++ b/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
@@ -26,6 +26,7 @@ struct tegra_capture_ivc_cb_ctx {
 	tegra_capture_ivc_cb_func cb_func;
 	/** Private context of a VI/ISP capture context */
 	const void *priv_context;
+	struct semaphore sem_ch;
 };
 
 /**
diff --git a/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c b/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c
index 14e1ba3ee..34d62daa2 100644
--- a/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c
+++ b/kernel/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c
@@ -22,6 +22,10 @@
 #include <trace/events/tegra_capture.h>
 
 #include "capture-ivc-priv.h"
+#include <linux/semaphore.h>
+
+/* Timeout for acquiring channel-id */
+#define TIMEOUT_ACQUIRE_CHANNEL_ID 120
 
 static int tegra_capture_ivc_tx_(struct tegra_capture_ivc *civc,
 				const void *req, size_t len)
@@ -184,6 +188,10 @@ int tegra_capture_ivc_notify_chan_id(uint32_t chan_id, uint32_t trans_id)
 
 	civc = __scivc_control;
 
+    if (down_timeout(&civc->cb_ctx[chan_id].sem_ch, TIMEOUT_ACQUIRE_CHANNEL_ID)) {
+        return -EBUSY;
+    }
+
 	mutex_lock(&civc->cb_ctx_lock);
 
 	if (WARN(civc->cb_ctx[trans_id].cb_func == NULL,
@@ -278,6 +286,8 @@ int tegra_capture_ivc_unregister_control_cb(uint32_t id)
 
 	mutex_lock(&civc->cb_ctx_lock);
 
+	up(&civc->cb_ctx[id].sem_ch);
+
 	if (WARN(civc->cb_ctx[id].cb_func == NULL,
 			"control channel %u is idle", id)) {
 		mutex_unlock(&civc->cb_ctx_lock);
@@ -454,6 +464,8 @@ static int tegra_capture_ivc_probe(struct tegra_ivc_channel *chan)
 	mutex_init(&civc->cb_ctx_lock);
 	mutex_init(&civc->ivc_wr_lock);
 
+	for (i = 0; i < TOTAL_CHANNELS; i++) sema_init(&civc->cb_ctx[i].sem_ch, 1);
+
 	/* Initialize kworker */
 	kthread_init_work(&civc->work, tegra_capture_ivc_worker);
 
diff --git a/kernel/nvidia-oot/include/media/gmsl-link.h b/kernel/nvidia-oot/include/media/gmsl-link.h
index ad902d0a7..da05e677c 100644
--- a/kernel/nvidia-oot/include/media/gmsl-link.h
+++ b/kernel/nvidia-oot/include/media/gmsl-link.h
@@ -35,11 +35,18 @@
 
 #define GMSL_SERDES_CSI_LINK_A 0x1
 #define GMSL_SERDES_CSI_LINK_B 0x2
+#define GMSL_SERDES_CSI_LINK_AUTO 0x3
 
 /* Didn't find kernel defintions, for now adding here */
 #define GMSL_CSI_DT_RAW_12 0x2C
 #define GMSL_CSI_DT_UED_U1 0x30
 #define GMSL_CSI_DT_EMBED 0x12
+#define GMSL_CSI_DT_YUV422_8 0x1E
+#define GMSL_CSI_DT_RGB_888 0x24
+#define GMSL_CSI_DT_RAW_8 0x2A
+/* orbbec add */
+#define GMSL_CSI_DT_RAW_10 0x2B
+#define GMSL_CSI_DT_RAW_14 0x2D
 
 #define GMSL_ST_ID_UNUSED 0xFF
 
diff --git a/kernel/nvidia-oot/include/media/max9295.h b/kernel/nvidia-oot/include/media/max9295.h
index bf801aa24..db007730e 100644
--- a/kernel/nvidia-oot/include/media/max9295.h
+++ b/kernel/nvidia-oot/include/media/max9295.h
@@ -12,6 +12,7 @@
 #ifndef __MAX9295_H__
 #define __MAX9295_H__
 
+#include <linux/types.h>
 #include <media/gmsl-link.h>
 /**
  * \defgroup max9295 MAX9295 serializer driver
@@ -22,6 +23,8 @@
  * @{
  */
 
+int max9295_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+		     u8 data_type2, u32 vc_id);
 
 /**
  * @brief  Powers on a serializer device and performs the I2C overrides
@@ -82,6 +85,14 @@ int max9295_sdev_unpair(struct device *dev, struct device *s_dev);
  */
 int max9295_setup_streaming(struct device *dev);
 
+int max9295_init_settings(struct device *dev);
+
+int max9295_set_orbbec_on(struct device *dev);
+
+int max9295_set_orbbec_off(struct device *dev);
+
+int max9295_update_pipe(struct device *dev, int sensor_type, u32 fourcc);
+
 /** @} */
 
 #endif  /* __MAX9295_H__ */
diff --git a/kernel/nvidia-oot/include/media/max9296.h b/kernel/nvidia-oot/include/media/max9296.h
index 210dbc80a..835deb856 100644
--- a/kernel/nvidia-oot/include/media/max9296.h
+++ b/kernel/nvidia-oot/include/media/max9296.h
@@ -12,6 +12,7 @@
 #ifndef __MAX9296_H__
 #define __MAX9296_H__
 
+#include <linux/types.h>
 #include <media/gmsl-link.h>
 /**
  * \defgroup max9296 MAX9296 deserializer driver
@@ -22,6 +23,13 @@
  * @{
  */
 
+int max9296_get_available_pipe_id(struct device *dev, int vc_id);
+int max9296_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+//		     u8 data_type2, u32 vc_id);
+		     u8 data_type2, u32 srcvc_id, u32 dtsvc_id);
+int max9296_release_pipe(struct device *dev, int pipe_id);
+void max9296_reset_oneshot(struct device *dev);
+
 /**
  * Puts a deserializer device in single exclusive link mode, so link-specific
  * I2C overrides can be performed for sensor and serializer devices.
@@ -146,6 +154,12 @@ int max9296_power_on(struct device *dev);
  */
 void max9296_power_off(struct device *dev);
 
+int max9296_init_settings(struct device *dev);
+
+int max9296_get_link_state(struct device *dev, int *value);
+
+int max9296_update_pipe(struct device *dev, int sensor_type, u32 fourcc);
+
 /** @} */
 
 #endif  /* __MAX9296_H__ */
diff --git a/kernel/nvidia-oot/include/media/mc_common.h b/kernel/nvidia-oot/include/media/mc_common.h
index 0408ba670..1252fb3fc 100644
--- a/kernel/nvidia-oot/include/media/mc_common.h
+++ b/kernel/nvidia-oot/include/media/mc_common.h
@@ -224,6 +224,23 @@ struct tegra_channel {
 	unsigned int embedded_data_width;
 	unsigned int embedded_data_height;
 
+	struct {
+		struct video_device *video;
+		struct mutex lock;
+		spinlock_t spin_lock;
+		struct vb2_queue queue;
+		/*FIXME: 16 is max queued metadata buffers
+		* define 16
+		*/
+		struct vb2_buffer *buffers[16];
+		unsigned int head;
+		unsigned int tail;
+		unsigned int num_buffers;
+		void *alloc_ctx;
+		struct media_pad pad;
+		struct v4l2_ctrl_handler ctrl_handler;
+	} embedded;
+
 	DECLARE_BITMAP(fmts_bitmap, MAX_FORMAT_NUM);
 	atomic_t power_on_refcnt;
 	struct v4l2_fh *fh;
@@ -304,6 +321,9 @@ struct tegra_mc_vi {
 	unsigned int num_channels;
 	unsigned int num_subdevs;
 
+	struct device *dser_dev;
+	struct device *ser_dev;
+
 	struct tegra_csi_device *csi;
 	struct list_head vi_chans;
 	struct tegra_channel *tpg_start;
@@ -400,7 +420,9 @@ struct tegra_channel_buffer *dequeue_inflight(struct tegra_channel *chan);
 int tegra_channel_set_power(struct tegra_channel *chan, bool on);
 
 int tegra_channel_init_video(struct tegra_channel *chan);
+int tegra_channel_init_video_embedded(struct tegra_channel *chan);
 int tegra_channel_cleanup_video(struct tegra_channel *chan);
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan);
 
 struct tegra_vi_fops {
 	int (*vi_power_on)(struct tegra_channel *chan);
diff --git a/kernel/nvidia-oot/include/media/tegra_camera_core.h b/kernel/nvidia-oot/include/media/tegra_camera_core.h
index e6d9a2b1c..94b1eeeeb 100644
--- a/kernel/nvidia-oot/include/media/tegra_camera_core.h
+++ b/kernel/nvidia-oot/include/media/tegra_camera_core.h
@@ -18,7 +18,7 @@
 /* Width alignment */
 #define TEGRA_WIDTH_ALIGNMENT	1
 /* Stride alignment */
-#define TEGRA_STRIDE_ALIGNMENT	1
+#define TEGRA_STRIDE_ALIGNMENT	64 //1, orbbec modify
 /* Height alignment */
 #define TEGRA_HEIGHT_ALIGNMENT	1
 /* Size alignment */
@@ -32,6 +32,8 @@
 #define TEGRA_IMAGE_FORMAT_DEF	32
 
 enum tegra_image_dt {
+	TEGRA_IMAGE_DT_EMBEDDED_8 = 18,
+
 	TEGRA_IMAGE_DT_YUV420_8 = 24,
 	TEGRA_IMAGE_DT_YUV420_10,
 
@@ -51,6 +53,12 @@ enum tegra_image_dt {
 	TEGRA_IMAGE_DT_RAW10,
 	TEGRA_IMAGE_DT_RAW12,
 	TEGRA_IMAGE_DT_RAW14,
+
+	TEGRA_IMAGE_DT_USER_1 = 48,
+	TEGRA_IMAGE_DT_USER_2,
+	TEGRA_IMAGE_DT_USER_3,
+	TEGRA_IMAGE_DT_USER_4,
+
 };
 
 /* Supported CSI to VI Data Formats */
