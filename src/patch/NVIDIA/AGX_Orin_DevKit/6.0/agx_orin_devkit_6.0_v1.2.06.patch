 Linux_for_Tegra/source/Makefile                    |    3 +-
 .../t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi |    4 +-
 .../nvidia/t23x/nv-public/overlay/Makefile         |    7 +-
 .../tegra234-p3737-camera-g300-fg96-overlay.dts    | 3213 ++++++++++++++++++++
 .../tegra234-p3737-camera-g300-leopard-overlay.dts | 3158 +++++++++++++++++++
 ...egra234-p3737-camera-g300-mic-fg-8g-overlay.dts | 3147 +++++++++++++++++++
 ...gra234-p3737-camera-g300-nomtd-fg96-overlay.dts | 3213 ++++++++++++++++++++
 ...234-p3737-camera-g300-nomtd-leopard-overlay.dts | 3158 +++++++++++++++++++
 ...gra234-p3767-camera-p3768-g300-fg96-overlay.dts | 1679 ++++++++++
 .../drivers/media/v4l2-core/v4l2-ioctl.c           |    3 +
 .../kernel/kernel-jammy-src/drivers/of/address.c   |   15 +-
 .../include/uapi/linux/media-bus-format.h          |    1 +
 .../include/uapi/linux/videodev2.h                 |    4 +
 .../source/nvidia-oot/drivers/media/i2c/Makefile   |    8 +
 .../source/nvidia-oot/drivers/media/i2c/obc_g300.c | 1501 +++++++++
 .../nvidia-oot/drivers/media/i2c/obc_g300_ctrl.c   | 1548 ++++++++++
 .../nvidia-oot/drivers/media/i2c/obc_g300_seri.c   |  237 ++
 .../nvidia-oot/drivers/media/i2c/obc_max9296.c     | 1323 ++++++++
 .../nvidia-oot/drivers/media/i2c/obc_max96712.c    | 1457 +++++++++
 .../tegra/camera/fusa-capture/capture-vi-channel.c |   29 +-
 .../media/platform/tegra/camera/sensor_common.c    |    6 +
 .../media/platform/tegra/camera/vi/channel.c       |  405 ++-
 .../drivers/media/platform/tegra/camera/vi/graph.c |   42 +-
 .../media/platform/tegra/camera/vi/vi5_fops.c      |   83 +-
 .../media/platform/tegra/camera/vi/vi5_formats.h   |   43 +-
 .../source/nvidia-oot/drivers/misc/Makefile        |    2 +
 .../source/nvidia-oot/drivers/misc/obc_cam_sync.c  |  874 ++++++
 .../platform/tegra/rtcpu/capture-ivc-priv.h        |    1 +
 .../drivers/platform/tegra/rtcpu/capture-ivc.c     |   12 +
 .../source/nvidia-oot/include/media/gmsl-link.h    |    8 +
 .../source/nvidia-oot/include/media/mc_common.h    |   21 +-
 .../nvidia-oot/include/media/obc_g300_priv.h       |  262 ++
 .../source/nvidia-oot/include/media/obc_max9296.h  |   53 +
 .../source/nvidia-oot/include/media/obc_max96712.h |   53 +
 .../nvidia-oot/include/media/tegra_camera_core.h   |    5 +-
 35 files changed, 25535 insertions(+), 43 deletions(-)

diff --git a/Linux_for_Tegra/source/Makefile b/Linux_for_Tegra/source/Makefile
index 5499ee71f..a0c556b76 100644
--- a/Linux_for_Tegra/source/Makefile
+++ b/Linux_for_Tegra/source/Makefile
@@ -123,7 +123,8 @@ endef
 
 nvidia-headers: nvidia-oot
 	mkdir -p $(NVIDIA_HEADERS)
-	cp -LR $(KERNEL_HEADERS)/* $(NVIDIA_HEADERS)
+	# cp -LR $(KERNEL_HEADERS)/* $(NVIDIA_HEADERS)
+	rsync -aL --info=progress2 "$(KERNEL_HEADERS)/" "$(NVIDIA_HEADERS)/"
 	if [ "$(KERNEL_HEADERS)" != "$(KERNEL_OUTPUT)" ] ; then \
 		cp -LR $(KERNEL_OUTPUT)/include/* $(NVIDIA_HEADERS)/include/ ; \
 		cp -LR $(KERNEL_OUTPUT)/arch/arm64/include/* $(NVIDIA_HEADERS)/arch/arm64/include/ ; \
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi
index 52cbe5141..5e9e67422 100644
--- a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/nv-soc/tegra234-soc-camera.dtsi
@@ -28,7 +28,7 @@
 				iommus = <&smmu_iso TEGRA234_SID_ISO_VI>;
 				interconnects = <&mc TEGRA234_MEMORY_CLIENT_VIW &emc>;
 				interconnect-names = "write";
-				non-coherent;
+				dma-noncoherent;
 				status = "okay";
 			};
 
@@ -52,7 +52,7 @@
 				iommus = <&smmu_iso TEGRA234_SID_ISO_VI2>;
 				interconnects = <&mc TEGRA234_MEMORY_CLIENT_VI2W &emc>;
 				interconnect-names = "write";
-				non-coherent;
+				dma-noncoherent;
 				status = "okay";
 			};
 
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/Makefile b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/Makefile
index c88bbe207..02014a7de 100644
--- a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/Makefile
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/Makefile
@@ -60,7 +60,12 @@ dtbo-y += tegra234-p3767-camera-p3768-imx219-A.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx219-imx477.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx477-C.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx477-A.dtbo
-
+dtbo-y += tegra234-p3737-camera-g300-fg96-overlay.dtbo  # orbbec add
+dtbo-y += tegra234-p3737-camera-g300-nomtd-fg96-overlay.dtbo  # orbbec add
+dtbo-y += tegra234-p3737-camera-g300-leopard-overlay.dtbo  # orbbec add
+dtbo-y += tegra234-p3767-camera-p3768-g300-fg96-overlay.dtbo # orbbec add
+dtbo-y += tegra234-p3737-camera-g300-mic-fg-8g-overlay.dtbo		# orbbec add
+dtbo-y += tegra234-p3737-camera-g300-nomtd-leopard-overlay.dtbo  # orbbec add
 ifneq ($(dtb-y),)
 dtb-y := $(addprefix $(makefile-path)/,$(dtb-y))
 endif
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-fg96-overlay.dts b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-fg96-overlay.dts
new file mode 100644
index 000000000..cc6afd6b6
--- /dev/null
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-fg96-overlay.dts
@@ -0,0 +1,3213 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2024-2029, ORBBEC CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h> 
+
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(H, 6)  //Pin93 --- UART4_CTS L49/397 - MAX9296_1 PWDN
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(H, 3)  //Pin95 --- UART4_TX L5/394 - MAX9296_2 PWDN
+#define CAM2_PWDN	TEGRA234_MAIN_GPIO(AC, 0) //Pin90 --- GPIO15 F10/486 - MAX9296_3 PWDN
+#define CAM3_PWDN	TEGRA234_MAIN_GPIO(AC, 1) //Pin92 --- GPIO16 E9/487 - MAX9296_4 PWDN
+#define CAM12V_POC	TEGRA234_MAIN_GPIO(AC, 7) //Pin119 --- GPIO12 E10 CAM_VDD_SYS_EN/493 Low enable
+#define CAM_SYNCALL	TEGRA234_AON_GPIO(CC, 0)  //E61/SPI2_CLK CAM_INT1/328 -- MAX9296x4 MFP6
+
+#define SYNC_IN    TEGRA234_AON_GPIO(BB, 0) //(BB, 0)
+
+#define PPS_TRIGGER  TEGRA234_AON_GPIO(BB, 2)//(BB, 2)
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson AGX CSI Connector";
+    compatible = JETSON_COMPATIBLE;
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <32>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						status = "okay";
+						g300_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "okay";
+						g300_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <2>;
+						status = "okay";
+						g300_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <3>;
+						status = "okay";
+						g300_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <4>;
+						status = "okay";
+						g300_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <5>;
+						status = "okay";
+						g300_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <6>;
+						status = "okay";
+						g300_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <7>;
+						status = "okay";
+						g300_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <8>;
+						status = "okay";
+						g300_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <9>;
+						status = "okay";
+						g300_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out9>;
+						};
+					};
+					port@10 {
+						reg = <10>;
+						status = "okay";
+						g300_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out10>;
+						};
+					};
+					port@11 {
+						reg = <11>;
+						status = "okay";
+						g300_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out11>;
+						};
+					};
+
+					port@12 {
+						reg = <12>;
+						status = "okay";
+						g300_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out12>;
+						};
+					};
+					port@13 {
+						reg = <13>;
+						status = "okay";
+						g300_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out13>;
+						};
+					};
+					port@14 {
+						reg = <14>;
+						status = "okay";
+						g300_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out14>;
+						};
+					};
+					port@15 {
+						reg = <15>;
+						status = "okay";
+						g300_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out15>;
+						};
+					};
+
+					port@16 {
+						reg = <16>;
+						status = "okay";
+						g300_vi_in16: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out16>;
+						};
+					};
+					port@17 {
+						reg = <17>;
+						status = "okay";
+						g300_vi_in17: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out17>;
+						};
+					};
+					port@18 {
+						reg = <18>;
+						status = "okay";
+						g300_vi_in18: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out18>;
+						};
+					};
+					port@19 {
+						reg = <19>;
+						status = "okay";
+						g300_vi_in19: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out19>;
+						};
+					};
+
+					port@20 {
+						reg = <20>;
+						status = "okay";
+						g300_vi_in20: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out20>;
+						};
+					};
+					port@21 {
+						reg = <21>;
+						status = "okay";
+						g300_vi_in21: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out21>;
+						};
+					};
+					port@22 {
+						reg = <22>;
+						status = "okay";
+						g300_vi_in22: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out22>;
+						};
+					};
+					port@23 {
+						reg = <23>;
+						status = "okay";
+						g300_vi_in23: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out23>;
+						};
+					};
+
+					port@24 {
+						reg = <24>;
+						status = "okay";
+						g300_vi_in24: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out24>;
+						};
+					};
+					port@25 {
+						reg = <25>;
+						status = "okay";
+						g300_vi_in25: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out25>;
+						};
+					};
+					port@26 {
+						reg = <26>;
+						status = "okay";
+						g300_vi_in26: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out26>;
+						};
+					};
+					port@27 {
+						reg = <27>;
+						status = "okay";
+						g300_vi_in27: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out27>;
+						};
+					};
+
+					port@28 {
+						reg = <28>;
+						status = "okay";
+						g300_vi_in28: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out28>;
+						};
+					};
+					port@29 {
+						reg = <29>;
+						status = "okay";
+						g300_vi_in29: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out29>;
+						};
+					};
+					port@30 {
+						reg = <30>;
+						status = "okay";
+						g300_vi_in30: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out30>;
+						};
+					};
+					port@31 {
+						reg = <31>;
+						status = "okay";
+						g300_vi_in31: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out31>;
+						};
+					};
+				};
+			};
+			tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <16>;
+				max_lane_speed = <1500000>;
+				min_bits_per_pixel = <8>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				max_pixel_rate = <750000>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+				status = "okay";
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "g300_0";
+						position = "topleft";
+						orientation = "1";
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m3@6D";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "g300_1";
+						position = "topright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m3@6D";
+						};
+					};
+
+					module2 {
+						status = "okay";
+						badge = "g300_2";
+						position = "bottomleft";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m3@6D";
+						};
+					};
+					module3 {
+						status = "okay";
+						badge = "g300_3";
+						position = "bottomright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m3@6D";
+						};
+					};
+				};
+			};
+
+			obc_cam_sync {
+				compatible = "orbbec,obc_cam_sync";
+				ranges = <0x0 0x0 0xc6a0000 0x10000>;
+				reg = <0x0 0xc6a0000 0x0 0x18>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				status = "okay";
+				//sync-in-gpios = <&gpio_aon SYNC_IN GPIO_ACTIVE_HIGH>;
+				//sync-out-gpios = <&gpio_aon CAM_SYNCALL GPIO_ACTIVE_HIGH>;  //Use hrtimer to generate trigger signals
+				pwms = <&pwm8 0 33333333>; //Use PWM to generate trigger signals, Default PWM mode, if use hrtimer comment out this line
+				/* EDGE_OUT #3 */
+				generator@500 {
+					reg = <0x500 0x80>;
+					freq_hz = <30>;
+					duty_cycle = <10>;
+					offset_ms = <0>;
+					status = "okay";
+				};
+			};
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <32>;
+
+						channel@0 {
+							reg = <0>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <1>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <2>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <3>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in3>;
+									};
+								};
+							};
+						};
+
+						channel@4 {
+							reg = <4>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <5>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <6>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <7>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in7>;
+									};
+								};
+							};
+						};
+
+						channel@8 {
+							reg = <8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@10 {
+							reg = <10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in11>;
+									};
+								};
+							};
+						};
+
+						channel@12 {
+							reg = <12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@14 {
+							reg = <14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in15>;
+									};
+								};
+							};
+						};
+
+						channel@16 {
+							reg = <16>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in16: endpoint@32 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out16: endpoint@33 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in16>;
+									};
+								};
+							};
+						};
+						channel@17 {
+							reg = <17>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in17: endpoint@34 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out17: endpoint@35 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in17>;
+									};
+								};
+							};
+						};
+						channel@18 {
+							reg = <18>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in18: endpoint@36 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out18: endpoint@37 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in18>;
+									};
+								};
+							};
+						};
+						channel@19 {
+							reg = <19>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in19: endpoint@38 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out19: endpoint@39 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in19>;
+									};
+								};
+							};
+						};
+
+						channel@20 {
+							reg = <20>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in20: endpoint@40 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out20: endpoint@41 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in20>;
+									};
+								};
+							};
+						};
+						channel@21 {
+							reg = <21>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in21: endpoint@42 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out21: endpoint@43 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in21>;
+									};
+								};
+							};
+						};
+						channel@22 {
+							reg = <22>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in22: endpoint@44 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out22: endpoint@45 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in22>;
+									};
+								};
+							};
+						};
+						channel@23 {
+							reg = <23>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in23: endpoint@46 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out23: endpoint@47 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in23>;
+									};
+								};
+							};
+						};
+
+						channel@24 {
+							reg = <24>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in24: endpoint@48 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out24: endpoint@49 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in24>;
+									};
+								};
+							};
+						};
+						channel@25 {
+							reg = <25>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in25: endpoint@50 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out25: endpoint@51 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in25>;
+									};
+								};
+							};
+						};
+						channel@26 {
+							reg = <26>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in26: endpoint@52 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out26: endpoint@53 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in26>;
+									};
+								};
+							};
+						};
+						channel@27 {
+							reg = <27>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in27: endpoint@54 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out27: endpoint@55 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in27>;
+									};
+								};
+							};
+						};
+
+						channel@28 {
+							reg = <28>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in28: endpoint@56 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out28: endpoint@57 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in28>;
+									};
+								};
+							};
+						};
+						channel@29 {
+							reg = <29>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in29: endpoint@58 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out29: endpoint@59 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in29>;
+									};
+								};
+							};
+						};
+						channel@30 {
+							reg = <30>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in30: endpoint@60 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out30: endpoint@61 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in30>;
+									};
+								};
+							};
+						};
+						channel@31 {
+							reg = <31>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in31: endpoint@62 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out31: endpoint@63 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in31>;
+									};
+								};
+							};
+						};
+					};
+				};
+
+				gpio@2200000 {
+					/*
+					camera-control-output-high {
+						gpio-hog;
+						output-high;
+						gpios = <CAM0_PWDN 0 CAM1_PWDN 0 CAM2_RST_L 0 CAM3_RST_L 0>;
+						label = "cam0-pwdn", "cam1-pwdn", "cam2-pwdn", "cam3-pwdn";
+					};
+					*/
+					cam-poc-high {
+						gpio-hog;
+						output-high;
+						gpios = <CAM12V_POC 0>;
+						label = "cam12-poc";
+					};
+				};
+
+				i2c@3180000 {
+					status = "okay";
+					clock-frequency = <400000>;
+					tca9546@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "nxp,pca9546";
+						#address-cells = <1>;
+						#size-cells = <0>;
+						skip_mux_detect = "yes";
+						vcc-supply = <&vdd_1v8_ls>;
+						/*vcc-pullup-supply = <&battery_reg>;*/
+						force_bus_start = <CAMERA_I2C_MUX_BUS(0)>;
+						vcc_lp = "vcc";
+						i2c@0 {
+							reg = <0>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m1_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in7>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "0";
+								};
+							};
+							g2m1_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in6>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "1";
+								};
+							};
+							g2m1_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in5>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+							g2m1_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in4>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+
+							/* IR_R */
+							g2m0_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <0>; //0
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in3>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "3";
+								};
+							};
+							/* IR_L */
+							g2m0_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in2>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+							/* RGB */
+							g2m0_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in1>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "1";
+								};
+							};
+							/* Depth */
+							g2m0_0: g2m0@66 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in0>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "0";
+								};
+							};
+
+							dser0: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <0>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>; //camera real address
+								reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+						i2c@1 {
+							status = "okay";
+							reg = <1>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m3_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in15>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "0";
+								};
+							};
+							g2m3_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in14>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "1";
+								};
+							};
+							g2m3_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in13>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "2";
+								};
+							};
+							g2m3_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in12>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "3";
+								};
+							};
+
+							g2m2_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in11>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "3";
+								};
+							};
+							g2m2_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in10>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+							g2m2_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in9>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "1";
+								};
+							};
+							g2m2_0: g2m0@66 {
+								status = "okay";
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in8>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "0";
+								};
+							};
+
+							dser1: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <1>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>;  //camera real address
+								reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+
+						i2c@2 {
+							reg = <2>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m5_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in23>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "0";
+								};
+							};
+							g2m5_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in22>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "1";
+								};
+							};
+							g2m5_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in21>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+							g2m5_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in20>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "3";
+								};
+							};
+							
+							/* IR_R */
+							g2m4_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <4>; //0
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in19>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "3";
+								};
+							};
+							/* IR_L */
+							g2m4_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in18>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+							/* RGB */
+							g2m4_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in17>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "1";
+								};
+							};
+							/* Depth */
+							g2m4_0: g2m0@66 {
+								status = "okay";
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in16>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "0";
+								};
+							};
+
+							dser2: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <2>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>;  //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>; //camera real address
+								reset-gpios = <&gpio CAM2_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+						i2c@3 {
+							status = "okay";
+							reg = <3>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m7_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in31>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "0";
+								};
+							};
+							g2m7_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in30>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "1";
+								};
+							};
+							g2m7_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in29>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "2";
+								};
+							};
+							g2m7_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in28>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1"; 
+									vc_id = "3";
+								};
+							};
+							
+							g2m6_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in27>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "3";
+								};
+							};
+							g2m6_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in26>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "2";
+								};
+							};
+							g2m6_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in25>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "1";
+								};
+							};
+							g2m6_0: g2m0@66 {
+								status = "okay";
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in24>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "1";
+									vc_id = "0";
+								};
+							};
+
+							dser3: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <3>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>;  //camera real address
+								reset-gpios = <&gpio CAM3_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-leopard-overlay.dts b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-leopard-overlay.dts
new file mode 100644
index 000000000..28249ccf6
--- /dev/null
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-leopard-overlay.dts
@@ -0,0 +1,3158 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2024-2029, Orbbec CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h>
+
+#define CAM0_RST_L	TEGRA234_MAIN_GPIO(H, 3)
+#define CAM0_PWDN   TEGRA234_MAIN_GPIO(H, 6)
+
+#define CAM1_RST_L	TEGRA234_MAIN_GPIO(AC, 1)
+#define CAM1_PWDN   TEGRA234_MAIN_GPIO(AC, 0)
+
+#define PWR_EN      TEGRA234_MAIN_GPIO(AC, 7)
+
+#define SYNC_OUT   	TEGRA234_AON_GPIO(BB, 2)
+#define SYNC_IN    	TEGRA234_MAIN_GPIO(AC, 4) //
+
+#define SYNC_SEL   	TEGRA234_MAIN_GPIO(AC, 3)
+
+#define SYNC2_OUT   TEGRA234_AON_GPIO(AA, 7)
+#define SYNC3_OUT   TEGRA234_AON_GPIO(AA, 4)
+
+#define PPS_TRIGGER	TEGRA234_AON_GPIO(CC, 2) //
+
+#define I2C_EN_PIN	TEGRA234_MAIN_GPIO(P, 1)
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson AGX CSI Connector";
+    compatible = JETSON_COMPATIBLE;
+	
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <32>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0x0>;
+						status = "okay";
+						g300_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <0x1>;
+						status = "okay";
+						g300_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <0x2>;
+						status = "okay";
+						g300_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <0x3>;
+						status = "okay";
+						g300_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <0x4>;
+						status = "okay";
+						g300_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <0x5>;
+						status = "okay";
+						g300_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <0x6>;
+						status = "okay";
+						g300_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <0x7>;
+						status = "okay";
+						g300_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <0x8>;
+						status = "okay";
+						g300_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <0x9>;
+						status = "okay";
+						g300_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out9>;
+						};
+					};
+					port@a {
+						reg = <0xa>;
+						status = "okay";
+						g300_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out10>;
+						};
+					};
+					port@b {
+						reg = <0xb>;
+						status = "okay";
+						g300_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out11>;
+						};
+					};
+
+					port@c {
+						reg = <0xc>;
+						status = "okay";
+						g300_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out12>;
+						};
+					};
+
+					port@d {
+						reg = <0xd>;
+						status = "okay";
+						g300_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out13>;
+						};
+					};
+					port@e {
+						reg = <0xe>;
+						status = "okay";
+						g300_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out14>;
+						};
+					};
+					port@f {
+						reg = <0xf>;
+						status = "okay";
+						g300_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out15>;
+						};
+					};
+				#if 1
+					port@10 {
+						reg = <0x10>;
+						status = "okay";
+						g300_vi_in16: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out16>;
+						};
+					};
+					port@11 {
+						reg = <0x11>;
+						status = "okay";
+						g300_vi_in17: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out17>;
+						};
+					};
+					port@12 {
+						reg = <0x12>;
+						status = "okay";
+						g300_vi_in18: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out18>;
+						};
+					};
+					port@13 {
+						reg = <0x13>;
+						status = "okay";
+						g300_vi_in19: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out19>;
+						};
+					};
+
+					port@14 {
+						reg = <0x14>;
+						status = "okay";
+						g300_vi_in20: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out20>;
+						};
+					};
+					port@15 {
+						reg = <0x15>;
+						status = "okay";
+						g300_vi_in21: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out21>;
+						};
+					};
+					port@16 {
+						reg = <0x16>;
+						status = "okay";
+						g300_vi_in22: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out22>;
+						};
+					};
+					port@17 {
+						reg = <0x17>;
+						status = "okay";
+						g300_vi_in23: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out23>;
+						};
+					};
+
+					port@18 {
+						reg = <0x18>;
+						status = "okay";
+						g300_vi_in24: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out24>;
+						};
+					};
+					port@19 {
+						reg = <0x19>;
+						status = "okay";
+						g300_vi_in25: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out25>;
+						};
+					};
+					port@1a {
+						reg = <0x1a>;
+						status = "okay";
+						g300_vi_in26: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out26>;
+						};
+					};
+					port@1b {
+						reg = <0x1b>;
+						status = "okay";
+						g300_vi_in27: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out27>;
+						};
+					};
+
+					port@1c {
+						reg = <0x1c>;
+						status = "okay";
+						g300_vi_in28: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out28>;
+						};
+					};
+					port@1d {
+						reg = <0x1d>;
+						status = "okay";
+						g300_vi_in29: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out29>;
+						};
+					};
+					port@1e {
+						reg = <0x1e>;
+						status = "okay";
+						g300_vi_in30: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out30>;
+						};
+					};
+					port@1f {
+						reg = <0x1f>;
+						status = "okay";
+						g300_vi_in31: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out31>;
+						};
+					};
+				#endif
+				};
+			};
+			tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <16>;
+				max_lane_speed = <20000000>;
+				min_bits_per_pixel = <8>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "g300_0";
+						position = "bottomleft";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@6D";
+						};
+
+						drivernode8 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@6E";
+						};
+
+						drivernode9 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@6F";
+						};
+
+						drivernode10 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@70";
+						};
+
+						drivernode11 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@71";
+						};
+
+						drivernode12 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@72";
+						};
+
+						drivernode13 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@73";
+						};
+
+						drivernode14 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@74";
+						};
+
+						drivernode15 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@75";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "g300_1";
+						position = "bottomright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@6D";
+						};
+
+						drivernode8 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@6E";
+						};
+
+						drivernode9 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@6F";
+						};
+
+						drivernode10 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@70";
+						};
+
+						drivernode11 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@71";
+						};
+
+						drivernode12 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@72";
+						};
+
+						drivernode13 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@73";
+						};
+
+						drivernode14 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@74";
+						};
+
+						drivernode15 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@75";
+						};
+					};
+				};
+			};
+
+			obc_cam_sync {
+				compatible = "orbbec,obc_cam_sync";
+				ranges = <0x0 0x0 0xc6a0000 0x10000>;
+				reg = <0x0 0xc6a0000 0x0 0x18>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				status = "okay";
+				//sync-in-gpios = <&gpio SYNC_IN GPIO_ACTIVE_HIGH>;
+				//sync-out-gpios = <&gpio_aon SYNC_OUT GPIO_ACTIVE_HIGH>;  //Use hrtimer to generate trigger signals
+				//pwms = <&pwm8 0 66666666>; //33333333>; //Use PWM to generate trigger signals, Default PWM mode, if use hrtimer comment out this line
+				/* EDGE_OUT #0 */
+				generator@380 {
+					reg = <0x380 0x80>;
+					freq_hz = <30>;
+					duty_cycle = <10>;
+					offset_ms = <0>;
+					gpio_pinmux = <&gpio_aon TEGRA234_AON_GPIO(BB, 2) GPIO_ACTIVE_LOW>;
+					status = "okay";
+				};	
+			};
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <32>;
+
+						channel@0 {
+							reg = <0x0>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <0x1>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <0x2>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <0x3>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in3>;
+									};
+								};
+							};
+						};
+
+						channel@4 {
+							reg = <0x4>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <0x5>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <0x6>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <0x7>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in7>;
+									};
+								};
+							};
+						};
+
+						channel@8 {
+							reg = <0x8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <0x9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@a {
+							reg = <0xa>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@b {
+							reg = <0xb>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in11>;
+									};
+								};
+							};
+						};
+
+						channel@c {
+							reg = <0xc>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@d {
+							reg = <0xd>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@e {
+							reg = <0xe>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@f {
+							reg = <0xf>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in15>;
+									};
+								};
+							};
+						};
+
+					#if 1
+						channel@10 {
+							reg = <0x10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in16: endpoint@32 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out16: endpoint@33 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in16>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <0x11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in17: endpoint@34 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out17: endpoint@35 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in17>;
+									};
+								};
+							};
+						};
+						channel@12 {
+							reg = <0x12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in18: endpoint@36 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out18: endpoint@37 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in18>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <0x13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in19: endpoint@38 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out19: endpoint@39 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in19>;
+									};
+								};
+							};
+						};
+					
+						channel@14 {
+							reg = <0x14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in20: endpoint@40 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out20: endpoint@41 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in20>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <0x15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in21: endpoint@42 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out21: endpoint@43 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in21>;
+									};
+								};
+							};
+						};
+						channel@16 {
+							reg = <0x16>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in22: endpoint@44 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out22: endpoint@45 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in22>;
+									};
+								};
+							};
+						};
+						channel@17 {
+							reg = <0x17>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in23: endpoint@46 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out23: endpoint@47 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in23>;
+									};
+								};
+							};
+						};
+
+						channel@18 {
+							reg = <0x18>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in24: endpoint@48 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out24: endpoint@49 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in24>;
+									};
+								};
+							};
+						};
+						channel@19 {
+							reg = <0x19>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in25: endpoint@50 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out25: endpoint@51 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in25>;
+									};
+								};
+							};
+						};
+						channel@1a {
+							reg = <0x1a>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in26: endpoint@52 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out26: endpoint@53 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in26>;
+									};
+								};
+							};
+						};
+						channel@1b {
+							reg = <0x1b>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in27: endpoint@54 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out27: endpoint@55 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in27>;
+									};
+								};
+							};
+						};
+
+						channel@1c {
+							reg = <0x1c>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in28: endpoint@56 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out28: endpoint@57 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in28>;
+									};
+								};
+							};
+						};
+						channel@1d {
+							reg = <0x1d>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in29: endpoint@58 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out29: endpoint@59 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in29>;
+									};
+								};
+							};
+						};
+						channel@1e {
+							reg = <0x1e>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in30: endpoint@60 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out30: endpoint@61 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in30>;
+									};
+								};
+							};
+						};
+						channel@1f {
+							reg = <0x1f>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in31: endpoint@62 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out31: endpoint@63 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in31>;
+									};
+								};
+							};
+						};
+					#endif
+					};
+				};
+
+				gpio@2200000 {
+					camera-control-output-low {
+						gpio-hog;
+						output-low;
+						gpios = <CAM0_RST_L 0 CAM0_PWDN 0 CAM1_RST_L 0 CAM1_PWDN 0>;
+						label = "cam0-rst", "cam0-pwdn", "cam1-rst", "cam1-pwdn";
+					};
+
+					camera_power_enable {
+						gpio-hog;
+						output-high;
+						gpios = <PWR_EN 0>;
+						label = "cam-pwr-en";
+					};
+
+					camera_fsync_input {
+						gpio-hog;
+						input;
+						gpios = <SYNC_OUT 0>;
+						label = "fsync-in";
+					};
+
+					camera_fsync_sel {
+						gpio-hog;
+						output-low;
+						gpios = <SYNC_SEL 1>;
+						label = "fsync-sel";
+					};
+				};
+
+				i2c@31e0000 { //i2c-8
+					status = "okay";
+					clock-frequency = <400000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					g2m3_3: g2m3@75 {
+						status = "okay";
+						reg = <0x75>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "d";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in15>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m3_2: g2m2@74 {
+						status = "okay";
+						reg = <0x74>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "d";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in14>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m3_1: g2m1@73 {
+						status = "okay";
+						reg = <0x73>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "d";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in13>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m3_0: g2m0@72 {
+						status = "okay";
+						reg = <0x72>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "d";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in12>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m2_3: g2m3@71 {
+						status = "okay";
+						reg = <0x71>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "c";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in11>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m2_2: g2m2@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "c";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in10>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m2_1: g2m1@6F {
+						status = "okay";
+						reg = <0x6F>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "c";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in9>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m2_0: g2m0@6E {
+						status = "okay";
+						reg = <0x6E>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "c";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in8>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					g2m1_3: g2m3@6D {
+						status = "okay";
+						reg = <0x6D>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "b";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in7>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m1_2: g2m2@6C {
+						status = "okay";
+						reg = <0x6C>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "b";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in6>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m1_1: g2m1@6B {
+						status = "okay";
+						reg = <0x6B>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "b";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in5>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m1_0: g2m0@6A {
+						status = "okay";
+						reg = <0x6A>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "b";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in4>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m0_3: g2m3@69 {
+						status = "okay";
+						reg = <0x69>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "a";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in3>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m0_2: g2m2@68 {
+						status = "okay";
+						reg = <0x68>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "a";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in2>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m0_1: g2m1@67 {
+						status = "okay";
+						reg = <0x67>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "a";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in1>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m0_0: g2m0@66 {
+						status = "okay";
+						reg = <0x66>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "a";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in0>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					dser0: max96712@29 {
+						status = "okay";
+						reg = <0x29>; //0x52>>1
+						compatible = "maxim,obc_max96712";
+						index = <0>;
+						csi-mode = "2x4"; //2*4lane 
+						seri-addr = <0x48>; //serializer start address, LinkA serializer i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						proxy-addr = <0x20>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						real-addr = <0x66>;  //camera real address
+						reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+						fsync_mfp_index = <2>;
+						pps_mfp_index = <9>;
+						vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+					};
+				};
+				i2c@3180000 { // i2c-2
+					status = "okay";
+					clock-frequency = <400000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					g2m7_3: g2m3@75 {
+						status = "okay";
+						reg = <0x75>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "d";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in31>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m7_2: g2m2@74 {
+						status = "okay";
+						reg = <0x74>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "d";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in30>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m7_1: g2m1@73 {
+						status = "okay";
+						reg = <0x73>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "d";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in29>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m7_0: g2m0@72 {
+						status = "okay";
+						reg = <0x72>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "d";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in28>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m6_3: g2m3@71 {
+						status = "okay";
+						reg = <0x71>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "c";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in27>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m6_2: g2m2@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "c";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in26>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m6_1: g2m1@6F {
+						status = "okay";
+						reg = <0x6F>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "c";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in25>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m6_0: g2m0@6E {
+						status = "okay";
+						reg = <0x6E>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "c";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in24>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					g2m5_3: g2m3@6D {
+						status = "okay";
+						reg = <0x6D>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "b";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in23>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m5_2: g2m2@6C {
+						status = "okay";
+						reg = <0x6C>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "b";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in22>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m5_1: g2m1@6B {
+						status = "okay";
+						reg = <0x6B>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "b";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in21>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m5_0: g2m0@6A {
+						status = "okay";
+						reg = <0x6A>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "b";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in20>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m4_3: g2m3@69 {
+						status = "okay";
+						reg = <0x69>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "a";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in19>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m4_2: g2m2@68 {
+						status = "okay";
+						reg = <0x68>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "a";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in18>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m4_1: g2m1@67 {
+						status = "okay";
+						reg = <0x67>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "a";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in17>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m4_0: g2m0@66 {
+						status = "okay";
+						reg = <0x66>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "a";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in16>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					dser1: max96712@29 {
+						status = "okay";
+						reg = <0x29>; //0x52>>1
+						compatible = "maxim,obc_max96712";
+						index = <1>;
+						csi-mode = "2x4"; //2*4lane
+						seri-addr = <0x48>;  //serializer start address, LinkA serializer i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						proxy-addr = <0x20>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						real-addr = <0x66>;	 //camera real address
+						reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+						fsync_mfp_index = <2>;
+						pps_mfp_index = <9>;
+						vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-mic-fg-8g-overlay.dts b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-mic-fg-8g-overlay.dts
new file mode 100644
index 000000000..68a2ce139
--- /dev/null
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-mic-fg-8g-overlay.dts
@@ -0,0 +1,3147 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2024-2029, Orbbec CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h>
+
+#define CAM0_RST_L	TEGRA234_MAIN_GPIO(H, 3)
+#define CAM0_PWDN   TEGRA234_MAIN_GPIO(H, 6)
+
+#define CAM1_RST_L	TEGRA234_MAIN_GPIO(AC, 1)
+#define CAM1_PWDN   TEGRA234_MAIN_GPIO(AC, 0)
+
+#define PWR_EN      TEGRA234_MAIN_GPIO(AC, 7)
+
+#define SYNC_OUT   	TEGRA234_AON_GPIO(BB, 2)
+#define SYNC_IN    	TEGRA234_MAIN_GPIO(AC, 4) //
+
+#define PPS_TRIGGER	TEGRA234_AON_GPIO(CC, 1) //
+
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson AGX CSI Connector";
+    compatible = JETSON_COMPATIBLE;
+	
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <32>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0x0>;
+						status = "okay";
+						g300_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <0x1>;
+						status = "okay";
+						g300_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <0x2>;
+						status = "okay";
+						g300_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <0x3>;
+						status = "okay";
+						g300_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <0x4>;
+						status = "okay";
+						g300_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <0x5>;
+						status = "okay";
+						g300_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <0x6>;
+						status = "okay";
+						g300_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <0x7>;
+						status = "okay";
+						g300_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <0x8>;
+						status = "okay";
+						g300_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <0x9>;
+						status = "okay";
+						g300_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out9>;
+						};
+					};
+					port@a {
+						reg = <0xa>;
+						status = "okay";
+						g300_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out10>;
+						};
+					};
+					port@b {
+						reg = <0xb>;
+						status = "okay";
+						g300_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out11>;
+						};
+					};
+
+					port@c {
+						reg = <0xc>;
+						status = "okay";
+						g300_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out12>;
+						};
+					};
+
+					port@d {
+						reg = <0xd>;
+						status = "okay";
+						g300_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out13>;
+						};
+					};
+					port@e {
+						reg = <0xe>;
+						status = "okay";
+						g300_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out14>;
+						};
+					};
+					port@f {
+						reg = <0xf>;
+						status = "okay";
+						g300_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out15>;
+						};
+					};
+				#if 1
+					port@10 {
+						reg = <0x10>;
+						status = "okay";
+						g300_vi_in16: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out16>;
+						};
+					};
+					port@11 {
+						reg = <0x11>;
+						status = "okay";
+						g300_vi_in17: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out17>;
+						};
+					};
+					port@12 {
+						reg = <0x12>;
+						status = "okay";
+						g300_vi_in18: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out18>;
+						};
+					};
+					port@13 {
+						reg = <0x13>;
+						status = "okay";
+						g300_vi_in19: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out19>;
+						};
+					};
+
+					port@14 {
+						reg = <0x14>;
+						status = "okay";
+						g300_vi_in20: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out20>;
+						};
+					};
+					port@15 {
+						reg = <0x15>;
+						status = "okay";
+						g300_vi_in21: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out21>;
+						};
+					};
+					port@16 {
+						reg = <0x16>;
+						status = "okay";
+						g300_vi_in22: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out22>;
+						};
+					};
+					port@17 {
+						reg = <0x17>;
+						status = "okay";
+						g300_vi_in23: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out23>;
+						};
+					};
+
+					port@18 {
+						reg = <0x18>;
+						status = "okay";
+						g300_vi_in24: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out24>;
+						};
+					};
+					port@19 {
+						reg = <0x19>;
+						status = "okay";
+						g300_vi_in25: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out25>;
+						};
+					};
+					port@1a {
+						reg = <0x1a>;
+						status = "okay";
+						g300_vi_in26: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out26>;
+						};
+					};
+					port@1b {
+						reg = <0x1b>;
+						status = "okay";
+						g300_vi_in27: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out27>;
+						};
+					};
+
+					port@1c {
+						reg = <0x1c>;
+						status = "okay";
+						g300_vi_in28: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out28>;
+						};
+					};
+					port@1d {
+						reg = <0x1d>;
+						status = "okay";
+						g300_vi_in29: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out29>;
+						};
+					};
+					port@1e {
+						reg = <0x1e>;
+						status = "okay";
+						g300_vi_in30: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out30>;
+						};
+					};
+					port@1f {
+						reg = <0x1f>;
+						status = "okay";
+						g300_vi_in31: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out31>;
+						};
+					};
+				#endif
+				};
+			};
+			tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <16>;
+				max_lane_speed = <20000000>;
+				min_bits_per_pixel = <8>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "g300_0";
+						position = "bottomleft";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@6D";
+						};
+
+						drivernode8 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@6E";
+						};
+
+						drivernode9 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@6F";
+						};
+
+						drivernode10 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@70";
+						};
+
+						drivernode11 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@71";
+						};
+
+						drivernode12 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@72";
+						};
+
+						drivernode13 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@73";
+						};
+
+						drivernode14 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@74";
+						};
+
+						drivernode15 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@75";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "g300_1";
+						position = "bottomright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@6D";
+						};
+
+						drivernode8 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@6E";
+						};
+
+						drivernode9 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@6F";
+						};
+
+						drivernode10 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@70";
+						};
+
+						drivernode11 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@71";
+						};
+
+						drivernode12 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@72";
+						};
+
+						drivernode13 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@73";
+						};
+
+						drivernode14 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@74";
+						};
+
+						drivernode15 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@75";
+						};
+					};
+				};
+			};
+
+			obc_cam_sync {
+				compatible = "orbbec,obc_cam_sync";
+				ranges = <0x0 0x0 0xc6a0000 0x10000>;
+				reg = <0x0 0xc6a0000 0x0 0x18>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				status = "okay";
+				//sync-in-gpios = <&gpio SYNC_IN GPIO_ACTIVE_HIGH>;
+				//sync-out-gpios = <&gpio_aon SYNC_OUT GPIO_ACTIVE_HIGH>;  //Use hrtimer to generate trigger signals
+				//pwms = <&pwm8 0 66666666>; //33333333>; //Use PWM to generate trigger signals, Default PWM mode, if use hrtimer comment out this line
+				/* EDGE_OUT #0 */
+				generator@380 {
+					reg = <0x380 0x80>;
+					freq_hz = <30>;
+					duty_cycle = <10>;
+					offset_ms = <0>;
+					gpio_pinmux = <&gpio_aon TEGRA234_AON_GPIO(BB, 2) GPIO_ACTIVE_LOW>;
+					status = "okay";
+				};
+			};
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <32>;
+
+						channel@0 {
+							reg = <0x0>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <0x1>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <0x2>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <0x3>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in3>;
+									};
+								};
+							};
+						};
+
+						channel@4 {
+							reg = <0x4>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <0x5>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <0x6>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <0x7>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in7>;
+									};
+								};
+							};
+						};
+
+						channel@8 {
+							reg = <0x8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <0x9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@a {
+							reg = <0xa>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@b {
+							reg = <0xb>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in11>;
+									};
+								};
+							};
+						};
+
+						channel@c {
+							reg = <0xc>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@d {
+							reg = <0xd>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@e {
+							reg = <0xe>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@f {
+							reg = <0xf>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in15>;
+									};
+								};
+							};
+						};
+
+					#if 1
+						channel@10 {
+							reg = <0x10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in16: endpoint@32 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out16: endpoint@33 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in16>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <0x11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in17: endpoint@34 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out17: endpoint@35 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in17>;
+									};
+								};
+							};
+						};
+						channel@12 {
+							reg = <0x12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in18: endpoint@36 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out18: endpoint@37 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in18>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <0x13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in19: endpoint@38 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out19: endpoint@39 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in19>;
+									};
+								};
+							};
+						};
+					
+						channel@14 {
+							reg = <0x14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in20: endpoint@40 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out20: endpoint@41 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in20>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <0x15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in21: endpoint@42 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out21: endpoint@43 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in21>;
+									};
+								};
+							};
+						};
+						channel@16 {
+							reg = <0x16>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in22: endpoint@44 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out22: endpoint@45 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in22>;
+									};
+								};
+							};
+						};
+						channel@17 {
+							reg = <0x17>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in23: endpoint@46 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out23: endpoint@47 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in23>;
+									};
+								};
+							};
+						};
+
+						channel@18 {
+							reg = <0x18>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in24: endpoint@48 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out24: endpoint@49 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in24>;
+									};
+								};
+							};
+						};
+						channel@19 {
+							reg = <0x19>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in25: endpoint@50 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out25: endpoint@51 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in25>;
+									};
+								};
+							};
+						};
+						channel@1a {
+							reg = <0x1a>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in26: endpoint@52 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out26: endpoint@53 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in26>;
+									};
+								};
+							};
+						};
+						channel@1b {
+							reg = <0x1b>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in27: endpoint@54 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out27: endpoint@55 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in27>;
+									};
+								};
+							};
+						};
+
+						channel@1c {
+							reg = <0x1c>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in28: endpoint@56 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out28: endpoint@57 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in28>;
+									};
+								};
+							};
+						};
+						channel@1d {
+							reg = <0x1d>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in29: endpoint@58 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out29: endpoint@59 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in29>;
+									};
+								};
+							};
+						};
+						channel@1e {
+							reg = <0x1e>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in30: endpoint@60 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out30: endpoint@61 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in30>;
+									};
+								};
+							};
+						};
+						channel@1f {
+							reg = <0x1f>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in31: endpoint@62 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out31: endpoint@63 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in31>;
+									};
+								};
+							};
+						};
+					#endif
+					};
+				};
+
+				gpio@2200000 {
+					camera-control-output-low {
+						gpio-hog;
+						output-low;
+						gpios = <CAM0_RST_L 0 CAM0_PWDN 0 CAM1_RST_L 0 CAM1_PWDN 0>;
+						label = "cam0-rst", "cam0-pwdn", "cam1-rst", "cam1-pwdn";
+					};
+
+					camera_power_enable {
+						gpio-hog;
+						output-high;
+						gpios = <PWR_EN 0>;
+						label = "cam-pwr-en";
+					};
+
+					camera_fsync_input {
+						gpio-hog;
+						input;
+						gpios = <SYNC_OUT 0>;
+						label = "fsync-in";
+					};
+				};
+
+				/* i2c9 */
+				i2c@31e0000 { //8-6a
+					status = "okay";
+					clock-frequency = <400000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					g2m3_3: g2m3@75 {
+						status = "okay";
+						reg = <0x75>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "d";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in15>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m3_2: g2m2@74 {
+						status = "okay";
+						reg = <0x74>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "d";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in14>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m3_1: g2m1@73 {
+						status = "okay";
+						reg = <0x73>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "d";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in13>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m3_0: g2m0@72 {
+						status = "okay";
+						reg = <0x72>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "d";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in12>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m2_3: g2m3@71 {
+						status = "okay";
+						reg = <0x71>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "c";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in11>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m2_2: g2m2@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "c";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in10>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m2_1: g2m1@6F {
+						status = "okay";
+						reg = <0x6F>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "c";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in9>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m2_0: g2m0@6E {
+						status = "okay";
+						reg = <0x6E>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "c";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in8>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					g2m1_3: g2m3@6D {
+						status = "okay";
+						reg = <0x6D>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "b";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in7>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m1_2: g2m2@6C {
+						status = "okay";
+						reg = <0x6C>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "b";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in6>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m1_1: g2m1@6B {
+						status = "okay";
+						reg = <0x6B>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "b";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in5>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m1_0: g2m0@6A {
+						status = "okay";
+						reg = <0x6A>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "b";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in4>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m0_3: g2m3@69 {
+						status = "okay";
+						reg = <0x69>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "a";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in3>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m0_2: g2m2@68 {
+						status = "okay";
+						reg = <0x68>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "a";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in2>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m0_1: g2m1@67 {
+						status = "okay";
+						reg = <0x67>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "a";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in1>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m0_0: g2m0@66 {
+						status = "okay";
+						reg = <0x66>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "a";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in0>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					dser0: max96712@29 {
+						status = "okay";
+						reg = <0x29>; //0x52>>1
+						compatible = "maxim,obc_max96712";
+						index = <0>;
+						csi-mode = "2x4"; //2*4lane 
+						seri-addr = <0x48>; //serializer start address, LinkA serializer i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						proxy-addr = <0x20>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						real-addr = <0x66>; //camera real address
+						reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+						fsync_mfp_index = <2>;
+						pps_mfp_index = <9>;
+						vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+					};
+				};
+
+				i2c@3180000 {
+					status = "okay";
+					clock-frequency = <400000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					g2m7_3: g2m3@75 {
+						status = "okay";
+						reg = <0x75>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "d";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in31>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m7_2: g2m2@74 {
+						status = "okay";
+						reg = <0x74>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "d";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in30>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m7_1: g2m1@73 {
+						status = "okay";
+						reg = <0x73>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "d";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in29>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m7_0: g2m0@72 {
+						status = "okay";
+						reg = <0x72>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "d";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in28>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m6_3: g2m3@71 {
+						status = "okay";
+						reg = <0x71>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "c";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in27>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m6_2: g2m2@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "c";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in26>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m6_1: g2m1@6F {
+						status = "okay";
+						reg = <0x6F>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "c";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in25>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m6_0: g2m0@6E {
+						status = "okay";
+						reg = <0x6E>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "c";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in24>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					g2m5_3: g2m3@6D {
+						status = "okay";
+						reg = <0x6D>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "b";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in23>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "0";
+						};
+					};
+					g2m5_2: g2m2@6C {
+						status = "okay";
+						reg = <0x6C>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "b";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in22>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "1";
+						};
+					};
+					g2m5_1: g2m1@6B {
+						status = "okay";
+						reg = <0x6B>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "b";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in21>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m5_0: g2m0@6A {
+						status = "okay";
+						reg = <0x6A>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "b";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in20>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+
+					g2m4_3: g2m3@69 {
+						status = "okay";
+						reg = <0x69>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "a";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in19>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "3";
+						};
+					};
+					g2m4_2: g2m2@68 {
+						status = "okay";
+						reg = <0x68>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "a";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in18>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1";
+							vc_id = "2";
+						};
+					};
+					g2m4_1: g2m1@67 {
+						status = "okay";
+						reg = <0x67>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "a";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in17>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "1";
+						};
+					};
+					g2m4_0: g2m0@66 {
+						status = "okay";
+						reg = <0x66>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "a";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in16>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "1"; 
+							vc_id = "0";
+						};
+					};
+
+					dser1: max96712@29 {
+						status = "okay";
+						reg = <0x29>; //0x52>>1
+						compatible = "maxim,obc_max96712";
+						index = <1>;
+						csi-mode = "2x4"; //2*4lane
+						seri-addr = <0x48>; //serializer start address, LinkA serializer i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						proxy-addr = <0x20>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						real-addr = <0x66>; //camera real address
+						reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+						fsync_mfp_index = <2>;
+						pps_mfp_index = <9>;
+						vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+					};
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-nomtd-fg96-overlay.dts b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-nomtd-fg96-overlay.dts
new file mode 100644
index 000000000..089e56558
--- /dev/null
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-nomtd-fg96-overlay.dts
@@ -0,0 +1,3213 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2024-2029, ORBBEC CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h> 
+
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(H, 6)  //Pin93 --- UART4_CTS L49/397 - MAX9296_1 PWDN
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(H, 3)  //Pin95 --- UART4_TX L5/394 - MAX9296_2 PWDN
+#define CAM2_PWDN	TEGRA234_MAIN_GPIO(AC, 0) //Pin90 --- GPIO15 F10/486 - MAX9296_3 PWDN
+#define CAM3_PWDN	TEGRA234_MAIN_GPIO(AC, 1) //Pin92 --- GPIO16 E9/487 - MAX9296_4 PWDN
+#define CAM12V_POC	TEGRA234_MAIN_GPIO(AC, 7) //Pin119 --- GPIO12 E10 CAM_VDD_SYS_EN/493 Low enable
+#define CAM_SYNCALL	TEGRA234_AON_GPIO(CC, 0)  //E61/SPI2_CLK CAM_INT1/328 -- MAX9296x4 MFP6
+
+#define SYNC_IN    TEGRA234_AON_GPIO(BB, 0) //(BB, 0)
+
+#define PPS_TRIGGER  TEGRA234_AON_GPIO(BB, 2)//(BB, 2)
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson AGX CSI Connector";
+    compatible = JETSON_COMPATIBLE;
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <32>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						status = "okay";
+						g300_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "okay";
+						g300_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <2>;
+						status = "okay";
+						g300_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <3>;
+						status = "okay";
+						g300_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <4>;
+						status = "okay";
+						g300_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <5>;
+						status = "okay";
+						g300_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <6>;
+						status = "okay";
+						g300_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <7>;
+						status = "okay";
+						g300_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <8>;
+						status = "okay";
+						g300_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <9>;
+						status = "okay";
+						g300_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out9>;
+						};
+					};
+					port@10 {
+						reg = <10>;
+						status = "okay";
+						g300_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out10>;
+						};
+					};
+					port@11 {
+						reg = <11>;
+						status = "okay";
+						g300_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out11>;
+						};
+					};
+
+					port@12 {
+						reg = <12>;
+						status = "okay";
+						g300_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out12>;
+						};
+					};
+					port@13 {
+						reg = <13>;
+						status = "okay";
+						g300_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out13>;
+						};
+					};
+					port@14 {
+						reg = <14>;
+						status = "okay";
+						g300_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out14>;
+						};
+					};
+					port@15 {
+						reg = <15>;
+						status = "okay";
+						g300_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out15>;
+						};
+					};
+
+					port@16 {
+						reg = <16>;
+						status = "okay";
+						g300_vi_in16: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out16>;
+						};
+					};
+					port@17 {
+						reg = <17>;
+						status = "okay";
+						g300_vi_in17: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out17>;
+						};
+					};
+					port@18 {
+						reg = <18>;
+						status = "okay";
+						g300_vi_in18: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out18>;
+						};
+					};
+					port@19 {
+						reg = <19>;
+						status = "okay";
+						g300_vi_in19: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out19>;
+						};
+					};
+
+					port@20 {
+						reg = <20>;
+						status = "okay";
+						g300_vi_in20: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out20>;
+						};
+					};
+					port@21 {
+						reg = <21>;
+						status = "okay";
+						g300_vi_in21: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out21>;
+						};
+					};
+					port@22 {
+						reg = <22>;
+						status = "okay";
+						g300_vi_in22: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out22>;
+						};
+					};
+					port@23 {
+						reg = <23>;
+						status = "okay";
+						g300_vi_in23: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out23>;
+						};
+					};
+
+					port@24 {
+						reg = <24>;
+						status = "okay";
+						g300_vi_in24: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out24>;
+						};
+					};
+					port@25 {
+						reg = <25>;
+						status = "okay";
+						g300_vi_in25: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out25>;
+						};
+					};
+					port@26 {
+						reg = <26>;
+						status = "okay";
+						g300_vi_in26: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out26>;
+						};
+					};
+					port@27 {
+						reg = <27>;
+						status = "okay";
+						g300_vi_in27: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out27>;
+						};
+					};
+
+					port@28 {
+						reg = <28>;
+						status = "okay";
+						g300_vi_in28: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out28>;
+						};
+					};
+					port@29 {
+						reg = <29>;
+						status = "okay";
+						g300_vi_in29: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out29>;
+						};
+					};
+					port@30 {
+						reg = <30>;
+						status = "okay";
+						g300_vi_in30: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out30>;
+						};
+					};
+					port@31 {
+						reg = <31>;
+						status = "okay";
+						g300_vi_in31: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out31>;
+						};
+					};
+				};
+			};
+			tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <16>;
+				max_lane_speed = <1500000>;
+				min_bits_per_pixel = <8>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				max_pixel_rate = <750000>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+				status = "okay";
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "g300_0";
+						position = "topleft";
+						orientation = "1";
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@0/g2m3@6D";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "g300_1";
+						position = "topright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@1/g2m3@6D";
+						};
+					};
+
+					module2 {
+						status = "okay";
+						badge = "g300_2";
+						position = "bottomleft";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@2/g2m3@6D";
+						};
+					};
+					module3 {
+						status = "okay";
+						badge = "g300_3";
+						position = "bottomright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/tca9546@70/i2c@3/g2m3@6D";
+						};
+					};
+				};
+			};
+
+			obc_cam_sync {
+				compatible = "orbbec,obc_cam_sync";
+				ranges = <0x0 0x0 0xc6a0000 0x10000>;
+				reg = <0x0 0xc6a0000 0x0 0x18>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				status = "okay";
+				//sync-in-gpios = <&gpio_aon SYNC_IN GPIO_ACTIVE_HIGH>;
+				//sync-out-gpios = <&gpio_aon CAM_SYNCALL GPIO_ACTIVE_HIGH>;  //Use hrtimer to generate trigger signals
+				pwms = <&pwm8 0 33333333>; //Use PWM to generate trigger signals, Default PWM mode, if use hrtimer comment out this line
+				/* EDGE_OUT #3 */
+				generator@500 {
+					reg = <0x500 0x80>;
+					freq_hz = <30>;
+					duty_cycle = <10>;
+					offset_ms = <0>;
+					status = "okay";
+				};
+			};
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <32>;
+
+						channel@0 {
+							reg = <0>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <1>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <2>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <3>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in3>;
+									};
+								};
+							};
+						};
+
+						channel@4 {
+							reg = <4>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <5>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <6>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <7>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in7>;
+									};
+								};
+							};
+						};
+
+						channel@8 {
+							reg = <8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@10 {
+							reg = <10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in11>;
+									};
+								};
+							};
+						};
+
+						channel@12 {
+							reg = <12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@14 {
+							reg = <14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in15>;
+									};
+								};
+							};
+						};
+
+						channel@16 {
+							reg = <16>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in16: endpoint@32 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out16: endpoint@33 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in16>;
+									};
+								};
+							};
+						};
+						channel@17 {
+							reg = <17>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in17: endpoint@34 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out17: endpoint@35 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in17>;
+									};
+								};
+							};
+						};
+						channel@18 {
+							reg = <18>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in18: endpoint@36 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out18: endpoint@37 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in18>;
+									};
+								};
+							};
+						};
+						channel@19 {
+							reg = <19>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in19: endpoint@38 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out19: endpoint@39 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in19>;
+									};
+								};
+							};
+						};
+
+						channel@20 {
+							reg = <20>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in20: endpoint@40 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out20: endpoint@41 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in20>;
+									};
+								};
+							};
+						};
+						channel@21 {
+							reg = <21>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in21: endpoint@42 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out21: endpoint@43 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in21>;
+									};
+								};
+							};
+						};
+						channel@22 {
+							reg = <22>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in22: endpoint@44 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out22: endpoint@45 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in22>;
+									};
+								};
+							};
+						};
+						channel@23 {
+							reg = <23>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in23: endpoint@46 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out23: endpoint@47 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in23>;
+									};
+								};
+							};
+						};
+
+						channel@24 {
+							reg = <24>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in24: endpoint@48 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out24: endpoint@49 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in24>;
+									};
+								};
+							};
+						};
+						channel@25 {
+							reg = <25>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in25: endpoint@50 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out25: endpoint@51 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in25>;
+									};
+								};
+							};
+						};
+						channel@26 {
+							reg = <26>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in26: endpoint@52 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out26: endpoint@53 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in26>;
+									};
+								};
+							};
+						};
+						channel@27 {
+							reg = <27>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in27: endpoint@54 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out27: endpoint@55 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in27>;
+									};
+								};
+							};
+						};
+
+						channel@28 {
+							reg = <28>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in28: endpoint@56 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out28: endpoint@57 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in28>;
+									};
+								};
+							};
+						};
+						channel@29 {
+							reg = <29>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in29: endpoint@58 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out29: endpoint@59 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in29>;
+									};
+								};
+							};
+						};
+						channel@30 {
+							reg = <30>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in30: endpoint@60 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out30: endpoint@61 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in30>;
+									};
+								};
+							};
+						};
+						channel@31 {
+							reg = <31>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in31: endpoint@62 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out31: endpoint@63 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in31>;
+									};
+								};
+							};
+						};
+					};
+				};
+
+				gpio@2200000 {
+					/*
+					camera-control-output-high {
+						gpio-hog;
+						output-high;
+						gpios = <CAM0_PWDN 0 CAM1_PWDN 0 CAM2_RST_L 0 CAM3_RST_L 0>;
+						label = "cam0-pwdn", "cam1-pwdn", "cam2-pwdn", "cam3-pwdn";
+					};
+					*/
+					cam-poc-high {
+						gpio-hog;
+						output-high;
+						gpios = <CAM12V_POC 0>;
+						label = "cam12-poc";
+					};
+				};
+
+				i2c@3180000 {
+					status = "okay";
+					clock-frequency = <400000>;
+					tca9546@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "nxp,pca9546";
+						#address-cells = <1>;
+						#size-cells = <0>;
+						skip_mux_detect = "yes";
+						vcc-supply = <&vdd_1v8_ls>;
+						/*vcc-pullup-supply = <&battery_reg>;*/
+						force_bus_start = <CAMERA_I2C_MUX_BUS(0)>;
+						vcc_lp = "vcc";
+						i2c@0 {
+							reg = <0>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m1_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in7>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+							};
+							g2m1_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in6>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+							};
+							g2m1_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in5>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+							g2m1_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <1>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m1_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in4>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+
+							/* IR_R */
+							g2m0_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <0>; //0
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in3>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+							};
+							/* IR_L */
+							g2m0_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in2>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+							/* RGB */
+							g2m0_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in1>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "1";
+								};
+							};
+							/* Depth */
+							g2m0_0: g2m0@66 {
+								status = "okay";
+								def-addr = <0x66>;
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <0>;
+								nvidia,gmsl-dser-device = <&dser0>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m0_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <0>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in0>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "0";
+								};
+							};
+
+							dser0: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <0>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>; //camera real address
+								reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+						i2c@1 {
+							status = "okay";
+							reg = <1>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m3_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in15>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+							};
+							g2m3_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in14>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+							};
+							g2m3_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in13>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "2";
+								};
+							};
+							g2m3_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <3>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m3_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in12>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "3";
+								};
+							};
+
+							g2m2_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in11>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+							};
+							g2m2_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in10>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+							g2m2_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in9>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+							};
+							g2m2_0: g2m0@66 {
+								status = "okay";
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <2>;
+								nvidia,gmsl-dser-device = <&dser1>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m2_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <2>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in8>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+							};
+
+							dser1: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <1>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>;  //camera real address
+								reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+
+						i2c@2 {
+							reg = <2>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m5_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in23>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+							};
+							g2m5_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in22>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+							};
+							g2m5_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in21>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+							g2m5_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <5>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m5_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in20>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+							};
+							
+							/* IR_R */
+							g2m4_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <4>; //0
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in19>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+							};
+							/* IR_L */
+							g2m4_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in18>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+							/* RGB */
+							g2m4_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in17>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "1";
+								};
+							};
+							/* Depth */
+							g2m4_0: g2m0@66 {
+								status = "okay";
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <4>;
+								nvidia,gmsl-dser-device = <&dser2>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m4_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <4>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in16>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_a";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "0";
+								};
+							};
+
+							dser2: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <2>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>;  //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>; //camera real address
+								reset-gpios = <&gpio CAM2_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+						i2c@3 {
+							status = "okay";
+							reg = <3>; // line 4 of the I2C switch
+							i2c-mux,deselect-on-exit;
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							g2m7_3: g2m3@6D {
+								status = "okay";
+								reg = <0x6D>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "b";
+								st-vc = <3>;
+								vc-id = <0>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_3_out: endpoint {
+											vc-id = <0>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in31>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+							};
+							g2m7_2: g2m2@6C {
+								status = "okay";
+								reg = <0x6C>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "b";
+								st-vc = <2>;
+								vc-id = <1>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_2_out: endpoint {
+											vc-id = <1>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in30>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+							};
+							g2m7_1: g2m1@6B {
+								status = "okay";
+								reg = <0x6B>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "b";
+								st-vc = <1>;
+								vc-id = <2>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_1_out: endpoint {
+											vc-id = <2>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in29>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "2";
+								};
+							};
+							g2m7_0: g2m0@6A {
+								status = "okay";
+								reg = <0x6A>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "b";
+								st-vc = <0>;
+								vc-id = <3>;
+								orbbec_cam_num = <7>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m7_0_out: endpoint {
+											vc-id = <3>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in28>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0"; 
+									vc_id = "3";
+								};
+							};
+							
+							g2m6_3: g2m3@69 {
+								status = "okay";
+								reg = <0x69>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_R";
+								dser-link-port = "a";
+								st-vc = <3>;
+								vc-id = <3>;
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_3_out: endpoint {
+											vc-id = <3>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in27>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "3";
+								};
+							};
+							g2m6_2: g2m2@68 {
+								status = "okay";
+								reg = <0x68>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "IR_L";
+								dser-link-port = "a";
+								st-vc = <2>;
+								vc-id = <2>;
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_2_out: endpoint {
+											vc-id = <2>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in26>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "grey_y8";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "8";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+									serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "2";
+								};
+							};
+							g2m6_1: g2m1@67 {
+								status = "okay";
+								reg = <0x67>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "RGB";
+								dser-link-port = "a";
+								st-vc = <1>;
+								vc-id = <1>;
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_1_out: endpoint {
+											vc-id = <1>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in25>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "1";
+								};
+							};
+							g2m6_0: g2m0@66 {
+								status = "okay";
+								reg = <0x66>;
+								compatible = "orbbec,g300";
+								use_sensor_mode_id = "true";
+								vcc-supply = <&vdd_1v8_ls>;
+								cam-type = "Depth";
+								dser-link-port = "a";
+								st-vc = <0>;   				/**< Default sensor virtual channel. */
+								vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+								orbbec_cam_num = <6>;
+								nvidia,gmsl-dser-device = <&dser3>;
+								pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+								ports {
+									#address-cells = <1>;
+									#size-cells = <0>;
+
+									port@0 {
+										reg = <0>;
+										g2m6_0_out: endpoint {
+											vc-id = <0>;
+											port-index = <6>;
+											bus-width = <4>;
+											remote-endpoint = <&g300_csi_in24>;
+										};
+									};
+								};
+								mode0 {
+									pixel_t = "yuv_yvyu16";
+									num_lanes = "4";
+									csi_pixel_bit_depth = "16";
+									active_w = "1280";
+									active_h = "720";
+									tegra_sinterface = "serial_c";
+									mclk_khz = "24000";
+									pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+									serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000 
+									discontinuous_clk = "no";
+									dpcm_enable = "false";
+									cil_settletime = "0";
+									line_length = "1280";
+									mclk_multiplier = "15.625";
+									embedded_metadata_height = "0";
+									vc_id = "0";
+								};
+							};
+
+							dser3: max9296@48 {
+								status = "okay";
+								reg = <0x48>; //0x90>>1
+								compatible = "maxim,obc_max9296";
+								index = <3>;
+								csi-mode = "2x4"; //2*4lane
+								seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+								proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+								real-addr = <0x66>;  //camera real address
+								reset-gpios = <&gpio CAM3_PWDN GPIO_ACTIVE_HIGH>;
+								fsync_mfp_index = <6>;
+								pps_mfp_index = <9>;
+								is-fg96-8ch-v2.1;
+								vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-nomtd-leopard-overlay.dts b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-nomtd-leopard-overlay.dts
new file mode 100644
index 000000000..42346406c
--- /dev/null
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3737-camera-g300-nomtd-leopard-overlay.dts
@@ -0,0 +1,3158 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2024-2029, Orbbec CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3737-0000+p3701-0000.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h>
+
+#define CAM0_RST_L	TEGRA234_MAIN_GPIO(H, 3)
+#define CAM0_PWDN   TEGRA234_MAIN_GPIO(H, 6)
+
+#define CAM1_RST_L	TEGRA234_MAIN_GPIO(AC, 1)
+#define CAM1_PWDN   TEGRA234_MAIN_GPIO(AC, 0)
+
+#define PWR_EN      TEGRA234_MAIN_GPIO(AC, 7)
+
+#define SYNC_OUT   	TEGRA234_AON_GPIO(BB, 2)
+#define SYNC_IN    	TEGRA234_MAIN_GPIO(AC, 4) //
+
+#define SYNC_SEL   	TEGRA234_MAIN_GPIO(AC, 3)
+
+#define SYNC2_OUT   TEGRA234_AON_GPIO(AA, 7)
+#define SYNC3_OUT   TEGRA234_AON_GPIO(AA, 4)
+
+#define PPS_TRIGGER	TEGRA234_AON_GPIO(CC, 2) //
+
+#define I2C_EN_PIN	TEGRA234_MAIN_GPIO(P, 1)
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson AGX CSI Connector";
+    compatible = JETSON_COMPATIBLE;
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <32>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0x0>;
+						status = "okay";
+						g300_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <0x1>;
+						status = "okay";
+						g300_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <0x2>;
+						status = "okay";
+						g300_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <0x3>;
+						status = "okay";
+						g300_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <0x4>;
+						status = "okay";
+						g300_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <0x5>;
+						status = "okay";
+						g300_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <0x6>;
+						status = "okay";
+						g300_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <0x7>;
+						status = "okay";
+						g300_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <0x8>;
+						status = "okay";
+						g300_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <0x9>;
+						status = "okay";
+						g300_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out9>;
+						};
+					};
+					port@a {
+						reg = <0xa>;
+						status = "okay";
+						g300_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out10>;
+						};
+					};
+					port@b {
+						reg = <0xb>;
+						status = "okay";
+						g300_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out11>;
+						};
+					};
+
+					port@c {
+						reg = <0xc>;
+						status = "okay";
+						g300_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out12>;
+						};
+					};
+
+					port@d {
+						reg = <0xd>;
+						status = "okay";
+						g300_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out13>;
+						};
+					};
+					port@e {
+						reg = <0xe>;
+						status = "okay";
+						g300_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out14>;
+						};
+					};
+					port@f {
+						reg = <0xf>;
+						status = "okay";
+						g300_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out15>;
+						};
+					};
+				#if 1
+					port@10 {
+						reg = <0x10>;
+						status = "okay";
+						g300_vi_in16: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out16>;
+						};
+					};
+					port@11 {
+						reg = <0x11>;
+						status = "okay";
+						g300_vi_in17: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out17>;
+						};
+					};
+					port@12 {
+						reg = <0x12>;
+						status = "okay";
+						g300_vi_in18: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out18>;
+						};
+					};
+					port@13 {
+						reg = <0x13>;
+						status = "okay";
+						g300_vi_in19: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out19>;
+						};
+					};
+
+					port@14 {
+						reg = <0x14>;
+						status = "okay";
+						g300_vi_in20: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out20>;
+						};
+					};
+					port@15 {
+						reg = <0x15>;
+						status = "okay";
+						g300_vi_in21: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out21>;
+						};
+					};
+					port@16 {
+						reg = <0x16>;
+						status = "okay";
+						g300_vi_in22: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out22>;
+						};
+					};
+					port@17 {
+						reg = <0x17>;
+						status = "okay";
+						g300_vi_in23: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <4>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out23>;
+						};
+					};
+
+					port@18 {
+						reg = <0x18>;
+						status = "okay";
+						g300_vi_in24: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out24>;
+						};
+					};
+					port@19 {
+						reg = <0x19>;
+						status = "okay";
+						g300_vi_in25: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out25>;
+						};
+					};
+					port@1a {
+						reg = <0x1a>;
+						status = "okay";
+						g300_vi_in26: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out26>;
+						};
+					};
+					port@1b {
+						reg = <0x1b>;
+						status = "okay";
+						g300_vi_in27: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out27>;
+						};
+					};
+
+					port@1c {
+						reg = <0x1c>;
+						status = "okay";
+						g300_vi_in28: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out28>;
+						};
+					};
+					port@1d {
+						reg = <0x1d>;
+						status = "okay";
+						g300_vi_in29: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out29>;
+						};
+					};
+					port@1e {
+						reg = <0x1e>;
+						status = "okay";
+						g300_vi_in30: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out30>;
+						};
+					};
+					port@1f {
+						reg = <0x1f>;
+						status = "okay";
+						g300_vi_in31: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <5>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out31>;
+						};
+					};
+				#endif
+				};
+			};
+			tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <16>;
+				max_lane_speed = <20000000>;
+				min_bits_per_pixel = <8>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "g300_0";
+						position = "bottomleft";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@6D";
+						};
+
+						drivernode8 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@6E";
+						};
+
+						drivernode9 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@6F";
+						};
+
+						drivernode10 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@70";
+						};
+
+						drivernode11 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@71";
+						};
+
+						drivernode12 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m0@72";
+						};
+
+						drivernode13 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m1@73";
+						};
+
+						drivernode14 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m2@74";
+						};
+
+						drivernode15 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@31e0000/g2m3@75";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "g300_1";
+						position = "bottomright";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@69";
+						};
+
+						drivernode4 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@6A";
+						};
+
+						drivernode5 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@6B";
+						};
+
+						drivernode6 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@6C";
+						};
+
+						drivernode7 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@6D";
+						};
+
+						drivernode8 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@6E";
+						};
+
+						drivernode9 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@6F";
+						};
+
+						drivernode10 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@70";
+						};
+
+						drivernode11 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@71";
+						};
+
+						drivernode12 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m0@72";
+						};
+
+						drivernode13 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m1@73";
+						};
+
+						drivernode14 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m2@74";
+						};
+
+						drivernode15 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							sysfs-device-tree = "/sys/firmware/devicetree/base/bus@0/i2c@3180000/g2m3@75";
+						};
+					};
+				};
+			};
+
+			obc_cam_sync {
+				compatible = "orbbec,obc_cam_sync";
+				ranges = <0x0 0x0 0xc6a0000 0x10000>;
+				reg = <0x0 0xc6a0000 0x0 0x18>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				status = "okay";
+				//sync-in-gpios = <&gpio SYNC_IN GPIO_ACTIVE_HIGH>;
+				//sync-out-gpios = <&gpio_aon SYNC_OUT GPIO_ACTIVE_HIGH>;  //Use hrtimer to generate trigger signals
+				//pwms = <&pwm8 0 66666666>; //33333333>; //Use PWM to generate trigger signals, Default PWM mode, if use hrtimer comment out this line
+				/* EDGE_OUT #0 */
+				generator@380 {
+					reg = <0x380 0x80>;
+					freq_hz = <30>;
+					duty_cycle = <10>;
+					offset_ms = <0>;
+					gpio_pinmux = <&gpio_aon TEGRA234_AON_GPIO(BB, 2) GPIO_ACTIVE_LOW>;
+					status = "okay";
+				};
+			};
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <32>;
+
+						channel@0 {
+							reg = <0x0>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <0x1>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <0x2>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <0x3>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in3>;
+									};
+								};
+							};
+						};
+
+						channel@4 {
+							reg = <0x4>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <0x5>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <0x6>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <0x7>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in7>;
+									};
+								};
+							};
+						};
+
+						channel@8 {
+							reg = <0x8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <0x9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@a {
+							reg = <0xa>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@b {
+							reg = <0xb>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in11>;
+									};
+								};
+							};
+						};
+
+						channel@c {
+							reg = <0xc>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@d {
+							reg = <0xd>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@e {
+							reg = <0xe>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@f {
+							reg = <0xf>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in15>;
+									};
+								};
+							};
+						};
+
+					#if 1
+						channel@10 {
+							reg = <0x10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in16: endpoint@32 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out16: endpoint@33 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in16>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <0x11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in17: endpoint@34 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out17: endpoint@35 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in17>;
+									};
+								};
+							};
+						};
+						channel@12 {
+							reg = <0x12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in18: endpoint@36 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out18: endpoint@37 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in18>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <0x13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in19: endpoint@38 {
+										status = "okay";
+										port-index = <4>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g2m4_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out19: endpoint@39 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in19>;
+									};
+								};
+							};
+						};
+
+						channel@14 {
+							reg = <0x14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in20: endpoint@40 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out20: endpoint@41 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in20>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <0x15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in21: endpoint@42 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out21: endpoint@43 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in21>;
+									};
+								};
+							};
+						};
+						channel@16 {
+							reg = <0x16>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in22: endpoint@44 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out22: endpoint@45 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in22>;
+									};
+								};
+							};
+						};
+						channel@17 {
+							reg = <0x17>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in23: endpoint@46 {
+										status = "okay";
+										port-index = <4>; //1
+										bus-width = <4>;
+										remote-endpoint = <&g2m5_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out23: endpoint@47 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in23>;
+									};
+								};
+							};
+						};
+
+						channel@18 {
+							reg = <0x18>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in24: endpoint@48 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out24: endpoint@49 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in24>;
+									};
+								};
+							};
+						};
+						channel@19 {
+							reg = <0x19>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in25: endpoint@50 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out25: endpoint@51 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in25>;
+									};
+								};
+							};
+						};
+						channel@1a {
+							reg = <0x1a>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in26: endpoint@52 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out26: endpoint@53 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in26>;
+									};
+								};
+							};
+						};
+						channel@1b {
+							reg = <0x1b>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in27: endpoint@54 {
+										status = "okay";
+										port-index = <6>; //2
+										bus-width = <4>;
+										remote-endpoint = <&g2m6_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out27: endpoint@55 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in27>;
+									};
+								};
+							};
+						};
+
+						channel@1c {
+							reg = <0x1c>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in28: endpoint@56 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out28: endpoint@57 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in28>;
+									};
+								};
+							};
+						};
+						channel@1d {
+							reg = <0x1d>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in29: endpoint@58 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out29: endpoint@59 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in29>;
+									};
+								};
+							};
+						};
+						channel@1e {
+							reg = <0x1e>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in30: endpoint@60 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out30: endpoint@61 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in30>;
+									};
+								};
+							};
+						};
+						channel@1f {
+							reg = <0x1f>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in31: endpoint@62 {
+										status = "okay";
+										port-index = <6>; //3
+										bus-width = <4>;
+										remote-endpoint = <&g2m7_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out31: endpoint@63 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in31>;
+									};
+								};
+							};
+						};
+					#endif
+					};
+				};
+
+				gpio@2200000 {
+					camera-control-output-low {
+						gpio-hog;
+						output-low;
+						gpios = <CAM0_RST_L 0 CAM0_PWDN 0 CAM1_RST_L 0 CAM1_PWDN 0>;
+						label = "cam0-rst", "cam0-pwdn", "cam1-rst", "cam1-pwdn";
+					};
+
+					camera_power_enable {
+						gpio-hog;
+						output-high;
+						gpios = <PWR_EN 0>;
+						label = "cam-pwr-en";
+					};
+
+					camera_fsync_input {
+						gpio-hog;
+						input;
+						gpios = <SYNC_OUT 0>;
+						label = "fsync-in";
+					};
+
+					camera_fsync_sel {
+						gpio-hog;
+						output-low;
+						gpios = <SYNC_SEL 1>;
+						label = "fsync-sel";
+					};
+				};
+
+				i2c@31e0000 { //i2c-8
+					status = "okay";
+					clock-frequency = <400000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					g2m3_3: g2m3@75 {
+						status = "okay";
+						reg = <0x75>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "d";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in15>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+					g2m3_2: g2m2@74 {
+						status = "okay";
+						reg = <0x74>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "d";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in14>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m3_1: g2m1@73 {
+						status = "okay";
+						reg = <0x73>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "d";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in13>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m3_0: g2m0@72 {
+						status = "okay";
+						reg = <0x72>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "d";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <3>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m3_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <2>; //3
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in12>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+
+					g2m2_3: g2m3@71 {
+						status = "okay";
+						reg = <0x71>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "c";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in11>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+					g2m2_2: g2m2@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "c";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in10>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m2_1: g2m1@6F {
+						status = "okay";
+						reg = <0x6F>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "c";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in9>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m2_0: g2m0@6E {
+						status = "okay";
+						reg = <0x6E>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "c";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <2>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m2_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <2>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in8>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_c";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+
+					g2m1_3: g2m3@6D {
+						status = "okay";
+						reg = <0x6D>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "b";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in7>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+					g2m1_2: g2m2@6C {
+						status = "okay";
+						reg = <0x6C>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "b";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in6>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m1_1: g2m1@6B {
+						status = "okay";
+						reg = <0x6B>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "b";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in5>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m1_0: g2m0@6A {
+						status = "okay";
+						reg = <0x6A>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "b";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <1>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m1_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <0>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in4>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+
+					g2m0_3: g2m3@69 {
+						status = "okay";
+						reg = <0x69>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "a";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in3>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+					g2m0_2: g2m2@68 {
+						status = "okay";
+						reg = <0x68>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "a";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in2>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m0_1: g2m1@67 {
+						status = "okay";
+						reg = <0x67>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "a";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in1>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m0_0: g2m0@66 {
+						status = "okay";
+						reg = <0x66>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "a";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <0>;
+						nvidia,gmsl-dser-device = <&dser0>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m0_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <0>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in0>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_a";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+
+					dser0: max96712@29 {
+						status = "okay";
+						reg = <0x29>; //0x52>>1
+						compatible = "maxim,obc_max96712";
+						index = <0>;
+						csi-mode = "2x4"; //2*4lane
+						seri-addr = <0x48>; //serializer start address, LinkA serializer i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						proxy-addr = <0x20>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						real-addr = <0x66>;  //camera real address
+						reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+						fsync_mfp_index = <2>;
+						pps_mfp_index = <9>;
+						vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+					};
+				};
+				i2c@3180000 { // i2c-2
+					status = "okay";
+					clock-frequency = <400000>;
+
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					g2m7_3: g2m3@75 {
+						status = "okay";
+						reg = <0x75>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "d";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in31>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+					g2m7_2: g2m2@74 {
+						status = "okay";
+						reg = <0x74>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "d";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in30>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m7_1: g2m1@73 {
+						status = "okay";
+						reg = <0x73>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "d";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in29>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m7_0: g2m0@72 {
+						status = "okay";
+						reg = <0x72>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "d";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <7>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m7_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <6>;
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in28>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+
+					g2m6_3: g2m3@71 {
+						status = "okay";
+						reg = <0x71>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "c";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in27>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+					g2m6_2: g2m2@70 {
+						status = "okay";
+						reg = <0x70>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "c";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in26>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m6_1: g2m1@6F {
+						status = "okay";
+						reg = <0x6F>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "c";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in25>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m6_0: g2m0@6E {
+						status = "okay";
+						reg = <0x6E>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "c";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <6>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m6_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <6>; //2
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in24>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_g";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+
+					g2m5_3: g2m3@6D {
+						status = "okay";
+						reg = <0x6D>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "b";
+						st-vc = <3>;
+						vc-id = <0>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_3_out: endpoint {
+									vc-id = <0>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in23>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+					g2m5_2: g2m2@6C {
+						status = "okay";
+						reg = <0x6C>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "b";
+						st-vc = <2>;
+						vc-id = <1>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_2_out: endpoint {
+									vc-id = <1>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in22>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m5_1: g2m1@6B {
+						status = "okay";
+						reg = <0x6B>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "b";
+						st-vc = <1>;
+						vc-id = <2>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_1_out: endpoint {
+									vc-id = <2>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in21>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m5_0: g2m0@6A {
+						status = "okay";
+						reg = <0x6A>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "b";
+						st-vc = <0>;
+						vc-id = <3>;
+						orbbec_cam_num = <5>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m5_0_out: endpoint {
+									vc-id = <3>;
+									port-index = <4>; //1
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in20>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+
+					g2m4_3: g2m3@69 {
+						status = "okay";
+						reg = <0x69>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_R";
+						dser-link-port = "a";
+						st-vc = <3>;
+						vc-id = <3>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_3_out: endpoint {
+									vc-id = <3>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in19>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "3";
+						};
+					};
+					g2m4_2: g2m2@68 {
+						status = "okay";
+						reg = <0x68>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "IR_L";
+						dser-link-port = "a";
+						st-vc = <2>;
+						vc-id = <2>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_2_out: endpoint {
+									vc-id = <2>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in18>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "grey_y8";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "8";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "2";
+						};
+					};
+					g2m4_1: g2m1@67 {
+						status = "okay";
+						reg = <0x67>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "RGB";
+						dser-link-port = "a";
+						st-vc = <1>;
+						vc-id = <1>;
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_1_out: endpoint {
+									vc-id = <1>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in17>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "1";
+						};
+					};
+					g2m4_0: g2m0@66 {
+						status = "okay";
+						reg = <0x66>;
+						compatible = "orbbec,g300";
+						use_sensor_mode_id = "true";
+						vcc-supply = <&vdd_1v8_ls>;
+						cam-type = "Depth";
+						dser-link-port = "a";
+						st-vc = <0>;   				/**< Default sensor virtual channel. */
+						vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+						orbbec_cam_num = <4>;
+						nvidia,gmsl-dser-device = <&dser1>;
+						pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+
+							port@0 {
+								reg = <0>;
+								g2m4_0_out: endpoint {
+									vc-id = <0>;
+									port-index = <4>; //0
+									bus-width = <4>;
+									remote-endpoint = <&g300_csi_in16>;
+								};
+							};
+						};
+						mode0 {
+							pixel_t = "yuv_yvyu16";
+							num_lanes = "4";
+							csi_pixel_bit_depth = "16";
+							active_w = "1280";
+							active_h = "720";
+							tegra_sinterface = "serial_e";
+							mclk_khz = "24000";
+							pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+							discontinuous_clk = "no";
+							dpcm_enable = "false";
+							cil_settletime = "0";
+							line_length = "1280";
+							mclk_multiplier = "15.625";
+							embedded_metadata_height = "0";
+							vc_id = "0";
+						};
+					};
+
+					dser1: max96712@29 {
+						status = "okay";
+						reg = <0x29>; //0x52>>1
+						compatible = "maxim,obc_max96712";
+						index = <1>;
+						csi-mode = "2x4"; //2*4lane
+						seri-addr = <0x48>;  //serializer start address, LinkA serializer i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						proxy-addr = <0x20>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+						real-addr = <0x66>;	 //camera real address
+						reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+						fsync_mfp_index = <2>;
+						pps_mfp_index = <9>;
+						vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+					};
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-g300-fg96-overlay.dts b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-g300-fg96-overlay.dts
new file mode 100644
index 000000000..70fdd2226
--- /dev/null
+++ b/Linux_for_Tegra/source/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-g300-fg96-overlay.dts
@@ -0,0 +1,1679 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2024-2029, ORBBEC CORPORATION.  All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+#include <dt-bindings/tegra234-p3767-0000-common.h>
+#include <dt-bindings/pinctrl/pinctrl-tegra.h> 
+
+#define CAM0_PWDN TEGRA234_MAIN_GPIO(H, 6) //0x3e
+#define CAM1_PWDN TEGRA234_MAIN_GPIO(AC, 0) //0x3b
+
+#define SYNC_OUT   CAM1_PWDN
+#define SYNC_IN    TEGRA234_AON_GPIO(BB, 0) //(BB, 0)
+//#define PPS_TRIGGER  TEGRA234_AON_GPIO(BB, 2)//(BB, 2)
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+#define CAM_I2C_MUX  TEGRA234_AON_GPIO(CC, 3)
+
+/* camera control gpio definitions */
+/ {
+	overlay-name = "Jetson Orbbec Camera G335Lg";
+    jetson-header-name = "Jetson 40pin Header";
+    compatible = JETSON_COMPATIBLE_P3768;
+
+	fragment@0 {
+		target = <&pinmux>;
+		__overlay__ {
+			pinctrl-names = "default";
+			pinctrl-0 = <&jetson_io_pinmux>;
+			jetson_io_pinmux: exp-header-pinmux {
+				hdr40-pin15 {
+					nvidia,pins = "soc_gpio39_pn1";
+					nvidia,function = "gp";
+					nvidia,pin-group = "pwm1";
+					nvidia,tristate = <TEGRA_PIN_DISABLE>;
+					nvidia,enable-input = <TEGRA_PIN_DISABLE>;
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				num-channels = <16>;
+				ports {
+					status = "okay";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						status = "disable";
+						g300_vi_in0: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out0>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "disable";
+						g300_vi_in1: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out1>;
+						};
+					};
+					port@2 {
+						reg = <2>;
+						status = "disable";
+						g300_vi_in2: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out2>;
+						};
+					};
+					port@3 {
+						reg = <3>;
+						status = "disable";
+						g300_vi_in3: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //0
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out3>;
+						};
+					};
+
+					port@4 {
+						reg = <4>;
+						status = "disable";
+						g300_vi_in4: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out4>;
+						};
+					};
+					port@5 {
+						reg = <5>;
+						status = "disable";
+						g300_vi_in5: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out5>;
+						};
+					};
+					port@6 {
+						reg = <6>;
+						status = "disable";
+						g300_vi_in6: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out6>;
+						};
+					};
+					port@7 {
+						reg = <7>;
+						status = "disable";
+						g300_vi_in7: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <0>; //1
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out7>;
+						};
+					};
+
+					port@8 {
+						reg = <8>;
+						status = "okay";
+						g300_vi_in8: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out8>;
+						};
+					};
+					port@9 {
+						reg = <9>;
+						status = "okay";
+						g300_vi_in9: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out9>;
+						};
+					};
+					port@10 {
+						reg = <10>;
+						status = "okay";
+						g300_vi_in10: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out10>;
+						};
+					};
+					port@11 {
+						reg = <11>;
+						status = "okay";
+						g300_vi_in11: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //2
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out11>;
+						};
+					};
+
+					port@12 {
+						reg = <12>;
+						status = "okay";
+						g300_vi_in12: endpoint {
+							status = "okay";
+							vc-id = <3>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out12>;
+						};
+					};
+					port@13 {
+						reg = <13>;
+						status = "okay";
+						g300_vi_in13: endpoint {
+							status = "okay";
+							vc-id = <2>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out13>;
+						};
+					};
+					port@14 {
+						reg = <14>;
+						status = "okay";
+						g300_vi_in14: endpoint {
+							status = "okay";
+							vc-id = <1>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out14>;
+						};
+					};
+					port@15 {
+						reg = <15>;
+						status = "okay";
+						g300_vi_in15: endpoint {
+							status = "okay";
+							vc-id = <0>;
+							port-index = <2>; //3
+							bus-width = <4>;
+							remote-endpoint = <&g300_csi_out15>;
+						};
+					};
+				};
+			};
+			
+			obc_cam_sync {
+				compatible = "orbbec,obc_cam_sync";
+				ranges = <0x0 0x0 0xc6a0000 0x10000>;
+				reg = <0x0 0xc6a0000 0x0 0x18>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				status = "okay";
+				//sync-in-gpios = <&gpio_aon SYNC_IN GPIO_ACTIVE_HIGH>;
+				//sync-out-gpios = <&gpio_aon CAM_SYNCALL GPIO_ACTIVE_HIGH>;  //Use hrtimer to generate trigger signals
+				pwms = <&pwm8 0 33333333>; //Use PWM to generate trigger signals, Default PWM mode, if use hrtimer comment out this line
+				/* EDGE_OUT #0 */
+				generator@380 {
+					reg = <0x380 0x80>;
+					freq_hz = <30>;
+					duty_cycle = <10>;
+					offset_ms = <0>;
+					gpio_pinmux = <&gpio_aon TEGRA234_AON_GPIO(BB, 2) GPIO_ACTIVE_LOW>;
+					status = "disabled";
+				};		
+			};
+
+
+			bus@0 {
+				host1x@13e00000 {
+					nvcsi@15a00000 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						num-channels = <16>;
+
+						channel@0 {
+							reg = <0>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in0: endpoint@0 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out0: endpoint@1 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in0>;
+									};
+								};
+							};
+						};
+						channel@1 {
+							reg = <1>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in1: endpoint@2 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out1: endpoint@3 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in1>;
+									};
+								};
+							};
+						};
+						channel@2 {
+							reg = <2>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in2: endpoint@4 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out2: endpoint@5 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in2>;
+									};
+								};
+							};
+						};
+						channel@3 {
+							reg = <3>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in3: endpoint@6 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m0_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out3: endpoint@7 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in3>;
+									};
+								};
+							};
+						};
+						channel@4 {
+							reg = <4>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in4: endpoint@8 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out4: endpoint@9 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in4>;
+									};
+								};
+							};
+						};
+						channel@5 {
+							reg = <5>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in5: endpoint@10 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out5: endpoint@11 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in5>;
+									};
+								};
+							};
+						};
+						channel@6 {
+							reg = <6>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in6: endpoint@12 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out6: endpoint@13 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in6>;
+									};
+								};
+							};
+						};
+						channel@7 {
+							reg = <7>;
+							status = "disable";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in7: endpoint@14 {
+										status = "okay";
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m1_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out7: endpoint@15 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in7>;
+									};
+								};
+							};
+						};
+						channel@8 {
+							reg = <8>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in8: endpoint@16 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out8: endpoint@17 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in8>;
+									};
+								};
+							};
+						};
+						channel@9 {
+							reg = <9>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in9: endpoint@18 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out9: endpoint@19 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in9>;
+									};
+								};
+							};
+						};
+						channel@10 {
+							reg = <10>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in10: endpoint@20 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out10: endpoint@21 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in10>;
+									};
+								};
+							};
+						};
+						channel@11 {
+							reg = <11>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in11: endpoint@22 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m2_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out11: endpoint@23 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in11>;
+									};
+								};
+							};
+						};
+						channel@12 {
+							reg = <12>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in12: endpoint@24 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_0_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out12: endpoint@25 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in12>;
+									};
+								};
+							};
+						};
+						channel@13 {
+							reg = <13>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in13: endpoint@26 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_1_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out13: endpoint@27 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in13>;
+									};
+								};
+							};
+						};
+						channel@14 {
+							reg = <14>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in14: endpoint@28 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_2_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out14: endpoint@29 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in14>;
+									};
+								};
+							};
+						};
+						channel@15 {
+							reg = <15>;
+							status = "okay";
+							ports {
+								status = "okay";
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									status = "okay";
+									g300_csi_in15: endpoint@30 {
+										status = "okay";
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g2m3_3_out>;
+									};
+								};
+								port@1 {
+									reg = <1>;
+									status = "okay";
+									g300_csi_out15: endpoint@31 {
+										status = "okay";
+										remote-endpoint = <&g300_vi_in15>;
+									};
+								};
+							};
+						};
+					};
+				};
+
+				cam_i2cmux{
+					status = "okay";
+					compatible = "i2c-mux-gpio";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					i2c-parent = <&cam_i2c>;
+					mux-gpios = <&gpio_aon CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+					i2c@0 {
+						status = "disable";
+						reg = <0>; // line 2 of the I2C switch
+						#address-cells = <1>;
+						#size-cells = <0>;
+						
+						g2m1_3: g2m3@6D {
+							status = "okay";
+							reg = <0x6D>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_R";
+							dser-link-port = "b";
+							st-vc = <3>;
+							vc-id = <0>;
+							orbbec_cam_num = <1>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m1_3_out: endpoint {
+										vc-id = <0>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in7>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "0";
+							};
+						};
+
+						g2m1_2: g2m2@6C {
+							status = "okay";
+							reg = <0x6C>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_L";
+							dser-link-port = "b";
+							st-vc = <2>;
+							vc-id = <1>;
+							orbbec_cam_num = <1>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m1_2_out: endpoint {
+										vc-id = <1>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in6>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "1";
+							};
+						};
+
+						g2m1_1: g2m1@6B {
+							status = "okay";
+							reg = <0x6B>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "RGB";
+							dser-link-port = "b";
+							st-vc = <1>;
+							vc-id = <2>;
+							orbbec_cam_num = <1>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m1_1_out: endpoint {
+										vc-id = <2>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in5>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "2";
+							};
+						};
+
+						g2m1_0: g2m0@6A {
+							status = "okay";
+							reg = <0x6A>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "Depth";
+							dser-link-port = "b";
+							st-vc = <0>;
+							vc-id = <3>;
+							orbbec_cam_num = <1>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m1_0_out: endpoint {
+										vc-id = <3>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in4>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "3";
+							};
+						};
+
+						/* IR_R */
+						g2m0_3: g2m3@69 {
+							status = "okay";
+							reg = <0x69>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_R";
+							dser-link-port = "a";
+							st-vc = <3>;
+							vc-id = <3>;
+							orbbec_cam_num = <0>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+
+								port@0 {
+									reg = <0>;
+									g2m0_3_out: endpoint {
+										vc-id = <3>;
+										port-index = <0>; //0
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in3>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "3";
+							};
+						};
+						/* IR_L */
+						g2m0_2: g2m2@68 {
+							status = "okay";
+							reg = <0x68>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_L";
+							dser-link-port = "a";
+							st-vc = <2>;
+							vc-id = <2>;
+							orbbec_cam_num = <0>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m0_2_out: endpoint {
+										vc-id = <2>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in2>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "2";
+							};
+						};
+						/* RGB */
+						g2m0_1: g2m1@67 {
+							status = "okay";
+							def-addr = <0x66>;
+							reg = <0x67>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "RGB";
+							dser-link-port = "a";
+							st-vc = <1>;
+							vc-id = <1>;
+							orbbec_cam_num = <0>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m0_1_out: endpoint {
+										vc-id = <1>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in1>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1"; 
+								vc_id = "1";
+							};
+						};
+						/* Depth */
+						g2m0_0: g2m0@66 {
+							status = "okay";
+							def-addr = <0x66>;
+							reg = <0x66>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "Depth";
+							dser-link-port = "a";
+							st-vc = <0>;   				/**< Default sensor virtual channel. */
+							vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+							orbbec_cam_num = <0>;
+							maxim,gmsl-dser-device = <&dser0>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+
+								port@0 {
+									reg = <0>;
+									g2m0_0_out: endpoint {
+										vc-id = <0>;
+										port-index = <0>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in0>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_a";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								lane_polarity = "6";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1"; 
+								vc_id = "0";
+							};
+						};
+						dser0: max9296@48 {
+							status = "okay";
+							reg = <0x48>; //0x90>>1
+							compatible = "maxim,obc_max9296";
+							index = <0>;
+							csi-mode = "2x4"; //2*4lane
+							seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+							proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+							real-addr = <0x66>; //camera real address
+							//reset-gpios = <&gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+							fsync_mfp_index = <0>;
+							pps_mfp_index = <6>;
+							is-fg96-2ch;
+							vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+						};
+					};
+					i2c@1 {
+						status = "okay";
+						reg = <1>; // line 2 of the I2C switch
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						g2m3_3: g2m3@6D {
+							status = "okay";
+							reg = <0x6D>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_R";
+							dser-link-port = "b";
+							st-vc = <3>;
+							vc-id = <0>;
+							orbbec_cam_num = <3>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m3_3_out: endpoint {
+										vc-id = <0>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in15>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "0";
+							};
+						};
+
+						g2m3_2: g2m2@6C {
+							status = "okay";
+							reg = <0x6C>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_L";
+							dser-link-port = "b";
+							st-vc = <2>;
+							vc-id = <1>;
+							orbbec_cam_num = <3>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m3_2_out: endpoint {
+										vc-id = <1>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in14>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "1";
+							};
+						};
+						g2m3_1: g2m1@6B {
+							status = "okay";
+							reg = <0x6B>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "RGB";
+							dser-link-port = "b";
+							st-vc = <1>;
+							vc-id = <2>;
+							orbbec_cam_num = <3>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m3_1_out: endpoint {
+										vc-id = <2>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in13>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1"; 
+								vc_id = "2";
+							};
+						};
+
+						g2m3_0: g2m0@6A {
+							status = "okay";
+							reg = <0x6A>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "Depth";
+							dser-link-port = "b";
+							st-vc = <0>;
+							vc-id = <3>;
+							orbbec_cam_num = <3>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m3_0_out: endpoint {
+										vc-id = <3>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in12>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1"; 
+								vc_id = "3";
+							};
+						};
+						g2m2_3: g2m3@69 {
+							status = "okay";
+							reg = <0x69>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_R";
+							dser-link-port = "a";
+							st-vc = <3>;
+							vc-id = <3>;
+							orbbec_cam_num = <2>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m2_3_out: endpoint {
+										vc-id = <3>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in11>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "3";
+							};
+						};
+						g2m2_2: g2m2@68 {
+							status = "okay";
+							reg = <0x68>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "IR_L";
+							dser-link-port = "a";
+							st-vc = <2>;
+							vc-id = <2>;
+							orbbec_cam_num = <2>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m2_2_out: endpoint {
+										vc-id = <2>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in10>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "grey_y8";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "8";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								serdes_pix_clk_hz = "750000000";  //4lane:750000000 ,2lane:375000000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "2";
+							};
+						};
+						g2m2_1: g2m1@67 {
+							status = "okay";
+							reg = <0x67>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "RGB";
+							dser-link-port = "a";
+							st-vc = <1>;
+							vc-id = <1>;
+							orbbec_cam_num = <2>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+								port@0 {
+									reg = <0>;
+									g2m2_1_out: endpoint {
+										vc-id = <1>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in9>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "1";
+							};
+						};
+						g2m2_0: g2m0@66 {
+							status = "okay";
+							reg = <0x66>;
+							compatible = "orbbec,g300";
+							use_sensor_mode_id = "true";
+							cam-type = "Depth";
+							dser-link-port = "a";
+							st-vc = <0>;   				/**< Default sensor virtual channel. */
+							vc-id = <0>;				/**< Destination virtual channel (user-defined). */
+							orbbec_cam_num = <2>;
+							maxim,gmsl-dser-device = <&dser1>;
+							//pps-gpios = <&gpio_aon PPS_TRIGGER GPIO_ACTIVE_LOW>;
+							ports {
+								#address-cells = <1>;
+								#size-cells = <0>;
+
+								port@0 {
+									reg = <0>;
+									g2m2_0_out: endpoint {
+										vc-id = <0>;
+										port-index = <2>;
+										bus-width = <4>;
+										remote-endpoint = <&g300_csi_in8>;
+									};
+								};
+							};
+							mode0 {
+								pixel_t = "yuv_yvyu16";
+								num_lanes = "4";
+								csi_pixel_bit_depth = "16";
+								active_w = "1280";
+								active_h = "720";
+								tegra_sinterface = "serial_c";
+								mclk_khz = "24000";
+								pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								serdes_pix_clk_hz = "375000000";  //4lane:375000000,2lane:187500000
+								discontinuous_clk = "no";
+								dpcm_enable = "false";
+								cil_settletime = "0";
+								line_length = "1280";
+								mclk_multiplier = "15.625";
+								embedded_metadata_height = "1";
+								vc_id = "0";
+							};
+						};
+						dser1: max9296@48 {
+							status = "okay";
+							reg = <0x48>; //0x90>>1
+							compatible = "maxim,obc_max9296";
+							index = <1>;
+							csi-mode = "2x4"; //2*4lane
+							seri-addr = <0x50>; //serializer start address, LinkA serializer i2c address,LINK B + 1
+							proxy-addr = <0x1a>; //camera proxy address, LinkA g300 i2c address,LINK B + 1,LINK C + 2,LINK D + 3
+							real-addr = <0x66>; //camera real address
+							//reset-gpios = <&gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+							fsync_mfp_index = <0>;
+							pps_mfp_index = <6>;
+							is-fg96-2ch;
+							vdd_supply_1v2;   //if Deser chip VDD supply 1.2V
+						};
+					};
+				};
+			};
+			tegra-camera-platform {
+				compatible = "nvidia, tegra-camera-platform";
+
+				/**
+				* Physical settings to calculate max ISO BW
+				*
+				* num_csi_lanes = <>;
+				* Total number of CSI lanes when all cameras are active
+				*
+				* max_lane_speed = <>;
+				* Max lane speed in Kbit/s
+				*
+				* min_bits_per_pixel = <>;
+				* Min bits per pixel
+				*
+				* vi_peak_byte_per_pixel = <>;
+				* Max byte per pixel for the VI ISO case
+				*
+				* vi_bw_margin_pct = <>;
+				* Vi bandwidth margin in percentage
+				*
+				* max_pixel_rate = <>;
+				* Max pixel rate in Kpixel/s for the ISP ISO case
+				*
+				* isp_peak_byte_per_pixel = <>;
+				* Max byte per pixel for the ISP ISO case
+				*
+				* isp_bw_margin_pct = <>;
+				* Isp bandwidth margin in percentage
+				*/
+				num_csi_lanes = <8>;
+				max_lane_speed = <1500000>;
+				min_bits_per_pixel = <8>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				max_pixel_rate = <7500000>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "g300_0";
+						position = "front";
+						orientation = "1";
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m3@69";
+						};
+					};
+					
+					module1 {
+						status = "okay";
+						badge = "g300_1";
+						position = "rear";
+						orientation = "1";
+						
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m0@6A";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m1@6B";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m2@6C";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/g2m3@6D";
+						};
+					};
+
+					module2 {
+						status = "okay";
+						badge = "g300_2";
+						position = "top";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m0@66";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m1@67";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m2@68";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m3@69";
+						};
+					};
+
+					module3 {
+						status = "okay";
+						badge = "g300_3";
+						position = "bottom";
+						orientation = "1";
+
+						drivernode0 {
+							status = "okay";
+								/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m0@6A";
+						};
+
+						drivernode1 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m1@6B";
+						};
+
+						drivernode2 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m2@6C";
+						};
+
+						drivernode3 {
+							status = "okay";
+							/* Declare PCL support driver (classically known as guid)  */
+							pcl_id = "v4l2_sensor";
+							/* Declare the device-tree hierarchy to driver instance */
+							proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/g2m3@6D";
+						};
+					};
+				};
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c b/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c
index 8375f9127..547bf030b 100644
--- a/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1258,6 +1258,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_GREY:		descr = "8-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y4:		descr = "4-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y6:		descr = "6-bit Greyscale"; break;
+	case V4L2_PIX_FMT_Y8:		descr = "Y8-bit Greyscale"; break; //orbbec add
 	case V4L2_PIX_FMT_Y10:		descr = "10-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y12:		descr = "12-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y14:		descr = "14-bit Greyscale"; break;
@@ -1267,6 +1268,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_Y10P:		descr = "10-bit Greyscale (MIPI Packed)"; break;
 	case V4L2_PIX_FMT_Y8I:		descr = "Interleaved 8-bit Greyscale"; break;
 	case V4L2_PIX_FMT_Y12I:		descr = "Interleaved 12-bit Greyscale"; break;
+	case V4L2_PIX_FMT_Y16I:		descr = "Interleaved 16-bit Greyscale"; break; //orbbec add
 	case V4L2_PIX_FMT_Z16:		descr = "16-bit Depth"; break;
 	case V4L2_PIX_FMT_INZI:		descr = "Planar 10:16 Greyscale Depth"; break;
 	case V4L2_PIX_FMT_CNF4:		descr = "4-bit Depth Confidence (Packed)"; break;
@@ -1396,6 +1398,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_META_FMT_VSP1_HGT:	descr = "R-Car VSP1 2-D Histogram"; break;
 	case V4L2_META_FMT_UVC:		descr = "UVC Payload Header Metadata"; break;
 	case V4L2_META_FMT_D4XX:	descr = "Intel D4xx UVC Metadata"; break;
+	case V4L2_META_FMT_G300:	descr = "Orbbec G2xx UVC Metadata"; break; //orbbec add
 	case V4L2_META_FMT_VIVID:       descr = "Vivid Metadata"; break;
 	case V4L2_META_FMT_RK_ISP1_PARAMS:	descr = "Rockchip ISP1 3A Parameters"; break;
 	case V4L2_META_FMT_RK_ISP1_STAT_3A:	descr = "Rockchip ISP1 3A Statistics"; break;
diff --git a/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/of/address.c b/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/of/address.c
index 4b0c036ec..1d613afb9 100644
--- a/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/of/address.c
+++ b/Linux_for_Tegra/source/kernel/kernel-jammy-src/drivers/of/address.c
@@ -1097,25 +1097,30 @@ phys_addr_t __init of_dma_get_max_cpu_address(struct device_node *np)
  * for this device in the DT, or if DMA is coherent by
  * default for OF devices on the current platform.
  */
+#if 1 //orbbec modify
 bool of_dma_is_coherent(struct device_node *np)
 {
 	struct device_node *node;
 
-	if (IS_ENABLED(CONFIG_OF_DMA_DEFAULT_COHERENT))
-		return true;
+	bool is_coherent = IS_ENABLED(CONFIG_OF_DMA_DEFAULT_COHERENT);
 
 	node = of_node_get(np);
 
 	while (node) {
 		if (of_property_read_bool(node, "dma-coherent")) {
-			of_node_put(node);
-			return true;
+			is_coherent = true;
+			break;
+		}
+		if (of_property_read_bool(node, "dma-noncoherent")) {
+			is_coherent = false;
+			break;
 		}
 		node = of_get_next_dma_parent(node);
 	}
 	of_node_put(node);
-	return false;
+	return is_coherent;
 }
+#endif
 EXPORT_SYMBOL_GPL(of_dma_is_coherent);
 
 /**
diff --git a/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h b/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h
index df6b711b2..02d0db3c1 100644
--- a/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h
+++ b/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/media-bus-format.h
@@ -88,6 +88,7 @@
 #define MEDIA_BUS_FMT_YUYV12_2X12		0x201e
 #define MEDIA_BUS_FMT_YVYU12_2X12		0x201f
 #define MEDIA_BUS_FMT_Y14_1X14			0x202d
+#define MEDIA_BUS_FMT_Y16_1X16			0x2033 //orbbec add
 #define MEDIA_BUS_FMT_UYVY8_1X16		0x200f
 #define MEDIA_BUS_FMT_VYUY8_1X16		0x2010
 #define MEDIA_BUS_FMT_YUYV8_1X16		0x2011
diff --git a/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h b/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h
index e6de9926c..41d74f6bc 100644
--- a/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h
+++ b/Linux_for_Tegra/source/kernel/kernel-jammy-src/include/uapi/linux/videodev2.h
@@ -734,11 +734,14 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_JPGL	v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
 #define V4L2_PIX_FMT_SE401      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
 #define V4L2_PIX_FMT_S5C_UYVY_JPG v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
+#define V4L2_PIX_FMT_Y8       v4l2_fourcc('Y', '8', ' ', ' ') /* Greyscale 8-bit, orbbec add */
 #define V4L2_PIX_FMT_Y8I      v4l2_fourcc('Y', '8', 'I', ' ') /* Greyscale 8-bit L/R interleaved */
 #define V4L2_PIX_FMT_Y12I     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
+#define V4L2_PIX_FMT_Y16I     v4l2_fourcc('Y', '1', '6', 'I') /* Greyscale 16-bit L/R interleaved, orbbec add */
 #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
 #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
 #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
+
 #define V4L2_PIX_FMT_SUNXI_TILED_NV12 v4l2_fourcc('S', 'T', '1', '2') /* Sunxi Tiled NV12 Format */
 #define V4L2_PIX_FMT_CNF4     v4l2_fourcc('C', 'N', 'F', '4') /* Intel 4-bit packed depth confidence information */
 #define V4L2_PIX_FMT_HI240    v4l2_fourcc('H', 'I', '2', '4') /* BTTV 8-bit dithered RGB */
@@ -770,6 +773,7 @@ struct v4l2_pix_format {
 #define V4L2_META_FMT_VSP1_HGT    v4l2_fourcc('V', 'S', 'P', 'T') /* R-Car VSP1 2-D Histogram */
 #define V4L2_META_FMT_UVC         v4l2_fourcc('U', 'V', 'C', 'H') /* UVC Payload Header metadata */
 #define V4L2_META_FMT_D4XX        v4l2_fourcc('D', '4', 'X', 'X') /* D4XX Payload Header metadata */
+#define V4L2_META_FMT_G300        v4l2_fourcc('G', '2', 'X', 'X') /* G300 Payload Header metadata, orbbec add */
 #define V4L2_META_FMT_VIVID	  v4l2_fourcc('V', 'I', 'V', 'D') /* Vivid Metadata */
 
 /* Vendor specific - used for RK_ISP1 camera sub-system */
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/Makefile b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/Makefile
index 7c5913c64..9595ad45d 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/Makefile
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/Makefile
@@ -5,6 +5,14 @@ subdir-ccflags-y += -Werror
 
 obj-m += max9295.o
 obj-m += max9296.o
+
+## orbbec max9296/max96712+ max9295d + G300
+obj-m += obc_max9296.o
+obj-m += obc_max96712.o
+subdir-ccflags-y += -DCONFIG_TEGRA_CAMERA_PLATFORM
+obj-m += g300.o
+g300-objs := obc_g300_seri.o obc_g300_ctrl.o obc_g300.o
+
 ifeq ($(findstring ack_src,$(NV_BUILD_KERNEL_OPTIONS)),)
 obj-m += max96712.o
 
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300.c
new file mode 100644
index 000000000..22d06ccce
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300.c
@@ -0,0 +1,1501 @@
+/*
+ * orb.c - Orbbec G300 camera driver
+ *
+ * Copyright (c) 2023-2025, ORBBEC CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+//#define DEBUG
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+
+#include <media/gmsl-link.h>
+#include <media/obc_max9296.h>
+#include <media/obc_max96712.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mediabus.h>
+
+#include <media/obc_g300_priv.h>
+
+//-------------------------------------------------------------------------------------------
+#define ORB_DRIVER_NAME 		"g300"
+#define ORB_METADATA_IN_IMAGE_FIRST_ROW 		1
+#define ORB_METADATA_IN_EMB 		            0
+#define MAX9296_MAX_LINKS   2
+#define MAX96712_MAX_LINKS  4
+//-------------------------------------------------------------------------------------------
+enum orb_mux_pad {
+    ORB_MUX_PAD_EXTERNAL,
+    ORB_MUX_PAD_DEPTH,
+    ORB_MUX_PAD_IR_L_T,
+    ORB_MUX_PAD_IR_R_T,
+    ORB_MUX_PAD_RGB,
+    ORB_MUX_PAD_COUNT,
+};
+
+//orbbec stream_type 
+enum stream_type {
+    STREAM_TYPE_UNDEFINE = 0,
+    STREAM_TYPE_GPM = 1,
+    STREAM_TYPE_DEPTH = 2,
+    STREAM_TYPE_MONO_L = 3,
+    STREAM_TYPE_MONO_R = 4,
+    STREAM_TYPE_RGB = 5,
+    STREAM_TYPE_MAX = 6,
+} stream_type_t;
+
+enum orb_sensor_type {
+    SENSOR_UNKNOWN = 0,
+    SENSOR_IR      = 1,
+    SENSOR_COLOR   = 2,
+    SENSOR_DEPTH   = 3,
+    SENSOR_ACCEL   = 4,
+    SENSOR_GYRO    = 5,
+    SENSOR_LEFT_IR = 6,
+    SENSOR_RIGHT_IR = 7,
+    SENSOR_TYPE_END = 8,
+} orb_sensor_type_t;
+
+enum pixel_fmt_e {
+    PIXEL_FORMAT_UNDEFINED    = -1,
+    PIXEL_FORMAT_PACKED_8BIT  = 8,
+    PIXEL_FORMAT_PACKED_10BIT = 10,
+    PIXEL_FORMAT_PACKED_12BIT = 12,
+    PIXEL_FORMAT_PACKED_14BIT = 14,
+    PIXEL_FORMAT_PACKED_16BIT = 16,
+    PIXEL_FORMAT_YUV422 = 16,
+    PIXEL_FORMAT_MJPEG = 8,
+};
+
+enum {
+    ORB_ORBU,
+};
+
+struct orbbec_frame_profile_data {
+    uint32_t orbbec_sensor_type;
+    uint32_t orbbec_pixel_format;
+    uint32_t width;
+    uint32_t height;
+    uint32_t max_rate;
+};
+
+//-------------------------------------------------------------------------------------------
+static int resolution_map[17] = {
+    256*144,
+    320*180,
+    320*240,
+    424*240,
+    480*270,
+    640*360,
+    640*400,
+    640*480,
+    848*100,
+    848*480,
+    967*16,
+    960*540,
+    1280*720,
+    1280*800,
+    1920*1080,
+    1280*960,
+    424*266,
+};
+
+struct orb_mbus_type_map {
+    uint32_t map_mbus_code;
+    uint8_t map_data_type;
+};
+
+static struct orb_mbus_type_map orb_mbus_code_map[25] = {
+    {MEDIA_BUS_FMT_YUYV8_1X16, PIXEL_FORMAT_YUV422},   		/**< YUYV */
+    {MEDIA_BUS_FMT_YUYV8_1X16, PIXEL_FORMAT_YUV422},		/**< YUY2 (same as YUYV)*/
+    {MEDIA_BUS_FMT_UYVY8_1X16, PIXEL_FORMAT_YUV422},		/**< UYVY */
+    {MEDIA_BUS_FMT_SGRBG12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< SGRBG12_1X12 map to NV12 */
+    {MEDIA_BUS_FMT_SGBRG12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< SGBRG12_1X12 map to NV21 */
+    {MEDIA_BUS_FMT_SBGGR8_1X8, PIXEL_FORMAT_MJPEG},					/**<SBGGR8_1X8 map to MJPG */
+    {MEDIA_BUS_FMT_SBGGR12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< SBGGR12_1X12 map to H.264 */
+    {MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< H.265 */
+    {MEDIA_BUS_FMT_VYUY8_1X16, PIXEL_FORMAT_PACKED_16BIT},  /**< Y16,single channel 16bit Depth */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< Y8, single channel 8bit Depth */
+    {MEDIA_BUS_FMT_Y10_1X10, PIXEL_FORMAT_PACKED_10BIT},	/**< Y10, single channel 10bit Depth, Parse to Y16 by SDK */
+    {MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< Y11, single channel 11bit Depth, Parse to Y16 by SDK */
+    {MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< Y12, single channel 12bit Depth, Parse to Y16 by SDK */
+    {MEDIA_BUS_FMT_UYVY8_1X16, PIXEL_FORMAT_YUV422},   		/**< No use GRAY (same as YUYV)*/
+    {MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< No use HEVC (same as H265)*/
+    {MEDIA_BUS_FMT_Y12_1X12, PIXEL_FORMAT_PACKED_12BIT},	/**< No use I420 */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use ACCEL */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use GYRO */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use  */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use x-y-z 3D point */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use RGB colored x-y-z 3d point */
+    {MEDIA_BUS_FMT_Y8_1X8, PIXEL_FORMAT_PACKED_8BIT},		/**< No use RLE lostless encoded Depth, Parse to Y16 by SDK*/
+    {MEDIA_BUS_FMT_RGB888_1X24, PIXEL_FORMAT_UNDEFINED},	/**< RGB888 */
+    {MEDIA_BUS_FMT_RGB888_1X24,	PIXEL_FORMAT_UNDEFINED}, 	/**< No use BGR (same as RBG888)*/
+    {MEDIA_BUS_FMT_Y14_1X14, PIXEL_FORMAT_UNDEFINED}		/**< Y14, single channel 14bit Depth, Parse to Y16 by SDK */
+};
+
+//-------------------------------------------------------------------------------------------
+static const u16 orb_framerate_10_30[] = {10, 15, 20, 30};
+
+static const u16 orb_framerate_to_30[] = {5, 10, 15, 30};
+static const u16 orb_framerate_to_60[] = {5, 10, 15, 30, 60};
+static const u16 orb_framerate_to_90[] = {5, 10, 15, 30, 60, 90};
+static const u16 orb_framerate_100[]= {100};
+
+static struct orb_resolution orb_default_sizes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.framerates = orb_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(orb_framerate_to_30),
+	},
+};
+
+static int orb_default_formats_num = 0;
+static struct orb_format orb_default_formats[] = {
+	{
+		.data_type = PIXEL_FORMAT_PACKED_16BIT,	// Z16 
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = 1,
+		.resolutions = orb_default_sizes,
+	}, 
+};
+
+//-------------------------------------------------------------------------------------------
+static const u16 orb_framerate_30 = 30;
+
+static struct v4l2_mbus_framefmt orb_mbus_framefmt_template = {
+    .width = 0,
+    .height = 0,
+    .code = MEDIA_BUS_FMT_FIXED,
+    .field = V4L2_FIELD_NONE,
+    .colorspace = V4L2_COLORSPACE_DEFAULT,
+    .ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+    .quantization = V4L2_QUANTIZATION_DEFAULT,
+    .xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+//-------------------------------------------------------------------------------------------
+static int probe_cam_num = -1;
+static bool pps_gpios_request = 0;
+static int max_link_num = 2;
+//-------------------------------------------------------------------------------------------
+
+
+//-------------------------------------------------------------------------------------------
+static int orb_fixed_configuration(struct orb *state)
+{
+    struct orb_sensor *sensor = &state->sensor;
+
+    switch(state->cam_type) {
+        case ORB_CAM_DEPTH:
+        default:
+            sensor->formats = state->orb_depth_formats;
+            sensor->n_formats = state->orb_depth_formats_num;
+            break;
+        case ORB_CAM_COLOR:
+            sensor->formats = state->orb_rgb_formats;
+            sensor->n_formats = state->orb_rgb_formats_num;
+            break;
+        case ORB_CAM_IR_L:
+            sensor->formats = state->orb_mono_formats;
+            sensor->n_formats = state->orb_mono_formats_num;
+            break;
+        case ORB_CAM_IR_R:
+            sensor->formats = state->orb_mono_formats;
+            sensor->n_formats = state->orb_mono_formats_num;
+            break;
+    }
+    if(sensor->n_formats == 0) {
+        dev_err(&state->client->dev, "frame_profile err cam_type%d formats_num =0 \n", state->cam_type);
+        sensor->formats = orb_default_formats;
+        sensor->n_formats = orb_default_formats_num;
+    }
+    return 0;
+}
+
+static int orb_format_struct_init(struct orb *state){
+	int i;
+	for(i = 0; i < ORB_FORMARS_MAX; i++) {
+		state->orb_depth_formats[i].resolutions = state->orb_depth_sizes[i];
+		state->orb_mono_formats[i].resolutions = state->orb_mono_sizes[i];
+		state->orb_rgb_formats[i].resolutions = state->orb_rgb_sizes[i];
+	}
+	return 0;
+}
+
+static int orbbec_get_frame_profile(struct orb *state){
+	int ret = 0;
+	int size = 0;
+	int i = 0;
+	int n = 0;
+	int f = 0;
+	int num = 0;
+	int get_ir_frame_profile_flag = 0;
+	struct orbbec_frame_profile_data *orbbec_frame_profile_t;
+	struct orb_format *orbbec_format_t;
+	struct orb_resolution *orbbec_resolutions_t;
+	int *orb_formats_num; 
+	int *orb_resolutions_num;
+	orbbec_frame_profile_t = devm_kzalloc(&state->client->dev,10*sizeof(struct orbbec_frame_profile_data), GFP_KERNEL); 
+	orb_format_struct_init(state);
+	ret = orbbec_get_frame_profile_len(state, &size);
+	if(size == 0) {
+		dev_err(&state->client->dev, "get frame_profile size =0 retry \n");
+		ret = orbbec_get_frame_profile_len(state, &size);
+		if(size == 0) {
+			dev_err(&state->client->dev, " err get frame_profile size =0  \n");
+			ret = -1;
+			goto err_6;
+		}
+	} 
+	if(ret < 0 ) {
+		dev_err(&state->client->dev, "get frame_profile size err \n");
+		goto err_6;
+	}
+	size = size / sizeof(struct orbbec_frame_profile_data);
+	dev_info(&state->client->dev, "frame_profile size = %d \n",size);
+	while (i < size)
+	{
+		if((size - i) >= 10) {
+			num = 10;
+			ret = orbbec_get_frame_profile_data(state, orbbec_frame_profile_t, 
+                        i*sizeof(struct orbbec_frame_profile_data), num*sizeof(struct orbbec_frame_profile_data));
+            if(ret < 0 ) {
+                dev_err(&state->client->dev, "orbbec_get_frame_profile_data err \n");
+                continue;
+            }
+			i += 10;
+		} else {
+			num = size - i;
+			ret = orbbec_get_frame_profile_data(state, orbbec_frame_profile_t, 
+                        i*sizeof(struct orbbec_frame_profile_data), num*sizeof(struct orbbec_frame_profile_data));
+			if(ret < 0 ) {
+                dev_err(&state->client->dev, "orbbec_get_frame_profile_data err \n");
+                continue;
+            }
+            i += size - i;
+		}
+		
+		for (n = 0; n < num; n++) {
+            struct orbbec_frame_profile_data *ptr = orbbec_frame_profile_t+n;
+			dev_dbg(&state->client->dev, "n = %d, sensor_type = %d \n", n, ptr->orbbec_sensor_type);
+			dev_dbg(&state->client->dev, "pixel_format = %d \n",ptr->orbbec_pixel_format);
+			dev_dbg(&state->client->dev, "height = %d \n",ptr->height);
+			dev_dbg(&state->client->dev, "width = %d \n",ptr->width);
+			dev_dbg(&state->client->dev, "max_rate = %d \n",ptr->max_rate);
+			
+			if(ptr->orbbec_pixel_format > 25 ) {
+				dev_err(&state->client->dev, "orbbec_pixel_format err \n");
+				continue;
+			}
+
+			if(ptr->width > 2560 || ptr->height > 2560) {
+				dev_err(&state->client->dev, "orbbec_resolution err \n");
+				continue;
+			}
+
+			if(ptr->orbbec_sensor_type > 9) {
+				dev_err(&state->client->dev, "orbbec_sensor_type err \n");
+				continue;
+			}
+
+			if(ptr->max_rate > 200) {
+				dev_err(&state->client->dev, "orbbec_max_rate err \n");
+				continue;
+			}
+
+			switch (ptr->orbbec_sensor_type) {
+				case SENSOR_IR:
+				case SENSOR_LEFT_IR:
+				case SENSOR_RIGHT_IR:
+					orbbec_format_t = state->orb_mono_formats;
+					orb_formats_num = &state->orb_mono_formats_num;
+					if(get_ir_frame_profile_flag == 0)
+                        get_ir_frame_profile_flag = ptr->orbbec_sensor_type;
+					break;	
+				case SENSOR_COLOR:
+					orbbec_format_t = state->orb_rgb_formats;
+					orb_formats_num = &state->orb_rgb_formats_num;
+					break;
+				case SENSOR_DEPTH:
+					orbbec_format_t = state->orb_depth_formats;
+					orb_formats_num = &state->orb_depth_formats_num;
+					break;
+				default :
+					dev_err(&state->client->dev, "sensor_type err \n");
+                    continue;
+					break;
+			}
+
+			if(state->device_info.pid == 0x80b && orbbec_format_t == state->orb_rgb_formats ) {
+				if(ptr->width == 1920 || ptr->width == 960 || ptr->width == 320)
+                    continue;
+			}
+			if(orbbec_format_t == state->orb_mono_formats && get_ir_frame_profile_flag != ptr->orbbec_sensor_type)
+                continue;
+
+			if(*orb_formats_num == 0) {
+				(orbbec_format_t+*orb_formats_num)->mbus_code = orb_mbus_code_map[ptr->orbbec_pixel_format].map_mbus_code;
+				(orbbec_format_t+*orb_formats_num)->data_type = orb_mbus_code_map[ptr->orbbec_pixel_format].map_data_type;
+				orbbec_resolutions_t = (orbbec_format_t+*orb_formats_num)->resolutions;
+				orb_resolutions_num = &(orbbec_format_t+*orb_formats_num)->n_resolutions;
+				*orb_formats_num=*orb_formats_num + 1; 
+			} else {
+				
+				for(f = 0;f < *orb_formats_num;f++){
+					if((orbbec_format_t+f)->mbus_code == orb_mbus_code_map[ptr->orbbec_pixel_format].map_mbus_code){
+						orbbec_resolutions_t = (orbbec_format_t+f)->resolutions;
+						orb_resolutions_num = &(orbbec_format_t+f)->n_resolutions;
+						break;
+					}
+				}
+				
+				
+				if(f == *orb_formats_num && (orbbec_format_t+f-1)->mbus_code != orb_mbus_code_map[ptr->orbbec_pixel_format].map_mbus_code){
+					if(*orb_formats_num > (ORB_FORMARS_MAX-1)) {
+						dev_err(&state->client->dev, "orb_formats_num is exceeded \n");
+						continue;
+					}
+					(orbbec_format_t+*orb_formats_num)->mbus_code = orb_mbus_code_map[ptr->orbbec_pixel_format].map_mbus_code;
+					(orbbec_format_t+*orb_formats_num)->data_type = orb_mbus_code_map[ptr->orbbec_pixel_format].map_data_type;
+					orbbec_resolutions_t = (orbbec_format_t+*orb_formats_num)->resolutions;
+					orb_resolutions_num = &(orbbec_format_t+*orb_formats_num)->n_resolutions;
+					*orb_formats_num=*orb_formats_num + 1; 
+				}
+								
+			}
+			if(*orb_resolutions_num >= ORB_RESOLUTIONS_MAX) 
+                continue;
+			(orbbec_resolutions_t+*orb_resolutions_num)->width = (uint16_t)ptr->width;
+			(orbbec_resolutions_t+*orb_resolutions_num)->height = (uint16_t)ptr->height;
+			
+			switch(ptr->max_rate){
+				case 30:
+					if(state->device_info.pid == 0xA13 || state->device_info.pid == 0x813){
+						(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_10_30;
+					    (orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_10_30);
+					}else{
+						(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_30;
+					    (orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_30);
+					}
+					break;
+
+				case 60:
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_60;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_60);
+					break;
+
+				case 90:
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_90;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_90);
+					break;
+				case 100:
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_100;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_100);
+					break;
+				default:
+					dev_err(&state->client->dev, "max_rate err \n");
+					(orbbec_resolutions_t+*orb_resolutions_num)->framerates = orb_framerate_to_30;
+					(orbbec_resolutions_t+*orb_resolutions_num)->n_framerates = ARRAY_SIZE(orb_framerate_to_30);
+					break;
+			}
+			*orb_resolutions_num = *orb_resolutions_num + 1;
+		}
+
+	}
+	err_6:
+	devm_kfree(&state->client->dev, orbbec_frame_profile_t);
+	return ret;
+}
+
+/* Get readable sensor name */
+static const char *orb_get_sensor_name(struct orb *state)
+{
+    static const char *sensor_name[] = {"DEPTH", "RGB", "IR_L", "IR_R"};
+    return sensor_name[state->cam_type];
+}
+
+/* This is needed for .get_fmt()
+ * and if streaming is started without .set_fmt() */
+static void orb_sensor_format_init(struct orb_sensor *sensor)
+{
+    struct orb_format *fmt;
+    struct v4l2_mbus_framefmt *ffmt;
+    unsigned int i;
+
+    if (sensor->config.format)
+        return;
+
+    dev_dbg(sensor->sd.dev, "%s()\n", __func__);
+
+    ffmt = &sensor->format;
+    *ffmt = orb_mbus_framefmt_template;
+    /* Use the first format */
+    fmt = sensor->formats;
+    ffmt->code = fmt->mbus_code;
+    /* and the first resolution */
+    ffmt->width = fmt->resolutions->width;
+    ffmt->height = fmt->resolutions->height;
+
+    sensor->config.format = fmt;
+    sensor->config.resolution = fmt->resolutions;
+    /* Set default framerate to 30, or to 1st one if not supported */
+    for (i = 0; i < fmt->resolutions->n_framerates;i++) {
+        if (fmt->resolutions->framerates[i] == orb_framerate_30 /* fps */) {
+            sensor->config.framerate = orb_framerate_30;
+            return;
+        }
+    }
+    sensor->config.framerate = fmt->resolutions->framerates[0];
+}
+
+/* No locking needed for enumeration methods */
+static int orb_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+        struct v4l2_subdev_pad_config *cfg,
+    #else
+        struct v4l2_subdev_state *v4l2_state,
+    #endif
+        struct v4l2_subdev_mbus_code_enum *mce)
+{
+    struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd.subdev);
+
+    if (mce->pad)
+        return -EINVAL;
+
+    if (mce->index >= sensor->n_formats)
+        return -EINVAL;
+
+    mce->code = sensor->formats[mce->index].mbus_code;
+
+    return 0;
+}
+
+static int orb_sensor_enum_frame_size(struct v4l2_subdev *sd,
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+        struct v4l2_subdev_pad_config *cfg,
+    #else
+        struct v4l2_subdev_state *v4l2_state,
+    #endif
+        struct v4l2_subdev_frame_size_enum *fse)
+{
+    struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd.subdev);
+    struct orb_format *fmt;
+    unsigned int i;
+
+    for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+        if (fse->code == fmt->mbus_code)
+            break;
+
+    if (i == sensor->n_formats)
+        return -EINVAL;
+
+    if (fse->index >= fmt->n_resolutions)
+        return -EINVAL;
+
+    fse->min_width = fse->max_width = fmt->resolutions[fse->index].width;
+    fse->min_height = fse->max_height = fmt->resolutions[fse->index].height;
+
+    dev_dbg(sd->dev, "enum_frame_size, index=%d, n_res=%d, w=%d, h=%d\n", fse->index, fmt->n_resolutions, fse->min_width, fse->min_height);
+
+    return 0;
+}
+
+static int orb_sensor_enum_frame_interval(struct v4l2_subdev *sd,
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+        struct v4l2_subdev_pad_config *cfg,
+    #else
+        struct v4l2_subdev_state *v4l2_state,
+    #endif
+        struct v4l2_subdev_frame_interval_enum *fie)
+{
+    struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd.subdev);
+    struct orb_format *fmt;
+    struct orb_resolution *res;
+    unsigned int i;
+
+    for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+        if (fie->code == fmt->mbus_code)
+            break;
+
+    if (i == sensor->n_formats)
+        return -EINVAL;
+
+    for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++)
+        if (res->width == fie->width && res->height == fie->height)
+            break;
+
+    if (i == fmt->n_resolutions)
+        return -EINVAL;
+
+    if (fie->index >= res->n_framerates)
+        return -EINVAL;
+
+    fie->interval.numerator = 1;
+    fie->interval.denominator = res->framerates[fie->index];
+
+    return 0;
+}
+
+static int orb_sensor_get_fmt(struct v4l2_subdev *sd,
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+        struct v4l2_subdev_pad_config *cfg,
+    #else
+        struct v4l2_subdev_state *v4l2_state,
+    #endif
+        struct v4l2_subdev_format *fmt)
+{
+    struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd.subdev);
+    struct orb *state = v4l2_get_subdevdata(sd);
+
+    if (fmt->pad)
+        return -EINVAL;
+
+    mutex_lock(&state->lock);
+
+    if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+        fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+#else
+        fmt->format = *v4l2_subdev_get_try_format(sd, v4l2_state, fmt->pad);
+#endif
+    else
+        fmt->format = sensor->format;
+
+    mutex_unlock(&state->lock);
+
+    dev_dbg(sd->dev, "%s(): pad %x, code %x, res %ux%u\n",
+            __func__, fmt->pad, fmt->format.code,
+            fmt->format.width, fmt->format.height);
+
+    return 0;
+}
+
+/* Called with lock held */
+static struct orb_format *orb_sensor_find_format(
+        struct orb_sensor *sensor,
+        struct v4l2_mbus_framefmt *ffmt,
+        struct orb_resolution **best)
+{
+    struct orb_resolution *res;
+    struct orb_format *fmt;
+    unsigned long best_delta = ~0;
+    unsigned int i;
+
+    for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++) {
+        if (fmt->mbus_code == ffmt->code)
+            break;
+    }
+    dev_dbg(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n",
+            __func__, fmt->mbus_code, ffmt->code);
+
+    if (i == sensor->n_formats)
+        /* Not found, use default */
+        fmt = sensor->formats;
+
+    for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
+        unsigned long delta = abs(ffmt->width * ffmt->height -
+                res->width * res->height);
+        if (delta < best_delta) {
+            best_delta = delta;
+            *best = res;
+        }
+    }
+
+    ffmt->code = fmt->mbus_code;
+    ffmt->width = (*best)->width;
+    ffmt->height = (*best)->height;
+
+    ffmt->field = V4L2_FIELD_NONE;
+    /* Should we use V4L2_COLORSPACE_RAW for Y12I? */
+    ffmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+    return fmt;
+}
+
+static int orb_sensor_set_fmt(struct v4l2_subdev *sd,
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+        struct v4l2_subdev_pad_config *cfg,
+    #else
+        struct v4l2_subdev_state *v4l2_state,
+    #endif
+        struct v4l2_subdev_format *fmt)
+{
+    struct orb_sensor *sensor = container_of(sd, struct orb_sensor, sd.subdev);
+    struct orb *state = v4l2_get_subdevdata(sd);
+    struct v4l2_mbus_framefmt *mf = &fmt->format;
+    //unsigned r;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+    dev_dbg(sensor->sd.dev, "%s(): state %p, "
+            "sensor %p, cfg %p, fmt %p, fmt->format %p\n",
+            __func__, state, sensor, cfg, fmt,  &fmt->format);
+#else
+    dev_dbg(sensor->sd.dev, "%s(): state %p, "
+            "sensor %p, cfg %p, fmt %p, fmt->format %p\n",
+            __func__, state, sensor, v4l2_state, fmt,  &fmt->format);
+#endif
+
+    if (fmt->pad)
+        return -EINVAL;
+
+    mutex_lock(&state->lock);
+
+    sensor->config.format = orb_sensor_find_format(sensor, mf,
+                        &sensor->config.resolution);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+    if (cfg && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+        *v4l2_subdev_get_try_format(&sensor->sd.subdev, cfg, fmt->pad) = *mf;
+#else
+    if (v4l2_state && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+        *v4l2_subdev_get_try_format(&sensor->sd.subdev, v4l2_state, fmt->pad) = *mf;
+#endif
+
+    else
+// FIXME: use this format in .s_stream()
+        sensor->format = *mf;
+
+    mutex_unlock(&state->lock);
+
+    dev_dbg(sensor->sd.dev, "%s(): pad: %x, code: %x, %ux%u\n",
+            __func__, fmt->pad, fmt->format.code,
+            fmt->format.width, fmt->format.height);
+
+    return 0;
+}
+
+static struct mutex serdes_lock__;
+
+//---------------------------------------------------------------------------------
+static int orb_is_link(struct orb *state)
+{
+    u8 link_sta = state->deser_ops->get_link_map(state->dser_dev);
+    return ((0x1<<state->dser_link) & link_sta) ? 1 : 0;
+}
+
+
+/* seri_pipe_id = dstvc_id */
+static int orb_setup_pipeline(struct orb *state, u8 data_type1, u8 data_type2,
+    s16 dser_pipe_id, u8 src_vc_id, u8 dst_vc_id)
+{
+    int ret = 0;
+    u8 pipe_lock = 0;
+    u8 seri_pipe_id = dst_vc_id;
+
+    dev_info(&state->client->dev, 
+            "set pipe, port:%d, pipe:%d, dt1: 0x%x, dt2: 0x%x, src_vc: %u, dst_vc: %u\n",
+            state->dser_link, dser_pipe_id, data_type1, data_type2, src_vc_id, dst_vc_id);
+
+    ret |= max9295d_set_pipe(state, state->dser_link, seri_pipe_id, data_type1, data_type2, src_vc_id);
+    ret |= state->deser_ops->set_pipe(state->dser_dev, state->dser_link, dser_pipe_id, data_type1, data_type2, src_vc_id, dst_vc_id);
+    // ret |= max9295d_pipe_en(state, dst_vc_id, 1);
+
+    msleep(200);
+    pipe_lock = state->deser_ops->check_pipe_lock(state->dser_dev);
+    dev_info(&state->client->dev, "%s pipe lock: 0x%x\n", __func__, pipe_lock);
+
+    if (ret)
+        dev_info(&state->client->dev, "failed to setup pipe\n");
+
+    return ret;
+}
+
+static int orb_gmsl_serdes_setup(struct orb *state)
+{
+    struct device *dev;
+    int err = 0, i = 0;
+    u8 link_init_flag = 0, link = 0;
+
+    if (!state || !state->dser_dev || !state->client)
+        return -EINVAL;
+
+    link_init_flag = state->deser_ops->get_link_init_flag(state->dser_dev);
+    if(link_init_flag == 0) return err;
+
+    dev = &state->client->dev;
+    dev_info(dev, "%s: start\n", __func__);
+    mutex_lock(&serdes_lock__);
+
+    link = state->deser_ops->get_link_map(state->dser_dev);
+    
+    for (i = 0; i < max_link_num; i++) { //link A~B
+		if(link & (1<<i)) {
+            state->deser_ops->set_link_init_flag(state->dser_dev, i);
+			err = max9295d_init_settings(state, i); //power off
+			if(err) {
+				dev_err(dev, "max9295d_init_settings : link %d failed \n", i);
+				continue;
+				//break;
+			}
+		}
+	}
+      
+    state->deser_ops->init_tx_gpio(state->dser_dev);
+
+    for (i = 0; i < max_link_num; i++) { //link A~B
+		if(link & (1<<i)) {
+			err = max9295d_set_orbbec_on(state, i); //power off
+			if(err) {
+				dev_err(dev, "max9295d_set_orbbec_on : link %d failed \n", i);
+				continue;
+				//break;
+			}
+		}
+	}
+    dev_info(dev, "delay 3s wait for the G300 to power on and stabilize. \n");
+    msleep_range(3000);
+
+    dev_info(dev, "%s success\n", __func__);
+
+    mutex_unlock(&serdes_lock__);
+    return err;
+}
+//---------------------------------------------------------------------------------
+
+int orbbec_reset_device_link(struct orb *state, s32 value)
+{
+    int ret = 0;
+    struct i2c_client *c = state->client;
+    
+    if(!state->dser_dev)
+        return -1;
+    
+    if(value == 0) {
+        ret = max9295d_set_orbbec_off(state, state->dser_link);
+        if(state->cam_type == ORB_CAM_DEPTH) {
+            ret = state->deser_ops->reset_dev(state->dser_dev);
+            if (ret)
+                dev_warn(&c->dev,  "failed in 9296 reset control\n");
+        }
+    } else {
+        if(state->cam_type == ORB_CAM_DEPTH) {
+
+            ret = orb_gmsl_serdes_setup(state);
+            if (ret) {
+                dev_err(&c->dev, "%s gmsl serdes setup failed\n", __func__);
+                return ret;
+            }
+
+            // ret = max9295d_init_settings(state);
+            // if (ret) {
+            // 	dev_err(&c->dev, "%s, failed to init max9295d settings\n", __func__);
+            // 	return ret;
+            // }
+
+            ret = state->deser_ops->init(state->dser_dev);
+            if (ret) {
+                dev_err(&c->dev, "%s, failed to init Deser chip settings\n", __func__);
+                return ret;
+            }
+        }
+
+        ret = max9295d_set_orbbec_on(state, state->dser_link);
+        if (ret) {
+            dev_err(&c->dev, "%s, failed to max9295d set_orbbec_on\n", __func__);
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+/* Video ops */
+static int orb_mux_g_frame_interval(struct v4l2_subdev *sd,
+        struct v4l2_subdev_frame_interval *fi)
+{
+    struct orb *state = container_of(sd, struct orb, sensor.sd.subdev);
+    struct orb_sensor *sensor = &state->sensor;
+
+    if (NULL == sd || NULL == fi)
+        return -EINVAL;
+
+    fi->interval.numerator = 1;
+    fi->interval.denominator = sensor->config.framerate;
+
+    dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+            fi->interval.denominator);
+
+    return 0;
+}
+
+static u16 __orb_probe_framerate(const struct orb_resolution *res, u16 target)
+{
+    int i;
+    u16 framerate;
+
+    for (i = 0; i < res->n_framerates; i++) {
+        framerate = res->framerates[i];
+        if (target <= framerate)
+            return framerate;
+    }
+
+    return res->framerates[res->n_framerates - 1];
+}
+
+static int orb_mux_s_frame_interval(struct v4l2_subdev *sd,
+        struct v4l2_subdev_frame_interval *fi)
+{
+    struct orb *state = container_of(sd, struct orb, sensor.sd.subdev);
+    struct orb_sensor *sensor = &state->sensor;
+    u16 framerate = 1;
+
+    if (NULL == sd || NULL == fi || fi->interval.numerator == 0) {
+        dev_err(sd->dev, "%s(): %p, %p %d\n", __func__, sd, fi, fi ? fi->interval.numerator : -1);
+        return -EINVAL;
+    }
+    framerate = fi->interval.denominator / fi->interval.numerator;
+    framerate = __orb_probe_framerate(sensor->config.resolution, framerate);
+    sensor->config.framerate = framerate;
+    fi->interval.numerator = 1;
+    fi->interval.denominator = framerate;
+
+    dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+    return 0;
+}
+
+static int orb_mux_s_stream(struct v4l2_subdev *sd, int on)
+{
+    struct orb *state = container_of(sd, struct orb, sensor.sd.subdev);
+    struct orb_sensor *sensor;
+    int ret = 0 ,i = 0 ,res_product = 0;
+    int restore_val = 0;
+    uint8_t stream_id = 0, stream_fmt = 0, stream_fmt_index = 0, stream_res = 0, md_fmt = 0;
+    uint8_t data_type1, data_type2, src_vc_id, dst_vc_id;
+    struct orbbec_set_stream_cmd stream_cmd = {0, 0, 0, 0};
+
+    sensor = &state->sensor;
+
+    switch(state->cam_type) {
+        case ORB_CAM_DEPTH:
+            stream_id = STREAM_TYPE_DEPTH;
+            break;
+        case ORB_CAM_COLOR:
+            stream_id = STREAM_TYPE_RGB;
+            break;
+        case ORB_CAM_IR_L:
+            stream_id = STREAM_TYPE_MONO_L;
+            break;
+        case ORB_CAM_IR_R:
+            stream_id = STREAM_TYPE_MONO_R;
+            break;
+        default:
+            dev_err(&state->client->dev, "Invail camera type!\n");
+            return -EINVAL;
+    }
+    md_fmt = GMSL_CSI_DT_EMBED;
+
+    stream_fmt_index = sensor->config.format->data_type;
+    switch (stream_fmt_index) {
+        case PIXEL_FORMAT_PACKED_8BIT:
+            stream_fmt = GMSL_CSI_DT_RAW_8;
+            break;
+        case PIXEL_FORMAT_PACKED_10BIT:
+            stream_fmt = GMSL_CSI_DT_RAW_10;
+            break;
+        case PIXEL_FORMAT_PACKED_12BIT:
+            stream_fmt = GMSL_CSI_DT_RAW_12;
+            break;
+        case PIXEL_FORMAT_PACKED_14BIT:
+            stream_fmt = GMSL_CSI_DT_RAW_14;
+            break;
+        case PIXEL_FORMAT_YUV422:
+            stream_fmt = GMSL_CSI_DT_YUV422_8;
+            break;
+        default:
+            dev_err(&state->client->dev, "Invail format");
+            return -EINVAL;
+    }
+    src_vc_id = state->src_vc;
+    dst_vc_id = state->dst_vc;
+
+    dev_info(&state->client->dev, "s_stream for stream %s, vc:%d, on:%d, format:%d ,fps:%d\n",
+            state->sensor.sd.subdev.name, dst_vc_id, on, stream_fmt_index, sensor->config.framerate);
+
+    restore_val = state->sensor.streaming;
+    state->sensor.streaming = on;
+
+    if (on) {
+        /*  sensor->pipe_id == dst_vc_id */
+        sensor->pipe_id = state->deser_ops->get_available_pipe(state->dser_dev, ((state->dser_link / 2) * 4) + dst_vc_id);
+        if (sensor->pipe_id < 0) {
+            dev_err(&state->client->dev, "No free pipe in Deser chip\n");
+            ret = 0;
+            goto restore_s_state;
+        }
+
+        data_type1 = stream_fmt;
+        if(state->embedded_metadata_height)
+            data_type2 = md_fmt;
+        else
+            data_type2 = 0;
+
+        ret = orb_setup_pipeline(state, data_type1, data_type2, sensor->pipe_id, src_vc_id, dst_vc_id);
+        if (ret < 0) {
+            dev_err(&state->client->dev, "setup_pipeline err\n");
+            goto restore_s_state;
+        }
+
+        if(state->embedded_metadata_height == 0) {
+            orbbec_set_metadata_place(state, ORB_METADATA_IN_IMAGE_FIRST_ROW);  //Enable METADATA_IN_IMAGE_FIRST_ROW
+        }
+        
+        res_product = sensor->config.resolution->width * sensor->config.resolution->height;
+        for(i = 0; i < ARRAY_SIZE(resolution_map); i++) {
+            if(res_product == resolution_map[i]) {
+                stream_res = i;
+                break;
+            }
+        }
+
+        if(i == ARRAY_SIZE(resolution_map) && res_product != resolution_map[i-1])
+            stream_res = -1;
+
+        stream_cmd.stream_type = stream_id;
+        stream_cmd.format = stream_fmt_index;
+        stream_cmd.res = stream_res;
+        stream_cmd.fps = sensor->config.framerate;
+        ret = sensor_stream_opt(state, &stream_cmd, 1); //stream on
+        if(ret < 0) {
+            printk(KERN_ERR "\n i2c write open stream cmd err \n");
+            goto restore_s_state;
+        }
+
+        msleep(300);
+
+        state->deser_ops->reset_oneshot(state->dser_dev);
+
+    } else {
+
+        stream_cmd.stream_type = stream_id;
+        ret = sensor_stream_opt(state, &stream_cmd, 0); //stream off
+        if(ret < 0){
+            printk(KERN_ERR "\n i2c write close stream cmd err \n");
+        }
+
+        msleep(50);
+        
+        if(max9295d_release_pipe(state, sensor->pipe_id) < 0)
+        dev_warn(&state->client->dev, "release max9295 pipe failed\n");
+        
+        if (state->deser_ops->release_pipe(state->dser_dev, state->dser_link, sensor->pipe_id) < 0)
+        dev_warn(&state->client->dev, "release Deser chip pipe failed\n");
+        
+        sensor->pipe_id = -1;
+        msleep(300);
+    }
+
+    return 0;
+
+restore_s_state:
+    if (on && sensor->pipe_id >= 0) {
+        if (state->deser_ops->release_pipe(state->dser_dev, state->dser_link, sensor->pipe_id) < 0)
+            dev_warn(&state->client->dev, "release pipe failed\n");
+        sensor->pipe_id = -1;
+    }
+
+    dev_err(&state->client->dev, "%s stream toggle failed! %x \n", orb_get_sensor_name(state) ,restore_val);
+
+    state->sensor.streaming = restore_val;
+
+    return ret;
+}
+
+static const struct v4l2_subdev_pad_ops orb_mux_pad_ops = {
+    .enum_mbus_code		= orb_sensor_enum_mbus_code,
+    .enum_frame_size	= orb_sensor_enum_frame_size,
+    .enum_frame_interval	= orb_sensor_enum_frame_interval,
+    .get_fmt		= orb_sensor_get_fmt,
+    .set_fmt		= orb_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_core_ops orb_mux_core_ops = {
+    //.s_power = orb_mux_set_power,
+    .log_status = v4l2_ctrl_subdev_log_status,
+};
+
+static const struct v4l2_subdev_video_ops orb_mux_video_ops = {
+    .g_frame_interval	= orb_mux_g_frame_interval,
+    .s_frame_interval	= orb_mux_s_frame_interval,
+    .s_stream		= orb_mux_s_stream,
+};
+
+static const struct v4l2_subdev_ops orb_mux_subdev_ops = {
+    .core = &orb_mux_core_ops,
+    .pad = &orb_mux_pad_ops,
+    .video = &orb_mux_video_ops,
+};
+
+static const struct orb_deser_ops max9296_deser_ops = {
+    .init	= max9296a_init_settings,
+    .get_link_map = max9296a_get_link_map,
+    .get_link_init_flag = max9296a_get_link_init_flag,
+    .set_link_init_flag = max9296a_set_link_init_flag,
+    .init_tx_gpio = max9296a_init_tx_gpio,
+    .get_link_state = max9296a_get_link_state,
+	.get_available_pipe = max9296a_get_available_pipe_id,
+	.set_pipe = max9296a_set_pipe,
+    .check_pipe_lock = max9296a_check_pipe_lock,
+	.release_pipe = max9296a_release_pipe,
+	.power_on = max9296a_power_on,
+	.power_off = max9296a_power_off,
+	.reset_dev = max9296a_reset_dev,
+    .write_seri_reg = max9296a_write_seri_reg,
+    .write_seri_tab = max9296a_write_seri_tab,
+    .write_sensor = max9296a_write_sensor,
+    .read_sensor = max9296a_read_sensor,
+    .reset_oneshot = max9296a_reset_oneshot,
+};
+
+static const struct orb_deser_ops max96712_deser_ops = {
+    .init	= max96712_init_settings,
+    .get_link_map = max96712_get_link_map,
+    .get_link_init_flag = max96712_get_link_init_flag,
+    .set_link_init_flag = max96712_set_link_init_flag,
+    .init_tx_gpio = max96712_init_tx_gpio,
+    .get_link_state = max96712_get_link_state,
+	.get_available_pipe = max96712_get_available_pipe_id,
+	.set_pipe = max96712_set_pipe,
+    .check_pipe_lock = max96712_check_pipe_lock,
+	.release_pipe = max96712_release_pipe,
+	.power_on = max96712_power_on,
+	.power_off = max96712_power_off,
+	.reset_dev = max96712_reset_dev,
+    .write_seri_reg = max96712_write_seri_reg,
+    .write_seri_tab = max96712_write_seri_tab,
+    .write_sensor = max96712_write_sensor,
+    .read_sensor = max96712_read_sensor,
+    .reset_oneshot = max96712_reset_oneshot,
+};
+
+static int orb_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+    dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+    return 0;
+}
+
+static int orb_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+    dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+    return 0;
+}
+
+static const struct v4l2_subdev_internal_ops orb_mux_internal_ops = {
+    .open = orb_mux_open,
+    .close = orb_mux_close,
+    // .registered = orb_mux_registered,
+    // .unregistered = orb_mux_unregistered,
+};
+
+// static int orb_mux_register(struct i2c_client *c, struct orb *state)
+// {
+// 	return v4l2_async_register_subdev(&state->sensor.sd.subdev);
+// }
+
+static int orb_v4l_init(struct i2c_client *c, struct orb *state)
+{
+    struct v4l2_subdev *sd = &state->sensor.sd.subdev;
+    struct media_entity *entity = &state->sensor.sd.subdev.entity;
+    struct media_pad *pad = &state->sensor.pad;
+    dev_t *dev_num = &state->client->dev.devt;
+    const char *name_tb[] = {"depth", "color", "ir_l", "ir_r"};
+    int ret;
+
+    orb_fixed_configuration(state);
+    orb_sensor_format_init(&state->sensor);
+
+    v4l2_i2c_subdev_init(sd, c, &orb_mux_subdev_ops);
+    // See tegracam_v4l2.c tegracam_v4l2subdev_register()
+    // Set owner to NULL so we can unload the driver module
+    sd->owner = NULL;
+    sd->internal_ops = &orb_mux_internal_ops;  //The internal operation function set for V4L2 sub-devices:opencloseregisteredunregistered
+    sd->grp_id = *dev_num;
+    v4l2_set_subdevdata(sd, state);
+    snprintf(sd->name, sizeof(sd->name), "G300 %s %d-%04x", name_tb[state->cam_type], i2c_adapter_id(c->adapter), c->addr);
+
+    sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+    pad->flags = MEDIA_PAD_FL_SOURCE;
+    entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+    entity->function = MEDIA_ENT_F_CAM_SENSOR;
+
+    ret = media_entity_pads_init(entity, 1, pad);
+    if (ret < 0)
+        return ret;
+
+    ret = orb_ctrl_init(state);
+    if (ret < 0)
+        goto e_entity;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+    state->sensor.sd.dev = &c->dev;
+    ret = camera_common_initialize(&state->sensor.sd, "g300");
+    if (ret) {
+        dev_err(&c->dev, "Failed to initialize g300, %d\n", ret);
+        goto e_ctrl;
+    }
+#endif
+
+    ret = v4l2_async_register_subdev(&state->sensor.sd.subdev);
+    if (ret < 0)
+        goto e_cam_com;
+
+    return 0;
+
+e_cam_com:
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+    camera_common_cleanup(&state->sensor.sd);
+e_ctrl:
+    v4l2_ctrl_handler_free(sd->ctrl_handler);
+#endif
+e_entity:
+    media_entity_cleanup(entity);
+
+    return ret;
+}
+
+static void orb_mux_remove(struct orb *state)
+{
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+    camera_common_cleanup(&state->sensor.sd);
+#endif
+    v4l2_async_unregister_subdev(&state->sensor.sd.subdev);
+    v4l2_ctrl_handler_free(state->sensor.sd.subdev.ctrl_handler);
+    media_entity_cleanup(&state->sensor.sd.subdev.entity);
+}
+
+static int orb_prase_dt(struct orb *state)
+{
+    struct device *dev = &state->client->dev;
+    struct device_node *node = dev->of_node;
+    struct device_node *dser_node;
+    struct i2c_client *dser_i2c = NULL;
+    struct device_node *mode;
+    const char *str;
+    int value = 0xFFFF;
+    int err = 0;
+
+    dser_node = of_parse_phandle(node, "maxim,gmsl-dser-device", 0);
+    if (dser_node == NULL) {
+        dser_node = of_parse_phandle(node, "nvidia,gmsl-dser-device", 0);
+        if (dser_node == NULL) {
+            dev_err(dev, "missing %s handle\n", "[maxim|nvidia],gmsl-dser-device");
+            goto error;
+        }
+    }
+
+    dser_i2c = of_find_i2c_device_by_node(dser_node);
+    of_node_put(dser_node);
+
+    if (dser_i2c == NULL) {
+        err = -EPROBE_DEFER;
+        goto error;
+    }
+    if (dser_i2c->dev.driver == NULL) {
+        dev_err(dev, "missing deserializer driver\n");
+        goto error;
+    }
+
+    state->dser_dev = &dser_i2c->dev;
+
+	if (of_device_is_compatible(dser_node, "maxim,obc_max9296")) {
+        state->deser_ops = &max9296_deser_ops;
+        max_link_num = MAX9296_MAX_LINKS;
+    }	
+	else if (of_device_is_compatible(dser_node, "maxim,obc_max96712")) {
+        state->deser_ops = &max96712_deser_ops;
+        max_link_num = MAX96712_MAX_LINKS;
+    }	
+	else {
+        state->deser_ops = &max9296_deser_ops;
+        max_link_num = MAX9296_MAX_LINKS;
+    }
+
+    err = of_property_read_string(node, "dser-link-port", &str);
+    if (err < 0) {
+        dev_err(dev, "No serdes-csi-link found\n");
+        goto error;
+    }
+    state->dser_link = str[0] - 'a';
+
+    err = of_property_read_u32(node, "st-vc", &value);
+    if (err < 0) {
+        dev_err(dev, "No st-vc info\n");
+        goto error;
+    }
+    state->src_vc = value;
+
+    err = of_property_read_u32(node, "vc-id", &value);
+    if (err < 0) {
+        dev_err(dev, "No vc-id info\n");
+        goto error;
+    }
+    state->dst_vc = value;
+
+    mode = of_get_child_by_name(node, "mode0");
+    if (mode == NULL) {
+        dev_err(dev, "missing mode0 device node\n");
+        err = -EINVAL;
+    }
+
+    /* embedded_metadata_height is optional */
+    err = of_property_read_string(mode, "embedded_metadata_height", &str);
+    if (err)
+        state->embedded_metadata_height = 0;
+    else
+        state->embedded_metadata_height = str[0] - '0';
+
+    state->pps_gpios = of_get_named_gpio(node, "pps-gpios", 0);
+    if (state->pps_gpios < 0) {
+        dev_err(dev, "pps-gpios not found %d\n", err);
+    } else {
+        if (!pps_gpios_request){
+            err = gpio_request(state->pps_gpios, "pps_gpios");
+            if (err < 0) {
+                dev_err(dev, "Failed to request GPIO %d\n", err);
+            }
+            pps_gpios_request = 1;
+        }
+
+        err = gpio_direction_output(state->pps_gpios, 0);
+        if (err < 0) {
+            dev_err(dev, "Failed to set GPIO direction %d\n", err);
+            gpio_free(state->pps_gpios);
+            pps_gpios_request = 0;
+            goto error;
+        }
+    }
+
+    err = of_property_read_string(node, "cam-type",	&str);
+
+    if (err || !strncmp(str, "Depth", strlen("Depth"))){
+        state->cam_type = ORB_CAM_DEPTH;
+        state->device_info.video_type = ORB_MUX_PAD_DEPTH;
+    }
+    else if (!strncmp(str, "RGB", strlen("RGB"))) {
+        state->cam_type = ORB_CAM_COLOR;
+        state->device_info.video_type = ORB_MUX_PAD_RGB;
+    }
+    else if (!strncmp(str, "IR_L", strlen("IR_L"))) {
+        state->cam_type = ORB_CAM_IR_L;
+        state->device_info.video_type = ORB_MUX_PAD_IR_L_T;
+    }
+    else if (!strncmp(str, "IR_R", strlen("IR_R"))) {
+        state->cam_type = ORB_CAM_IR_R;
+        state->device_info.video_type = ORB_MUX_PAD_IR_R_T;
+    }
+
+    state->device_info.vid = 0x2bc5;
+    err = of_property_read_u32(node, "orbbec_cam_num", &state->device_info.cam_num);
+    if (err < 0) {
+        dev_err(dev, "orbbec_cam_num not found\n");
+        goto error;
+    }
+
+    dev_info(dev, "g300 devicetree parse success\n");
+
+error:
+    return err;
+}
+
+static int orb_probe(struct i2c_client *c, const struct i2c_device_id *id)
+{
+    struct orb *state = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);
+    int ret = 0;
+    int size = 0;
+    int i = 0;
+    u8 value;
+
+    if (!state)
+        return -ENOMEM;
+    mutex_init(&state->lock);
+
+    state->client = c;
+    dev_info(&c->dev, "Probing new driver for orbbec camera\n");
+
+    state->vcc = devm_regulator_get(&c->dev, "vcc");
+    if (IS_ERR(state->vcc)) {
+        ret = PTR_ERR(state->vcc);
+        dev_warn(&c->dev, "failed %d to get vcc regulator\n", ret);
+        return ret;
+    }
+
+    if (state->vcc) {
+        ret = regulator_enable(state->vcc); 
+        if (ret < 0) {
+            dev_warn(&c->dev, "failed %d to enable the vcc regulator\n", ret);
+            return ret;
+        }
+    }
+
+    ret = orb_prase_dt(state);
+    if (ret) {
+        dev_err(&c->dev, "g300 device-tree parse failed\n");
+        goto e_regulator;
+    }
+
+    if(orb_is_link(state) == 0) {
+        dev_err(&c->dev, "camera num %d no found serialer dev\n", state->device_info.cam_num);
+        goto e_regulator;
+    }
+
+    /* Each device is called only once */
+    if(probe_cam_num != state->device_info.cam_num) {
+
+        probe_cam_num = state->device_info.cam_num;
+        
+        ret = orb_gmsl_serdes_setup(state);
+        if (ret) {
+            dev_err(&c->dev, "orbbec gmsl serdes setup failed, %d\n", ret);
+            goto e_regulator;
+        }
+
+        for (i = 0; i < 10; i++) {
+            ret = orbbec_get_frame_profile_len(state, &size);
+            if(ret == 0 && size > 0) {
+                dev_info(&c->dev, "communicate with G300\n");
+                break;
+            }
+            msleep(100);
+        }
+        if (ret < 0 || size <= 0) {
+            dev_err(&c->dev, "%s(): cannot communicate with G300: %d, %d\n", __func__, ret, size);
+            goto e_regulator;
+        }
+        if(state->embedded_metadata_height == 0) {
+            orbbec_set_metadata_place(state, ORB_METADATA_IN_IMAGE_FIRST_ROW);  //Enable METADATA_IN_IMAGE_FIRST_ROW
+            dev_err(&c->dev, "orbbec set metadata in image first row\n");
+            msleep (1);
+            orbbec_get_metadata_place(state, &value);
+            msleep (1);
+            if(value != ORB_METADATA_IN_IMAGE_FIRST_ROW){
+                dev_err(&c->dev, "orbbec set metadata in image first row err, Please use camera firmware version 1.5.57 and later.\n");
+            }
+        }
+        dev_info(&c->dev, "orbbec gmsl serdes setup success\n");
+    }
+
+    /* All video streams will be called  */
+    orbbec_get_deviceinfo(state, &state->device_info.pid, &state->device_info.sn, &state->device_info.asic_sn);
+
+    ret = orbbec_get_frame_profile(state);
+    if(ret < 0) {
+        dev_err(&c->dev, "%s(): orbbec_get_frame_profile err: %d\n" , __func__, ret);
+        goto e_regulator;
+    }
+
+    ret = orb_v4l_init(c, state);
+    if (ret < 0) {
+        dev_err(&c->dev, "orb_v4l_init failed, %d\n", ret);
+        goto e_regulator;
+    }
+
+    /* wait video pipeline bound finish */
+    while(state->sensor.sd.subdev.devnode == NULL)
+        msleep (50);
+    state->device_info.sub_num = state->sensor.sd.subdev.devnode->num;
+    if(state->cam_type == ORB_CAM_DEPTH)
+        dev_info(&c->dev, "success probe orbbec camera num %d\n", state->device_info.cam_num);
+    return 0;
+
+e_regulator:
+    if (state->vcc)
+        regulator_disable(state->vcc);
+    return ret;
+}
+
+static int orb_remove(struct i2c_client *c)
+{	
+    struct orb *state = NULL;
+    if (c != NULL) {
+        struct v4l2_subdev *sd = i2c_get_clientdata(c);
+        state = container_of(sd, struct orb, sensor.sd.subdev);
+        //state= v4l2_get_subdevdata(sd);
+        if(state != NULL && sd != NULL){
+            int ret;
+            if (state->cam_type == ORB_CAM_DEPTH) {
+                mutex_lock(&serdes_lock__);
+
+                // ret = max9295d_reset_control(state->dser_dev);
+                // if (ret)
+                // 	dev_warn(&c->dev,"failed in 9295 reset control\n");
+
+                ret = state->deser_ops->reset_dev(state->dser_dev);
+                if (ret)
+                    dev_warn(&c->dev,  "failed in deser chip reset control\n");
+                
+                state->deser_ops->power_off(state->dser_dev);
+
+                mutex_unlock(&serdes_lock__);
+            }
+            
+            dev_info(&c->dev, "G300 remove %s\n", orb_get_sensor_name(state));
+            if (state->vcc)
+                regulator_disable(state->vcc);
+            if (pps_gpios_request) {
+                gpio_free(state->pps_gpios);
+                pps_gpios_request = 0;
+            }
+            mutex_destroy(&state->lock);
+            orb_mux_remove(state);
+        }
+    
+    }
+    
+    return 0;
+}
+
+static const struct i2c_device_id orb_id[] = {
+    { ORB_DRIVER_NAME, ORB_ORBU },
+    { },
+};
+MODULE_DEVICE_TABLE(i2c, orb_id);
+
+static const struct of_device_id g300_of_match[] = {
+    { .compatible = "orbbec,g300", },
+    { },
+};
+MODULE_DEVICE_TABLE(of, g300_of_match);
+
+static struct i2c_driver orb_i2c_driver = {
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = ORB_DRIVER_NAME,
+        .of_match_table = of_match_ptr(g300_of_match),
+    },
+    .probe		= orb_probe,
+    .remove		= orb_remove,
+    .id_table	= orb_id,
+};
+
+module_i2c_driver(orb_i2c_driver);
+
+MODULE_DESCRIPTION("Orbbec G300 Camera Driver");
+MODULE_AUTHOR("chenwendong <xuanyuan@orbbec.com>");
+MODULE_AUTHOR("yezhenhao <yanxiao@orbbec.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.2.06(JP6.0)");
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300_ctrl.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300_ctrl.c
new file mode 100644
index 000000000..9051e8892
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300_ctrl.c
@@ -0,0 +1,1548 @@
+/*
+ * obc_g300_ctrl.c - Orbbec G300 camera driver
+ *
+ * Copyright (c) 2023-2025, ORBBEC CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+//#define DEBUG
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include <media/v4l2-ctrls.h>
+
+#include <media/gmsl-link.h>
+#include <media/obc_max9296.h>
+
+#include <media/obc_g300_priv.h>
+
+//-------------------------------------------------------------------------------------------
+#define ORB_N_CONTROLS			8
+
+//-------------------------------------------------------------------------------------------
+#define ORB_CAMERA_CID          0x4000
+#define ORB_CAMERA_CID_BASE	    (V4L2_CTRL_CLASS_CAMERA | ORB_CAMERA_CID)
+
+#define ORBBEC_CAMERA_CID_SET_DATA				(ORB_CAMERA_CID_BASE+33)
+#define ORBBEC_CAMERA_CID_GET_VERSION_DATA		(ORB_CAMERA_CID_BASE+34)
+//#define ORBBEC_CAMERA_CID_GET_IMU_STOCK			(ORB_CAMERA_CID_BASE+35)
+#define ORBBEC_CAMERA_CID_GET_IMU_DATA			(ORB_CAMERA_CID_BASE+36)
+#define ORBBEC_CAMERA_CID_GET_IMU_FPS			(ORB_CAMERA_CID_BASE+37)
+#define ORBBEC_CAMERA_CID_SET_DATA_LEN			(ORB_CAMERA_CID_BASE+38)
+#define ORBBEC_CAMERA_CID_GET_DATA          	(ORB_CAMERA_CID_BASE+39)
+#define ORBBEC_CAMERA_CID_PPS_TRIGGER		    (ORB_CAMERA_CID_BASE+40)
+#define ORBBEC_CAMERA_CID_RESET_DEVICE_LINK		(ORB_CAMERA_CID_BASE+41)
+#define ORBBEC_CAMERA_CID_GET_PID_SN			(ORB_CAMERA_CID_BASE+42)
+#define ORBBEC_CAMERA_CID_GET_LINK_STATE		(ORB_CAMERA_CID_BASE+43)
+#define ORBBEC_CAMERA_CID_RESET_DEVICE		    (ORB_CAMERA_CID_BASE+44)
+#define ORBBEC_CAMERA_CID_GET_METADATA_PLACE    (ORB_CAMERA_CID_BASE+45)
+
+#define G2R_IMU_STOCK_MAX_SIZE   				9
+
+//----------------------------------------------------------
+#define G2R_I2C_RESPONSE_HEARD_LEN				8
+#define G2R_GET_FIRMWARE_DATA_CMD_LEN			8
+#define G2R_GET_IMU_STOCK_CMD_LEN				10
+#define G2R_GET_IMU_DATA_CMD_LEN				18
+#define G2R_GET_FRAME_PROFILE_LEN_CMD_LEN		10
+#define G2R_GET_FRAME_PROFILE_DATA_CMD_LEN		18
+#define G2R_STREAM_START_CMD_LEN				10
+#define G2R_STREAM_STOP_CMD_LEN					8
+#define G2R_SET_PROPERTY_CMD_LEN				14
+#define G2R_GET_PROPERTY_CMD_LEN				10
+#define G2R_SET_IMU_CMD_LEN						14
+#define G2R_GET_PU_CMD_LEN      		8
+#define G2R_GET_PU_INIT_LEN     		30 //8+sizeof(ctpu_data)
+
+//I2C command to read data length
+#define G2R_GET_DATA_NOMAL_LEN	        10 
+#define G2R_GET_RESPONSE_NOMAL_LEN	    8
+#define G2R_GET_VERSION_DATA_LEN	    172
+#define G2R_RW_DATA_LEN	                256
+#define G2R_GET_IMU_DATA_LEN	        24
+#define G2R_GET_IMU_STOCK_LEN	        14 
+#define G2R_GET_PROPERTY_DATA_LEN	    28
+#define G2R_GET_FRAME_PROFILE_LEN_LEN	14 
+#define G2R_GET_SN_DATA_LEN				24
+
+//----------------------------------------------------------
+//I2C command operation code
+#define G2R_SET_PROPERTY_CODE		    2
+#define G2R_GET_PROPERTY_CODE		    1
+#define G2R_GET_FIRMWARE_DATA_CODE      3
+#define G2R_GET_IMU_DATA_CODE	        30
+#define G2R_GET_IMU_STOCK_CODE          29 
+#define G2R_GET_FRAME_PROFILE_LEN_CORE  29
+#define G2R_GET_FRAME_PROFILE_DATA_CORE 30
+#define G2R_GET_CTPU_INIT_CODE          200
+#define G2R_GET_CTPU_CODE               201
+#define G2R_SET_CTPU_CODE               202
+
+#define G2R_GET_PID_PRO_ID  			111
+#define G2R_GET_SN_PRO_ID  				1035
+#define G2R_GET_ASIC_SN_PRO_ID  		1063
+
+//----------------------------------------------------------
+#define CTPU_PROID_LEN					2
+#define IR_CONTROL_SELECT               1
+#define RGB_CONTROL_SELECT              0
+#define CT_CONTROL_SELECT               0x00
+#define PU_CONTROL_SELECT               0x80
+
+//----------------------------------------------------------
+#define CT_AE_MANUL_MODE				(1 << 0)
+#define CT_AE_AUTO_MODE					(1 << 1)
+#define CT_AE_SHUTTER_MODE				(1 << 2)
+#define CT_AE_APERTURE_MODE				(1 << 3)
+
+//----------------------------------------------------------
+/* A.9.4. Camera Terminal Control Selectors */
+#define CT_CONTROL_UNDEFINED                       0x00
+#define CT_SCANNING_MODE_CONTROL                   0x01
+#define CT_AE_MODE_CONTROL                         0x02
+#define CT_AE_PRIORITY_CONTROL                     0x03
+#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL          0x04
+#define CT_EXPOSURE_TIME_RELATIVE_CONTROL          0x05
+#define CT_FOCUS_ABSOLUTE_CONTROL                  0x06
+#define CT_FOCUS_RELATIVE_CONTROL                  0x07
+#define CT_FOCUS_AUTO_CONTROL                      0x08
+#define CT_IRIS_ABSOLUTE_CONTROL                   0x09
+#define CT_IRIS_RELATIVE_CONTROL                   0x0A
+#define CT_ZOOM_ABSOLUTE_CONTROL                   0x0B
+#define CT_ZOOM_RELATIVE_CONTROL                   0x0C
+#define CT_PANTILT_ABSOLUTE_CONTROL                0x0D
+#define CT_PANTILT_RELATIVE_CONTROL                0x0E
+#define CT_ROLL_ABSOLUTE_CONTROL                   0x0F
+#define CT_ROLL_RELATIVE_CONTROL                   0x10
+#define CT_PRIVACY_CONTROL                         0x11
+#define CT_FOCUS_SIMPLE_CONTROL                    0x12
+#define CT_WINDOW_CONTROL                          0x13
+#define CT_REGION_OF_INTEREST_CONTROL              0x14
+#define CT_CONTROL_NUM              			   0x15
+
+//----------------------------------------------------------
+/* Processing Unit Control Selectors */
+#define PU_CONTROL_UNDEFINED                       0x00
+#define PU_BACKLIGHT_COMPENSATION_CONTROL          0x01
+#define PU_BRIGHTNESS_CONTROL                      0x02
+#define PU_CONTRAST_CONTROL                        0x03
+#define PU_GAIN_CONTROL                            0x04
+#define PU_POWER_LINE_FREQUENCY_CONTROL            0x05
+#define PU_HUE_CONTROL                             0x06
+#define PU_SATURATION_CONTROL                      0x07
+#define PU_SHARPNESS_CONTROL                       0x08
+#define PU_GAMMA_CONTROL                           0x09
+#define PU_WHITE_BALANCE_TEMPERATURE_CONTROL       0x0A
+#define PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL  0x0B
+#define PU_WHITE_BALANCE_COMPONENT_CONTROL         0x0C
+#define PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL    0x0D
+#define PU_DIGITAL_MULTIPLIER_CONTROL              0x0E
+#define PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL        0x0F
+#define PU_HUE_AUTO_CONTROL                        0x10
+#define PU_ANALOG_VIDEO_STANDARD_CONTROL           0x11
+#define PU_ANALOG_LOCK_STATUS_CONTROL              0x12
+#define PU_CONTROL_NUM              			   0x13
+
+//----------------------------------------------------------
+#define OPCODE_OPEN_STREAM      100
+#define OPCODE_CLOSE_STREAM     101
+
+//-------------------------------------------------------------------------------------------
+#define I2C_RETRY_TIME		10
+
+//-------------------------------------------------------------------------------------------
+struct ctpu_data {
+    uint8_t len;//1/2/4
+    uint8_t info;
+    int32_t cur;
+    int32_t max;
+    int32_t min;
+    int32_t def;
+    int32_t step;
+}__attribute__((__packed__));
+
+struct xu_data {
+    int32_t cur_xu;
+    int32_t max_xu;
+    int32_t min_xu;
+    int32_t def_xu;
+    int32_t step_xu;
+};
+
+//-------------------------------------------------------------------------------------------
+uint8_t ct_ctl_len[CT_CONTROL_NUM] = {0};
+uint8_t pu_ctl_len[PU_CONTROL_NUM] = {0};
+
+static const u16 orb_imu_framerates[] = {0, 1, 3, 6, 12, 25, 50, 100, 200, 500, 1000, 2000, 
+    4000, 8000, 16000, 32000, 400, 800};
+
+static int get_data_len = 10;
+
+int orb_cmd_index = 1;
+
+//-------------------------------------------------------------------------------------------
+
+
+//-------------------------------------------------------------------------------------------
+/*i2c orbbec,
+*orbbec_clientorbbeci2c_client
+*data
+*length
+*-10  
+*/
+static int sensor_write_data(struct orb *state, void *data, u16 length)
+{
+    return state->deser_ops->write_sensor(state->dser_dev, state->dser_link, data, length);
+}
+
+/*i2c orbbec
+*orbbec_clientorbbeci2c_client
+*data
+*length
+*-10
+*/
+static int sensor_read_data(struct orb *state, void *data, u16 length)
+{
+    return state->deser_ops->read_sensor(state->dser_dev, state->dser_link, data, length);
+}
+
+int sensor_stream_opt(struct orb *state, struct orbbec_set_stream_cmd *strcmd, int on)
+{
+    int ret;
+    struct orbbec_cmd *cmd = kzalloc(sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    if(on) {
+        cmd->header.len = G2R_STREAM_START_CMD_LEN;
+        cmd->header.code = OPCODE_OPEN_STREAM;
+    } else {
+        cmd->header.len = G2R_STREAM_STOP_CMD_LEN;
+        cmd->header.code = OPCODE_CLOSE_STREAM;
+    }
+    cmd->header.index = orb_cmd_index++;
+    cmd->set_stream_cmd = *strcmd;
+
+    ret = sensor_write_data(state, cmd, cmd->header.len);
+    if(ret < 0) {
+        printk(KERN_ERR "\n i2c write open stream cmd err \n");
+    }
+    sensor_read_data(state, cmd, G2R_GET_DATA_NOMAL_LEN); //read response
+    kfree(cmd);
+
+    return ret;
+}
+
+/*i2c orbbec
+*stateorbbeci2c_client
+*data: 
+*cmd_len: 
+*opcode: 
+*pro_id pro_id
+*data_len 
+*-10
+*/
+static int orbbec_get_dev_info(struct orb *state, void * data, uint16_t cmd_len, uint16_t opcode, uint16_t pro_id, uint32_t data_len)
+{
+    int ret = 0, i = 0;
+    struct orbbec_cmd *get_info_cmd;
+    get_info_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_info_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_info_cmd->header.len = cmd_len;
+    get_info_cmd->header.code = opcode;
+    get_info_cmd->header.index = orb_cmd_index++;
+    get_info_cmd->_data[0] = pro_id;
+    get_info_cmd->_data[1] = pro_id >>8;
+
+    ret = sensor_write_data(state, get_info_cmd, cmd_len);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_11;
+    }
+    udelay(10);
+retry:
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_info_cmd, data_len);
+    if(get_info_cmd->header.len == 0 && get_info_cmd->header.code == 0 && get_info_cmd->header.index == 0 && i < I2C_RETRY_TIME){
+        i++;
+        dev_err(&state->client->dev, "get_dev_info data err retry ...\n");
+        goto retry;
+    }
+    if(get_info_cmd->header.code != opcode){
+        dev_err(&state->client->dev, "get_dev_info data err\n");
+        goto err_11;
+    }
+    memcpy(data, get_info_cmd->msg_body1.data, data_len-G2R_I2C_RESPONSE_HEARD_LEN);
+err_11:
+    devm_kfree(&state->client->dev, get_info_cmd);
+    return ret;
+}
+
+int orbbec_get_deviceinfo(struct orb *state, void *pid, void *sn, void *asic_sn)
+{
+    int ret = 0;
+    ret |= orbbec_get_dev_info(state, pid, G2R_GET_PROPERTY_CMD_LEN, G2R_GET_PROPERTY_CODE, G2R_GET_PID_PRO_ID,G2R_GET_DATA_NOMAL_LEN);
+    ret |= orbbec_get_dev_info(state, sn, G2R_GET_FIRMWARE_DATA_CMD_LEN, G2R_GET_FIRMWARE_DATA_CODE, G2R_GET_SN_PRO_ID,G2R_GET_SN_DATA_LEN);
+    ret |= orbbec_get_dev_info(state, asic_sn, G2R_GET_FIRMWARE_DATA_CMD_LEN, G2R_GET_FIRMWARE_DATA_CODE, G2R_GET_ASIC_SN_PRO_ID,G2R_GET_SN_DATA_LEN);
+    return ret;
+}
+
+/*i2c orbbec
+*stateorbbeci2c_client
+*data
+*-10
+*/
+static int orbbec_get_version(struct orb *state, void * data)
+{
+    int ret = 0;
+    struct orbbec_cmd *get_version_cmd;
+    get_version_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_version_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_version_cmd->header.len = G2R_GET_FIRMWARE_DATA_CMD_LEN;
+    get_version_cmd->header.code = G2R_GET_FIRMWARE_DATA_CODE;
+    get_version_cmd->header.index = orb_cmd_index++;
+    get_version_cmd->_data[0] = 0xe8;
+    get_version_cmd->_data[1] = 0x03;
+
+    ret = sensor_write_data(state, get_version_cmd, G2R_GET_FIRMWARE_DATA_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_10;
+    }
+    udelay(10);
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_version_cmd, G2R_GET_VERSION_DATA_LEN);
+    memcpy(data, get_version_cmd, G2R_GET_VERSION_DATA_LEN);
+err_10:
+    devm_kfree(&state->client->dev, get_version_cmd);
+    return ret;
+}
+
+static int orbbec_get_imu_stock(struct orb *state, int *data)
+{
+    int ret = 0, i = 0;
+    u16 cmd_index;
+    struct orbbec_cmd *get_imu_stock_cmd;
+    get_imu_stock_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_imu_stock_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_imu_stock_cmd->header.len = G2R_GET_IMU_STOCK_CMD_LEN;
+    get_imu_stock_cmd->header.code = G2R_GET_IMU_STOCK_CODE;
+    get_imu_stock_cmd->header.index = orb_cmd_index++;
+    get_imu_stock_cmd->_data[0] = 0xcd;
+    get_imu_stock_cmd->_data[1] = 0x0f;
+
+    cmd_index = get_imu_stock_cmd->header.index;
+    ret = sensor_write_data(state, get_imu_stock_cmd, G2R_GET_IMU_STOCK_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write get_imu_stock cmd err\n");
+        goto err_5;
+    }
+    //udelay(10);
+    for(i = 0; i <= I2C_RETRY_TIME; i++) {
+        usleep_range(100,120);
+        ret = sensor_read_data(state, get_imu_stock_cmd, G2R_GET_IMU_STOCK_LEN);
+        if(ret < 0) {
+            dev_err(&state->client->dev, "i2c read  get_imu_stock data err\n");
+            goto err_5;
+        }
+        
+        if(get_imu_stock_cmd->header.len != G2R_GET_IMU_STOCK_LEN || get_imu_stock_cmd->header.code != G2R_GET_IMU_STOCK_CODE || get_imu_stock_cmd->header.index != cmd_index) {
+            dev_info(&state->client->dev, "retry get_imustock\n");
+            continue;
+        }
+        else break;
+    }
+    memcpy(data, get_imu_stock_cmd->msg_body.data, 4);
+    *data = *data/G2R_GET_IMU_DATA_LEN;
+err_5:
+    devm_kfree(&state->client->dev, get_imu_stock_cmd);
+    return ret;
+}
+
+static int orbbec_get_imu_data(struct orb *state, void * data)
+{
+    int ret = 0, stock_size = 0, get_imu_date_len = 0, i = 0;
+    u16 cmd_index;
+    struct orbbec_cmd *get_imudata_cmd;
+    get_imudata_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_imudata_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+
+    ret = orbbec_get_imu_stock(state, &stock_size);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "orbbec_get_imu_stock err\n");
+        goto err_9;
+    }
+
+    get_imu_date_len = G2R_GET_IMU_DATA_LEN*stock_size;
+    get_imudata_cmd->header.len = G2R_GET_IMU_DATA_CMD_LEN;
+    get_imudata_cmd->header.code = G2R_GET_IMU_DATA_CODE;
+    get_imudata_cmd->header.index = orb_cmd_index++;
+    get_imudata_cmd->_data[0] = 0xcd;
+    get_imudata_cmd->_data[1] = 0x0f;
+    get_imudata_cmd->_data[2] = 0x0;
+    get_imudata_cmd->_data[3] = 0x0;
+    get_imudata_cmd->_data[4] = 0x0;
+    get_imudata_cmd->_data[5] = 0x0;
+    get_imudata_cmd->_data[6] = 0x0;
+    get_imudata_cmd->_data[7] = 0x0;
+    get_imudata_cmd->_data[8] = get_imu_date_len;
+    get_imudata_cmd->_data[9] = get_imu_date_len >> 8;
+    get_imudata_cmd->_data[10] = get_imu_date_len >> 16;
+    get_imudata_cmd->_data[11] = get_imu_date_len >> 24;
+
+    cmd_index = get_imudata_cmd->header.index;
+
+    if(stock_size == 0 || stock_size < 0 || stock_size > G2R_IMU_STOCK_MAX_SIZE) {
+        get_imudata_cmd->header.len = G2R_I2C_RESPONSE_HEARD_LEN;
+        get_imudata_cmd->_data[0] = 0;
+        get_imudata_cmd->_data[1] = 0;
+        get_imu_date_len = 0;
+        dev_info(&state->client->dev, " stock_size = %d \n",stock_size);
+        dev_err(&state->client->dev, "orbbec stock size err\n");
+    } else {
+        ret = sensor_write_data(state, get_imudata_cmd, G2R_GET_IMU_DATA_CMD_LEN);
+        if(ret < 0) {
+            dev_err(&state->client->dev, "i2c write get_imudata_cmd cmd err\n");
+            goto err_9;
+        }
+        //udelay(10);
+        for(i = 0; i <= I2C_RETRY_TIME; i++) {
+            usleep_range(100,120);
+            ret = sensor_read_data(state, get_imudata_cmd, G2R_I2C_RESPONSE_HEARD_LEN + get_imu_date_len);
+            if(ret < 0) {
+                dev_err(&state->client->dev, "i2c write get_imudata_cmd data err\n");
+                goto err_9;
+            }
+
+            if(get_imudata_cmd->header.len == 0 && get_imudata_cmd->header.code == 0 && get_imudata_cmd->header.index == 0) {
+                dev_dbg(&state->client->dev, "retry get_imudata\n");
+                continue;
+            }
+            else if(get_imudata_cmd->header.len != G2R_I2C_RESPONSE_HEARD_LEN + get_imu_date_len || get_imudata_cmd->header.code != G2R_GET_IMU_DATA_CODE || get_imudata_cmd->header.index != cmd_index) {
+                get_imudata_cmd->header.len = G2R_I2C_RESPONSE_HEARD_LEN;
+                get_imudata_cmd->_data[0] = 0;
+                get_imudata_cmd->_data[1] = 0;
+                get_imu_date_len = 0;
+                dev_dbg(&state->client->dev, " get_imudata data err\n");
+                break;
+            } else {
+                break;
+            }
+        }
+    }
+    
+    memcpy(data, get_imudata_cmd, G2R_I2C_RESPONSE_HEARD_LEN + get_imu_date_len);
+err_9:
+    devm_kfree(&state->client->dev, get_imudata_cmd);
+    return ret;
+}
+
+int orbbec_get_frame_profile_len(struct orb *state, void * data)
+{
+    int ret = 0;
+    struct orbbec_cmd *get_frame_profile_len_cmd = kzalloc(sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_frame_profile_len_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory\n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_frame_profile_len_cmd->header.len = G2R_GET_FRAME_PROFILE_LEN_CMD_LEN;
+    get_frame_profile_len_cmd->header.code = G2R_GET_FRAME_PROFILE_LEN_CORE;
+    get_frame_profile_len_cmd->header.index = orb_cmd_index++;
+    get_frame_profile_len_cmd->_data[0] = 0xc3;
+    get_frame_profile_len_cmd->_data[1] = 0x0f;
+    get_frame_profile_len_cmd->_data[2] = 0x00;
+    get_frame_profile_len_cmd->_data[3] = 0x00;
+
+    ret = sensor_write_data(state, get_frame_profile_len_cmd, G2R_GET_FRAME_PROFILE_LEN_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_8;
+    }
+    //udelay(10);
+    usleep_range(500, 800);
+    ret = sensor_read_data(state, get_frame_profile_len_cmd, G2R_GET_FRAME_PROFILE_LEN_LEN);
+    if(get_frame_profile_len_cmd->header.code != G2R_GET_FRAME_PROFILE_LEN_CORE) {
+        ret = -2;
+        dev_err(&state->client->dev, "get_frame_profile_len i2c data err\n");
+        goto err_8;
+    }
+    memcpy(data, get_frame_profile_len_cmd->msg_body.data, 4);
+
+err_8:
+    kfree(get_frame_profile_len_cmd);
+    return ret;
+}
+
+int orbbec_get_frame_profile_data(struct orb *state, void * data, int offset, int length)
+{
+    int ret = 0;
+    struct orbbec_cmd *get_frame_profile_data_cmd;
+    get_frame_profile_data_cmd = kzalloc(sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_frame_profile_data_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory\n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_frame_profile_data_cmd->header.len = G2R_GET_FRAME_PROFILE_DATA_CMD_LEN;
+    get_frame_profile_data_cmd->header.code = G2R_GET_FRAME_PROFILE_DATA_CORE;
+    get_frame_profile_data_cmd->header.index = orb_cmd_index++;
+    get_frame_profile_data_cmd->_data[0] = 0xc3;
+    get_frame_profile_data_cmd->_data[1] = 0x0f;
+    get_frame_profile_data_cmd->_data[2] = 0x00;
+    get_frame_profile_data_cmd->_data[3] = 0x00;
+    get_frame_profile_data_cmd->_data[4] = offset;
+    get_frame_profile_data_cmd->_data[5] = offset >> 8;
+    get_frame_profile_data_cmd->_data[6] = offset >> 16;
+    get_frame_profile_data_cmd->_data[7] = offset >> 24;
+    get_frame_profile_data_cmd->_data[8] = length;
+    get_frame_profile_data_cmd->_data[9] = length >> 8;
+    get_frame_profile_data_cmd->_data[10] = length >> 16;
+    get_frame_profile_data_cmd->_data[11] = length >> 24;
+
+    ret = sensor_write_data(state, get_frame_profile_data_cmd, G2R_GET_FRAME_PROFILE_DATA_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_7;
+    }
+    //udelay(10);
+    usleep_range(100, 120);
+    ret = sensor_read_data(state, get_frame_profile_data_cmd, G2R_GET_DATA_NOMAL_LEN+length);
+    if(get_frame_profile_data_cmd->header.code != G2R_GET_FRAME_PROFILE_DATA_CORE) {
+        ret = -2;
+        dev_err(&state->client->dev, "orbbec_get_frame_profile_data i2c data err\n");
+        goto err_7;
+    }
+    memcpy(data,get_frame_profile_data_cmd->msg_body1.data, length);
+err_7:
+    kfree(get_frame_profile_data_cmd);
+    return ret;
+}
+
+static int orbbec_set_exposure(struct orb *state, s32 data)
+{
+    int ret;
+    int prop_id;
+    struct orbbec_cmd *set_exposure_cmd;
+    set_exposure_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!set_exposure_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    switch(state->cam_type) {
+        case ORB_CAM_DEPTH: prop_id = 2017; break;
+        case ORB_CAM_COLOR: prop_id = 2001; break;
+        case ORB_CAM_IR_L:
+        case ORB_CAM_IR_R:  prop_id = 2026; break;
+        default: prop_id = 2017; break;
+    }
+    set_exposure_cmd->header.len = G2R_SET_PROPERTY_CMD_LEN;
+    set_exposure_cmd->header.code = G2R_SET_PROPERTY_CODE;
+    set_exposure_cmd->header.index = orb_cmd_index++;
+    set_exposure_cmd->_data[0] = prop_id;
+    set_exposure_cmd->_data[1] = prop_id >>8;
+    set_exposure_cmd->_data[2] = prop_id >>16;
+    set_exposure_cmd->_data[3] = prop_id >>24;
+    set_exposure_cmd->_data[4] = data;
+    set_exposure_cmd->_data[5] = data >>8;
+    set_exposure_cmd->_data[6] = data >>16;
+    set_exposure_cmd->_data[7] = data >>24;
+    
+    ret = sensor_write_data(state, set_exposure_cmd, G2R_SET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_2;
+    }
+    usleep_range(100,120);
+    sensor_read_data(state, set_exposure_cmd, G2R_GET_RESPONSE_NOMAL_LEN); //read response
+err_2:
+    devm_kfree(&state->client->dev, set_exposure_cmd);
+    return ret;
+}
+
+static int orbbec_get_exposure(struct orb *state, void * data)
+{
+    int ret;
+    int prop_id;
+    struct orbbec_cmd *get_exposure_cmd;
+    get_exposure_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_exposure_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    switch(state->cam_type) {
+        case ORB_CAM_DEPTH: prop_id = 2017; break;
+        case ORB_CAM_COLOR: prop_id = 2001; break;
+        case ORB_CAM_IR_L:
+        case ORB_CAM_IR_R:  prop_id = 2026; break;
+        default: prop_id = 2017; break;
+    }
+    get_exposure_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+    get_exposure_cmd->header.code = G2R_GET_PROPERTY_CODE;
+    get_exposure_cmd->header.index = orb_cmd_index++;
+    get_exposure_cmd->_data[0] = prop_id;
+    get_exposure_cmd->_data[1] = prop_id >>8;
+    get_exposure_cmd->_data[2] = prop_id >>16;
+    get_exposure_cmd->_data[3] = prop_id >>24;
+    
+    ret = sensor_write_data(state, get_exposure_cmd, G2R_GET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_1;
+    }
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_exposure_cmd, sizeof(struct orbbec_header)+6);
+    memcpy(data, get_exposure_cmd->msg_body1.data, 4);
+err_1:
+    devm_kfree(&state->client->dev, get_exposure_cmd);
+    return ret;
+}
+
+static int orbbec_get_exposure_init(struct orb *state, void * data)
+{
+    int ret;
+    int prop_id;
+    struct orbbec_cmd *get_exposure_cmd;
+    get_exposure_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_exposure_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    switch(state->cam_type) {
+        case ORB_CAM_DEPTH: prop_id = 2017; break;
+        case ORB_CAM_COLOR: prop_id = 2001; break;
+        case ORB_CAM_IR_L:
+        case ORB_CAM_IR_R:  prop_id = 2026; break;
+        default: prop_id = 2017; break;
+    }
+    get_exposure_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+    get_exposure_cmd->header.code = G2R_GET_PROPERTY_CODE;
+    get_exposure_cmd->header.index = orb_cmd_index++;
+    get_exposure_cmd->_data[0] = prop_id;
+    get_exposure_cmd->_data[1] = prop_id>>8;
+    get_exposure_cmd->_data[2] = prop_id>>16;
+    get_exposure_cmd->_data[3] = prop_id>>24;
+    
+    ret = sensor_write_data(state, get_exposure_cmd, G2R_GET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_1;
+    }
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_exposure_cmd, G2R_GET_PROPERTY_DATA_LEN);
+    memcpy(data, get_exposure_cmd->msg_body1.data, 20);
+err_1:
+    devm_kfree(&state->client->dev, get_exposure_cmd);
+    return ret;
+}
+
+static int orbbec_get_ctpu_init(struct orb *state, uint8_t ctpu_select, uint8_t irrgb_select, uint8_t ctpu_id, void * data)
+{
+    int ret;
+    struct orbbec_cmd *get_pu_cmd;
+    get_pu_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_pu_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_pu_cmd->header.len = G2R_GET_PU_CMD_LEN;
+    get_pu_cmd->header.code = G2R_GET_CTPU_INIT_CODE;
+    get_pu_cmd->header.index = orb_cmd_index++;
+    get_pu_cmd->_data[0] = ctpu_select+ctpu_id;
+    get_pu_cmd->_data[1] = irrgb_select;
+
+    ret = sensor_write_data(state, get_pu_cmd, G2R_GET_PU_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto error;
+    }
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_pu_cmd, G2R_GET_PU_INIT_LEN);
+    memcpy(data, get_pu_cmd->msg_body1.data, sizeof(struct ctpu_data));
+error:
+    devm_kfree(&state->client->dev, get_pu_cmd);
+    return ret;
+}
+
+static int orbbec_get_ctpu(struct orb *state, uint8_t ctpu_select, uint8_t irrgb_select, uint8_t ctpu_id, void * data, uint8_t len)
+{
+    int ret;
+    struct orbbec_cmd *get_pu_cmd;
+    get_pu_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_pu_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_pu_cmd->header.len = G2R_GET_PU_CMD_LEN;
+    get_pu_cmd->header.code = G2R_GET_CTPU_CODE;
+    get_pu_cmd->header.index = orb_cmd_index++;
+    get_pu_cmd->_data[0] = ctpu_select+ctpu_id;
+    get_pu_cmd->_data[1] = irrgb_select;
+
+    ret = sensor_write_data(state, get_pu_cmd, G2R_GET_PU_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto error;
+    }
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_pu_cmd, G2R_I2C_RESPONSE_HEARD_LEN+len);
+    memcpy(data, get_pu_cmd->msg_body1.data, len);
+error:
+    devm_kfree(&state->client->dev, get_pu_cmd);
+    return ret;
+}
+
+static int orbbec_set_autoexposure(struct orb *state, s32 data)
+{
+    int ret;
+    struct orbbec_cmd *set_autoexposure_cmd;
+    set_autoexposure_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!set_autoexposure_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    set_autoexposure_cmd->header.len = G2R_SET_PROPERTY_CMD_LEN;
+    set_autoexposure_cmd->header.code = G2R_SET_PROPERTY_CODE;
+    set_autoexposure_cmd->header.index = orb_cmd_index++;
+    set_autoexposure_cmd->_data[0] = 0xE0;
+    set_autoexposure_cmd->_data[1] = 0x07;
+    set_autoexposure_cmd->_data[2] = 0x00;
+    set_autoexposure_cmd->_data[3] = 0x00;
+    if(data == V4L2_EXPOSURE_AUTO) {
+        set_autoexposure_cmd->_data[4] = 1;
+        set_autoexposure_cmd->_data[5] = 0;
+    } else if(data == V4L2_EXPOSURE_MANUAL) {
+        set_autoexposure_cmd->_data[4] = 0;
+        set_autoexposure_cmd->_data[5] = 0;
+    }
+
+    ret = sensor_write_data(state, set_autoexposure_cmd, G2R_SET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_3;
+    }
+    usleep_range(100,120);
+    sensor_read_data(state, set_autoexposure_cmd, G2R_GET_RESPONSE_NOMAL_LEN);  //read response
+err_3:
+    devm_kfree(&state->client->dev, set_autoexposure_cmd);
+    return ret;
+}
+
+static int orbbec_get_autoexposure(struct orb *state, void * data)
+{
+    int ret;
+    struct orbbec_cmd *get_autoexposure_cmd;
+    get_autoexposure_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_autoexposure_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_autoexposure_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+    get_autoexposure_cmd->header.code = G2R_GET_PROPERTY_CODE;
+    get_autoexposure_cmd->header.index = orb_cmd_index++;
+    get_autoexposure_cmd->_data[0] = 0xE0;
+    get_autoexposure_cmd->_data[1] = 0x07;
+    get_autoexposure_cmd->_data[2] = 0x00;
+    get_autoexposure_cmd->_data[3] = 0x00;
+
+
+    ret = sensor_write_data(state, get_autoexposure_cmd, G2R_GET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto error;
+    }
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_autoexposure_cmd, G2R_GET_PROPERTY_DATA_LEN);
+    memcpy(data, get_autoexposure_cmd->msg_body1.data, 2);
+error:
+    devm_kfree(&state->client->dev, get_autoexposure_cmd);
+    return ret;
+}
+
+int orbbec_set_metadata_place(struct orb *state, u8 data)
+{
+    int ret;
+    struct orbbec_cmd *set_metadata_place_cmd;
+    set_metadata_place_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!set_metadata_place_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    set_metadata_place_cmd->header.len = G2R_SET_PROPERTY_CMD_LEN;
+    set_metadata_place_cmd->header.code = G2R_SET_PROPERTY_CODE;
+    set_metadata_place_cmd->header.index = orb_cmd_index++;
+    set_metadata_place_cmd->_data[0] = 0xE9;
+    set_metadata_place_cmd->_data[1] = 0x00;
+    set_metadata_place_cmd->_data[2] = 0x00;
+    set_metadata_place_cmd->_data[3] = 0x00;
+    set_metadata_place_cmd->_data[4] = data;
+
+    ret = sensor_write_data(state, set_metadata_place_cmd, G2R_SET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto err_3;
+    }
+    usleep_range(100,120);
+    sensor_read_data(state, set_metadata_place_cmd, G2R_GET_RESPONSE_NOMAL_LEN); //read response
+err_3:
+    devm_kfree(&state->client->dev, set_metadata_place_cmd);
+    return ret;
+}
+
+int orbbec_get_metadata_place(struct orb *state, u8 *data)
+{
+    int ret;
+    struct orbbec_cmd *get_metadata_place_cmd;
+    get_metadata_place_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!get_metadata_place_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    get_metadata_place_cmd->header.len = G2R_GET_PROPERTY_CMD_LEN;
+    get_metadata_place_cmd->header.code = G2R_GET_PROPERTY_CODE;
+    get_metadata_place_cmd->header.index = orb_cmd_index++;
+    get_metadata_place_cmd->_data[0] = 0xE9;
+    get_metadata_place_cmd->_data[1] = 0x00;
+    get_metadata_place_cmd->_data[2] = 0x00;
+    get_metadata_place_cmd->_data[3] = 0x00;
+
+
+    ret = sensor_write_data(state, get_metadata_place_cmd, G2R_GET_PROPERTY_CMD_LEN);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+        goto error;
+    }
+    usleep_range(100,120);
+    ret = sensor_read_data(state, get_metadata_place_cmd, G2R_GET_DATA_NOMAL_LEN);
+    memcpy(data, get_metadata_place_cmd->msg_body1.data, 1);
+error:
+    devm_kfree(&state->client->dev, get_metadata_place_cmd);
+    return ret;
+}
+
+static int orbbec_set_ctpu(struct orb *state,uint8_t ctpu_select, uint8_t irrgb_select, uint8_t ctpu_id, int value, uint8_t len)
+{
+    int ret;
+    struct orbbec_cmd *set_pu_cmd;
+    set_pu_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    if (!set_pu_cmd) {
+        dev_err(&state->client->dev, "%s(): Can't allocate memory \n", __func__);
+        ret = -ENOMEM;
+        return ret;
+    }
+    set_pu_cmd->header.len = sizeof(struct orbbec_header)+CTPU_PROID_LEN+len;
+    set_pu_cmd->header.code = G2R_SET_CTPU_CODE;
+    set_pu_cmd->header.index = orb_cmd_index++;
+    set_pu_cmd->_data[0] = ctpu_select+ctpu_id;
+    set_pu_cmd->_data[1] = irrgb_select;
+    set_pu_cmd->_data[2] = value;
+    set_pu_cmd->_data[3] = value >> 8;
+    set_pu_cmd->_data[4] = value >> 16;
+    set_pu_cmd->_data[5] = value >> 24;
+
+    ret = sensor_write_data(state, set_pu_cmd, sizeof(struct orbbec_header)+CTPU_PROID_LEN+len);
+    if(ret < 0) {
+        dev_err(&state->client->dev, "i2c write cmd err\n");
+    }
+    devm_kfree(&state->client->dev, set_pu_cmd);
+    return ret;
+}
+
+static int orb_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+    struct orb *state = container_of(ctrl->handler, struct orb, ctrls.handler);
+    struct v4l2_subdev *sd = &state->sensor.sd.subdev;
+    struct orbbec_cmd *get_cmd = NULL;
+    int ret = 0;
+
+    mutex_lock(&state->lock);
+
+    get_cmd = devm_kzalloc(&state->client->dev, sizeof(struct orbbec_cmd), GFP_KERNEL);
+    dev_dbg(&state->client->dev, "%s(): ctrl: %s \n", __func__, ctrl->name);
+
+    v4l2_dbg(3, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+
+    switch (ctrl->id) {
+    case V4L2_CID_GAIN:
+        if (state->cam_type != ORB_CAM_COLOR) {
+            orbbec_set_ctpu(state, PU_CONTROL_SELECT, IR_CONTROL_SELECT, PU_GAIN_CONTROL, ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+        } else {
+            orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAIN_CONTROL, ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+        }
+        break;
+    case V4L2_CID_BACKLIGHT_COMPENSATION:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BACKLIGHT_COMPENSATION_CONTROL, ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+        break;
+
+    case V4L2_CID_BRIGHTNESS:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BRIGHTNESS_CONTROL, ctrl->val, pu_ctl_len[PU_BRIGHTNESS_CONTROL]);
+        break;	
+    
+    case V4L2_CID_CONTRAST:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_CONTRAST_CONTROL, ctrl->val, pu_ctl_len[PU_CONTRAST_CONTROL]);
+        break;
+        
+    case V4L2_CID_EXPOSURE_AUTO:
+        if (state->cam_type == ORB_CAM_COLOR) {
+            if(ctrl->val == V4L2_EXPOSURE_AUTO) {
+                orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_AUTO_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+            } else if(ctrl->val == V4L2_EXPOSURE_MANUAL) {
+                orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_MANUL_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+            }
+        }
+        if (state->cam_type == ORB_CAM_IR_L || state->cam_type == ORB_CAM_IR_R) {
+            if(ctrl->val == V4L2_EXPOSURE_AUTO) {
+                orbbec_set_ctpu(state, CT_CONTROL_SELECT, IR_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_AUTO_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+            } else if(ctrl->val == V4L2_EXPOSURE_MANUAL) {
+                orbbec_set_ctpu(state, CT_CONTROL_SELECT, IR_CONTROL_SELECT, CT_AE_MODE_CONTROL, CT_AE_MANUL_MODE, ct_ctl_len[CT_AE_MODE_CONTROL]);
+            }
+        }
+        if (state->cam_type == ORB_CAM_DEPTH) {
+            ret = orbbec_set_autoexposure(state, ctrl->val);
+        }
+        break;
+
+    case V4L2_CID_EXPOSURE_ABSOLUTE:
+        if (state->cam_type != ORB_CAM_COLOR) {
+            ret = orbbec_set_exposure(state, ctrl->val);
+        } else {
+            orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, ctrl->val, ct_ctl_len[CT_EXPOSURE_TIME_ABSOLUTE_CONTROL]);	
+        }
+        break;
+
+    case V4L2_CID_GAMMA:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAMMA_CONTROL, ctrl->val, pu_ctl_len[PU_GAMMA_CONTROL]);	
+        break;
+
+    case V4L2_CID_HUE:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_HUE_CONTROL, ctrl->val, pu_ctl_len[PU_HUE_CONTROL]);	
+        break;
+
+    case V4L2_CID_SATURATION:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SATURATION_CONTROL, ctrl->val, pu_ctl_len[PU_SATURATION_CONTROL]);	
+        break;
+
+    case V4L2_CID_SHARPNESS:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SHARPNESS_CONTROL, ctrl->val, pu_ctl_len[PU_SHARPNESS_CONTROL]);	
+        break;
+
+    case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_CONTROL, ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_CONTROL]);	
+        break;
+
+    case V4L2_CID_AUTO_WHITE_BALANCE:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL, ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL]);	
+        break;
+
+    case V4L2_CID_POWER_LINE_FREQUENCY:
+        orbbec_set_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_POWER_LINE_FREQUENCY_CONTROL, ctrl->val, pu_ctl_len[PU_POWER_LINE_FREQUENCY_CONTROL]);	
+        break;
+    
+    case V4L2_CID_EXPOSURE_AUTO_PRIORITY:
+        orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_PRIORITY_CONTROL, ctrl->val, ct_ctl_len[CT_AE_PRIORITY_CONTROL]);	
+        break;
+
+    case V4L2_CID_FOCUS_ABSOLUTE:
+        orbbec_set_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_FOCUS_ABSOLUTE_CONTROL, ctrl->val, ct_ctl_len[CT_FOCUS_ABSOLUTE_CONTROL]);	
+        break;
+
+    case ORBBEC_CAMERA_CID_SET_DATA:
+        dev_dbg(&state->client->dev,"%s(): G2R set size \n",__func__);
+        if (ctrl->p_new.p_u8) {
+            memcpy(get_cmd, ctrl->p_new.p_u8, sizeof(struct orbbec_header)+8);
+            dev_dbg(&state->client->dev, "%s(): G2R set opcode=%d, proid=%d\n",
+                    __func__, get_cmd->header.code, get_cmd->set_imu_cmd.prop_code0);
+            //save imu_fps
+            if(get_cmd->header.code == 2 && get_cmd->set_imu_cmd.prop_code0 == 2021) {
+                state->imu_fps = orb_imu_framerates[get_cmd->set_imu_cmd.value0];
+                dev_dbg(&state->client->dev,"%s(): imu_fps=%d \n", __func__, state->imu_fps);
+            }  
+            ret = sensor_write_data(state, (u8*)ctrl->p_new.p_u8, get_cmd->header.len);
+        }
+        break;
+
+    case ORBBEC_CAMERA_CID_SET_DATA_LEN:
+        if (ctrl->val) {
+            get_data_len = ctrl->val;
+            dev_dbg(&state->client->dev, "%s(): G2R set get data len= %d\n", __func__, get_data_len);
+        }
+        break;
+    
+    case ORBBEC_CAMERA_CID_RESET_DEVICE_LINK:
+        dev_dbg(&state->client->dev,"%s(): G2R reset device link\n", __func__);
+        ret = orbbec_reset_device_link(state, 0);
+        msleep (3000);
+        ret = orbbec_reset_device_link(state, 1);
+        msleep (3000);
+        dev_dbg(&state->client->dev,"%s(): G2R reset device link finish\n", __func__);
+        break;
+
+    case ORBBEC_CAMERA_CID_PPS_TRIGGER:
+        dev_dbg(&state->client->dev,"%s(): G2R set pps trigger\n", __func__);
+        gpio_set_value(state->pps_gpios, 1);
+        msleep (1);
+        gpio_set_value(state->pps_gpios, 0);
+        break;
+
+    case ORBBEC_CAMERA_CID_RESET_DEVICE:
+        dev_dbg(&state->client->dev,"%s(): G2R reset device\n", __func__);
+        ret = max9295d_set_orbbec_off(state, state->dser_link);
+        msleep (3000);
+        ret = max9295d_set_orbbec_on(state, state->dser_link);
+        msleep (3000);
+        dev_dbg(&state->client->dev,"%s(): G2R reset device finish\n", __func__);
+        break;
+
+    }
+
+    devm_kfree(&state->client->dev, get_cmd);
+    mutex_unlock(&state->lock);
+
+    return ret;
+}
+
+static int orb_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+    struct orb *state = container_of(ctrl->handler, struct orb,
+            ctrls.handler);
+    int16_t temp;
+    int ret = 0, err = 0;
+    u16 reg;
+
+    dev_dbg(&state->client->dev, "%s(): ctrl: %s \n",
+        __func__, ctrl->name);
+    mutex_lock(&state->lock);
+
+    switch (ctrl->id) {
+    case V4L2_CID_GAIN:
+        if (state->cam_type != ORB_CAM_COLOR) {
+            orbbec_get_ctpu(state, PU_CONTROL_SELECT, IR_CONTROL_SELECT, PU_GAIN_CONTROL, &ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+        } else {
+            orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAIN_CONTROL, &ctrl->val, pu_ctl_len[PU_GAIN_CONTROL]);
+        }	
+        break;
+
+    case V4L2_CID_BACKLIGHT_COMPENSATION:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BACKLIGHT_COMPENSATION_CONTROL, &ctrl->val, pu_ctl_len[PU_BACKLIGHT_COMPENSATION_CONTROL]);
+        break;
+
+    case V4L2_CID_BRIGHTNESS:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BRIGHTNESS_CONTROL, &temp, pu_ctl_len[PU_BRIGHTNESS_CONTROL]);
+        ctrl->val = temp;
+        break;	
+    
+    case V4L2_CID_CONTRAST:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_CONTRAST_CONTROL, &ctrl->val, pu_ctl_len[PU_CONTRAST_CONTROL]);
+        break;	
+    case V4L2_CID_EXPOSURE_AUTO:
+        if(state->cam_type == ORB_CAM_DEPTH) {
+            orbbec_get_autoexposure(state, &reg);
+            if (reg == 1) ctrl->val = V4L2_EXPOSURE_AUTO;
+            else if (reg == 0) ctrl->val = V4L2_EXPOSURE_MANUAL;
+        } else {
+            if(state->cam_type == ORB_CAM_COLOR) {
+                orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, &ctrl->val, ct_ctl_len[CT_AE_MODE_CONTROL]);
+            } else {
+                orbbec_get_ctpu(state, CT_CONTROL_SELECT, IR_CONTROL_SELECT, CT_AE_MODE_CONTROL, &ctrl->val, ct_ctl_len[CT_AE_MODE_CONTROL]);
+            }
+            if(ctrl->val == CT_AE_AUTO_MODE || ctrl->val == CT_AE_APERTURE_MODE)
+                ctrl->val = V4L2_EXPOSURE_AUTO;
+            else if(ctrl->val == CT_AE_MANUL_MODE || ctrl->val == CT_AE_SHUTTER_MODE)
+                ctrl->val = V4L2_EXPOSURE_MANUAL;
+        }
+        break;
+
+    case V4L2_CID_EXPOSURE_ABSOLUTE:
+        if (state->cam_type != ORB_CAM_COLOR) {
+            ret = orbbec_get_exposure(state, &ctrl->val);
+        } else {
+            ret = orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, &ctrl->val, ct_ctl_len[CT_EXPOSURE_TIME_ABSOLUTE_CONTROL]);
+        }
+        break;
+
+    case V4L2_CID_GAMMA:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAMMA_CONTROL, &ctrl->val, pu_ctl_len[PU_GAMMA_CONTROL]);	
+        break;
+
+    case V4L2_CID_HUE:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_HUE_CONTROL, &temp, pu_ctl_len[PU_HUE_CONTROL]);
+        ctrl->val = temp;
+        break;
+
+    case V4L2_CID_SATURATION:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SATURATION_CONTROL, &ctrl->val, pu_ctl_len[PU_SATURATION_CONTROL]);	
+        break;
+
+    case V4L2_CID_SHARPNESS:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SHARPNESS_CONTROL, &ctrl->val, pu_ctl_len[PU_SHARPNESS_CONTROL]);	
+        break;
+
+    case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_CONTROL, &ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_CONTROL]);	
+        break;
+
+    case V4L2_CID_AUTO_WHITE_BALANCE:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL, &ctrl->val, pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL]);	
+        break;
+
+    case V4L2_CID_POWER_LINE_FREQUENCY:
+        orbbec_get_ctpu(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_POWER_LINE_FREQUENCY_CONTROL, &ctrl->val, pu_ctl_len[PU_POWER_LINE_FREQUENCY_CONTROL]);	
+        break;
+
+    case V4L2_CID_EXPOSURE_AUTO_PRIORITY:
+        orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_PRIORITY_CONTROL, &ctrl->val, ct_ctl_len[CT_AE_PRIORITY_CONTROL]);	
+        break;
+
+    case V4L2_CID_FOCUS_ABSOLUTE:
+        orbbec_get_ctpu(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_FOCUS_ABSOLUTE_CONTROL, &ctrl->val, ct_ctl_len[CT_FOCUS_ABSOLUTE_CONTROL]);	
+        break;
+
+    case ORBBEC_CAMERA_CID_GET_VERSION_DATA:
+        if (ctrl->p_new.p_u8) {
+            ret = orbbec_get_version(state, ctrl->p_new.p_u8);	
+        }
+        break;
+
+    case ORBBEC_CAMERA_CID_GET_IMU_FPS:
+        if (ctrl->p_new.p_u32) {
+            *ctrl->p_new.p_u32 = state->imu_fps;
+        }
+        break;
+
+    case ORBBEC_CAMERA_CID_GET_IMU_DATA:
+        if (ctrl->p_new.p_u8) {
+            ret = orbbec_get_imu_data(state, ctrl->p_new.p_u8);		
+        }
+        break;
+        
+    case ORBBEC_CAMERA_CID_GET_DATA:
+        dev_dbg(&state->client->dev,"%s(): G2R getdata\n",__func__);
+        if (ctrl->p_new.p_u8) {
+            ret = sensor_read_data(state, (u8*)ctrl->p_new.p_u8 , get_data_len);
+        }
+        break;
+
+    case ORBBEC_CAMERA_CID_GET_PID_SN:
+        dev_dbg(&state->client->dev,"%s(): G2R getpidsn\n",__func__);
+        ret = orbbec_get_deviceinfo(state, &state->device_info.pid, &state->device_info.sn, &state->device_info.asic_sn);
+        if (ret) {
+            dev_err(&state->client->dev,"orbbec_get_deviceinfo err\n");
+            goto error;
+        }
+        if (ctrl->p_new.p_u8) {
+            memcpy(ctrl->p_new.p_u8,&state->device_info, sizeof(struct orbbec_device_info));
+        }
+        break;
+
+    case ORBBEC_CAMERA_CID_GET_LINK_STATE:
+        /*
+        dev_dbg(&state->client->dev,"%s(): G2R get link state\n",__func__);
+        err = max9295d_set_orbbec_on(state);
+        if (err) {
+            dev_err(&state->client->dev, "%s, failed to max9295d set_orbbec_on\n", __func__);
+            ctrl->val = 0;
+        } else {
+            ctrl->val = 1;
+        }
+        */
+        err = state->deser_ops->get_link_state(state->dser_dev, state->dser_link, &ctrl->val);
+        break;
+    case ORBBEC_CAMERA_CID_GET_METADATA_PLACE:
+        ctrl->val = state->embedded_metadata_height==1 ? 0 : 1;
+        break;
+    }
+error:
+    mutex_unlock(&state->lock);
+
+    return ret;
+}
+
+static const struct v4l2_ctrl_ops orb_ctrl_ops = {
+    .s_ctrl	= orb_s_ctrl,
+    .g_volatile_ctrl = orb_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_imu_fps = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_IMU_FPS,
+    .name = "GET_IMU_FPS",
+    .type = V4L2_CTRL_TYPE_U32,
+    .dims = {1},
+    .elem_size = sizeof(u32),
+    .min = 0,
+    .max = 0xFFFFFFFF,
+    .def = 0,
+    .step = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};	
+    
+static const struct v4l2_ctrl_config g2r_ctrl_set_data = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_SET_DATA,
+    .name = "G2R_W",
+    .type = V4L2_CTRL_TYPE_U8,
+    .dims = {G2R_RW_DATA_LEN},
+    .elem_size = sizeof(u8),
+    .min = 0,
+    .max = 0xFFFFFFFF,
+    .def = 240,
+    .step = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};	
+
+static const struct v4l2_ctrl_config g2r_ctrl_set_datalen = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_SET_DATA_LEN,
+    .name = "SET G2R_R LEN",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .min = 0,
+    .max = 256,
+    .step = 1,
+    .def = 256,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};	
+
+static const struct v4l2_ctrl_config g2r_ctrl_reset_device_link = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_RESET_DEVICE_LINK,
+    .name = "G2R_RESET_DEVICE_LINK",
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_reset_device = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_RESET_DEVICE,
+    .name = "G2R_RESET_DEVICE",
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_version_data = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_VERSION_DATA,
+    .name = "G2R_GET_VERSION",
+    .type = V4L2_CTRL_TYPE_U8,
+    .dims = {G2R_GET_VERSION_DATA_LEN},
+    .elem_size = sizeof(u8),
+    .min = 0,
+    .max = 0xFFFFFFFF,
+    .def = 240,
+    .step = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_data = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_DATA,
+    .name = "G2R_R",
+    .type = V4L2_CTRL_TYPE_U8,
+    .dims = {G2R_RW_DATA_LEN},
+    .elem_size = sizeof(u8),
+    .min = 0,
+    .max = 0xFFFFFFFF,
+    .def = 1,
+    .step = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+static const struct v4l2_ctrl_config g2r_ctrl_get_pid_sn = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_PID_SN,
+    .name = "G2R_R_PID_SN",
+    .type = V4L2_CTRL_TYPE_U8,
+    .dims = {sizeof(struct orbbec_device_info)},
+    .elem_size = sizeof(u8),
+    .min = 0,
+    .max = 0xFFFFFFFF,
+    .def = 1,
+    .step = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE |V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_imu_data = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_IMU_DATA,
+    .name = "G2R_GET_IMU_DATA",
+    .type = V4L2_CTRL_TYPE_U8,
+    .dims = {G2R_I2C_RESPONSE_HEARD_LEN + G2R_GET_IMU_DATA_LEN * G2R_IMU_STOCK_MAX_SIZE},
+    .elem_size = sizeof(u8),
+    .min = 0,
+    .max = 0xFFFFFFFF,
+    .def = 240,
+    .step = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_pps_trigger = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_PPS_TRIGGER,
+    .name = "G2R_PPS_TRIGGER",
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_link_state = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_LINK_STATE,
+    .name = "GET LINK STATE",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 1,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config g2r_ctrl_get_metadata_place = {
+    .ops = &orb_ctrl_ops,
+    .id = ORBBEC_CAMERA_CID_GET_METADATA_PLACE,
+    .name = "GET METADATA PLACE",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 0,
+    .flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static int orb_set_flags(uint8_t info)
+{
+    switch (info) {
+    case 3:
+        return V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+    case 2:
+        return V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_WRITE_ONLY;
+    case 1:
+        return V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE | V4L2_CTRL_FLAG_READ_ONLY;
+    default:
+        return V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+    }
+}
+
+int orb_ctrl_init(struct orb *state)
+{
+    const struct v4l2_ctrl_ops *ops = &orb_ctrl_ops;
+    struct orb_ctrls *ctrls = &state->ctrls;
+    struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+    struct v4l2_subdev *sd = &state->sensor.sd.subdev;
+    struct ctpu_data *ctpu_data_t = devm_kzalloc(&state->client->dev, sizeof(struct ctpu_data), GFP_KERNEL);
+    struct xu_data *xu_data_t = devm_kzalloc(&state->client->dev, sizeof(struct xu_data), GFP_KERNEL);
+    int ret, sel;
+
+    ret = v4l2_ctrl_handler_init(hdl, ORB_N_CONTROLS);
+    if (ret < 0) {
+        v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
+        goto err_ctl;
+    }
+
+    /* Total gain */
+    if (state->cam_type == ORB_CAM_COLOR)
+        sel = RGB_CONTROL_SELECT;
+    else
+        sel = IR_CONTROL_SELECT;
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, sel, PU_GAIN_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_GAIN_CONTROL] = ctpu_data_t->len;
+    ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->gain)
+        ctrls->gain->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BACKLIGHT_COMPENSATION_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_BACKLIGHT_COMPENSATION_CONTROL] = ctpu_data_t->len;
+    ctrls->backlight = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BACKLIGHT_COMPENSATION,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->backlight)
+        ctrls->backlight->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_BRIGHTNESS_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_BRIGHTNESS_CONTROL] = ctpu_data_t->len;
+    ctrls->brightness = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->brightness)
+        ctrls->brightness->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_CONTRAST_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_CONTRAST_CONTROL] = ctpu_data_t->len;
+    ctrls->contrast = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->contrast)
+        ctrls->contrast->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_MODE_CONTROL, ctpu_data_t);
+    ct_ctl_len[CT_AE_MODE_CONTROL] = ctpu_data_t->len;
+    ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_EXPOSURE_AUTO,
+            V4L2_EXPOSURE_MANUAL, ~((1 << V4L2_EXPOSURE_AUTO) | (1 << V4L2_EXPOSURE_MANUAL)), V4L2_EXPOSURE_AUTO);
+    if (ctrls->auto_exp)
+        ctrls->auto_exp->flags |= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+    /* Exposure time: V4L2_CID_EXPOSURE_ABSOLUTE default unit: 100 us. */
+    if (state->cam_type != ORB_CAM_COLOR) {
+        orbbec_get_exposure_init(state,xu_data_t);
+        ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE_ABSOLUTE,
+                    xu_data_t->min_xu, xu_data_t->max_xu, xu_data_t->step_xu, xu_data_t->def_xu);
+    } else {
+        orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_EXPOSURE_TIME_ABSOLUTE_CONTROL, ctpu_data_t);
+        ct_ctl_len[CT_EXPOSURE_TIME_ABSOLUTE_CONTROL] = ctpu_data_t->len;
+        ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE_ABSOLUTE,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    }
+    if (ctrls->exposure) {
+        ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+        /* override default int type to u32 to match SKU & UVC */
+        //ctrls->exposure->type = V4L2_CTRL_TYPE_U32;
+    }
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_GAMMA_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_GAMMA_CONTROL] = ctpu_data_t->len;
+    ctrls->gamma = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAMMA,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->gamma)
+        ctrls->gamma->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_HUE_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_HUE_CONTROL] = ctpu_data_t->len;
+    ctrls->hue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HUE,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->hue)
+        ctrls->hue->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SATURATION_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_SATURATION_CONTROL] = ctpu_data_t->len;
+    ctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->saturation)
+        ctrls->saturation->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_SHARPNESS_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_SHARPNESS_CONTROL] = ctpu_data_t->len;
+    ctrls->sharpness = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->sharpness)
+        ctrls->sharpness->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_CONTROL] = ctpu_data_t->len;
+    ctrls->whitebalance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->whitebalance)
+        ctrls->whitebalance->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL] = ctpu_data_t->len;
+    ctrls->autowhitebalance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTO_WHITE_BALANCE,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->autowhitebalance)
+        ctrls->autowhitebalance->flags = orb_set_flags(ctpu_data_t->info);
+
+    orbbec_get_ctpu_init(state, PU_CONTROL_SELECT, RGB_CONTROL_SELECT, PU_POWER_LINE_FREQUENCY_CONTROL, ctpu_data_t);
+    pu_ctl_len[PU_POWER_LINE_FREQUENCY_CONTROL] = ctpu_data_t->len;
+    ctrls->powerlinefreq = v4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_POWER_LINE_FREQUENCY,
+                    ctpu_data_t->max, ~((1 << V4L2_CID_POWER_LINE_FREQUENCY_AUTO) |
+                    (1 << V4L2_CID_POWER_LINE_FREQUENCY_60HZ) | (1 << V4L2_CID_POWER_LINE_FREQUENCY_50HZ) | 
+                    (1 << V4L2_CID_POWER_LINE_FREQUENCY_DISABLED)), ctpu_data_t->def);
+    if (ctrls->powerlinefreq)
+        ctrls->powerlinefreq->flags = orb_set_flags(ctpu_data_t->info);
+    
+    orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_AE_PRIORITY_CONTROL, ctpu_data_t);
+    ct_ctl_len[CT_AE_PRIORITY_CONTROL] = ctpu_data_t->len;
+    ctrls->aepriority = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE_AUTO_PRIORITY,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->aepriority)
+        ctrls->aepriority->flags = orb_set_flags(ctpu_data_t->info);
+
+    /*
+    orbbec_get_ctpu_init(state, CT_CONTROL_SELECT, RGB_CONTROL_SELECT, CT_FOCUS_ABSOLUTE_CONTROL, ctpu_data_t);
+    ct_ctl_len[CT_FOCUS_ABSOLUTE_CONTROL] = ctpu_data_t->len;
+    ctrls->focus_absolute = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE,
+                    ctpu_data_t->min, ctpu_data_t->max, ctpu_data_t->step, ctpu_data_t->def);
+    if (ctrls->focus_absolute)
+        ctrls->focus_absolute->flags = orb_set_flags(ctpu_data_t->info);
+    */
+
+    if (hdl->error) {
+        v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
+        ret = hdl->error;
+        v4l2_ctrl_handler_free(hdl);
+        goto err_ctl;
+    }
+    /*
+    //During the initialization of the V4L2 device, the setup control will be set to the default values of the current control parameters.
+    ret = v4l2_ctrl_handler_setup(hdl);
+    if (ret < 0) {
+        dev_err(&state->client->dev,
+            "failed to set default values for controls\n");
+        v4l2_ctrl_handler_free(hdl);
+        return ret;
+    }
+    */
+    ctrls->set_date = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_set_data, NULL);
+    ctrls->set_datelen = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_set_datalen, NULL);
+    ctrls->reset_device_link = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_reset_device_link, NULL);
+    ctrls->reset_device = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_reset_device, NULL);
+    ctrls->pps_trigger = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_pps_trigger, NULL);
+    ctrls->get_link_state = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_link_state, NULL);
+    ctrls->get_date = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_data, NULL);
+    ctrls->get_pid_sn = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_pid_sn, NULL);
+    ctrls->get_imu_fps = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_imu_fps, NULL);
+    ctrls->get_version = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_version_data , NULL);
+    ctrls->get_imu_data = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_imu_data, NULL);
+    ctrls->get_metadata_place = v4l2_ctrl_new_custom(hdl,&g2r_ctrl_get_metadata_place, NULL);
+
+    state->sensor.sd.subdev.ctrl_handler = hdl;
+
+err_ctl:
+    devm_kfree(&state->client->dev, xu_data_t);
+    devm_kfree(&state->client->dev, ctpu_data_t);
+
+    return 0;
+}
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300_seri.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300_seri.c
new file mode 100644
index 000000000..e2dbc29dc
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_g300_seri.c
@@ -0,0 +1,237 @@
+/*
+ * obc_g300_seri.c - Orbbec G300 camera driver
+ *
+ * Copyright (c) 2023-2025, ORBBEC CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+//#define DEBUG
+#include <linux/kernel.h>
+#include <linux/delay.h>
+
+#include <media/gmsl-link.h>
+#include <media/obc_max9296.h>
+
+#include <media/obc_g300_priv.h>
+
+
+//-------------------------------------------------------------------------------------------
+#define MAX9295D_PIPE_EN_ADDR 		0x2
+#define MAX9295D_START_PIPE_ADDR 	0x311
+#define MAX9295D_MIPI_RX0_ADDR 		0x330
+#define MAX9295D_MIPI_RX1_ADDR 		0x331
+#define MAX9295D_CSI_PORT_SEL_ADDR 	0x308
+
+//-------------------------------------------------------------------------------------------
+#define MAX9295D_MAX_PIPES 			4
+
+#define SERI_START_ADDR             0x90
+#define TO_SERI_ADDR(A)             (SERI_START_ADDR + (A)*2)
+
+//-------------------------------------------------------------------------------------------
+#define ORBBEC_POWER_GPIOA_ADDR     0x2D6
+#define ORBBEC_POWER_GPIOB_ADDR     0x2D7
+
+//-------------------------------------------------------------------------------------------
+static int max9295d_set_registers(struct orb *state, u8 link_id, struct max_reg_pair *map, u16 count)
+{
+    return state->deser_ops->write_seri_tab(state->dser_dev, link_id, map, count);
+}
+
+static int max9295d_write_reg(struct orb *state, u8 link_id, u16 addr, u8 val)
+{
+    return state->deser_ops->write_seri_reg(state->dser_dev, link_id, addr, val);
+}
+
+int max9295d_set_pipe(struct orb *state, u8 link_id, u8 pipe_id, u8 data_type1, u8 data_type2, u8 src_vc_id)
+{
+    int err = 0;
+    static u8 pipe_x_val = 0x0;
+
+    struct max_reg_pair map_multi_pipe_en[] = {
+        {0x0315, 0x80},
+    };
+    struct max_reg_pair map_bpp8dbl[] = {
+        {0x0312, 0x0F}, // Send 8-bit pixels as 16-bit on Video Pipe X,Y,Z,U, This is double pixel mode
+    };
+    struct max_reg_pair map_pipe_control[] = {
+        {0x0314, 0x5E}, // Pipe X route data_type1
+        {0x0315, 0x52}, // Pipe X route data_type2
+        {0x0309, 0x01}, // Pipe X vc_id low byte
+        {0x030A, 0x00}, // Pipe X vc_id high byte
+        {0x031C, 0x30}, // [5]: Pipe X override enable, [4:0]: override value is 0x10 = 16bit, raw8 double 
+        {0x0102, 0x0E}, // Pipe X: LIM_HEART=1, Disable heartbeat during blanking
+    };
+
+    if (data_type1 == GMSL_CSI_DT_RAW_8 || data_type1 == GMSL_CSI_DT_EMBED
+        || data_type2 == GMSL_CSI_DT_RAW_8 || data_type2 == GMSL_CSI_DT_EMBED) {
+        map_bpp8dbl[0].val |= (1 << pipe_id);
+    } else {
+        map_bpp8dbl[0].val &= ~(1 << pipe_id);
+    }
+
+    err |= max9295d_set_registers(state, link_id, map_bpp8dbl, ARRAY_SIZE(map_bpp8dbl));
+
+    map_pipe_control[0].addr += 0x2 * pipe_id;
+    map_pipe_control[1].addr += 0x2 * pipe_id;
+    map_pipe_control[2].addr += 0x2 * pipe_id;
+    map_pipe_control[3].addr += 0x2 * pipe_id;
+    map_pipe_control[4].addr += 0x1 * pipe_id;
+    map_pipe_control[5].addr += 0x8 * pipe_id;
+
+    map_pipe_control[0].val = 0x40 | data_type1; //MSb is enable
+    map_pipe_control[1].val = 0x40 | data_type2; //MSb is enable
+    map_pipe_control[2].val = (1<<src_vc_id);
+    map_pipe_control[3].val = 0x00;
+    map_pipe_control[4].val = (data_type1 == GMSL_CSI_DT_RGB_888) ? 0x18 : 0x30;
+    map_pipe_control[5].val = 0x0E;
+
+    err |= max9295d_set_registers(state, link_id, map_pipe_control, ARRAY_SIZE(map_pipe_control));
+
+    if (pipe_id == 0)
+        pipe_x_val = map_pipe_control[1].val;
+
+    map_multi_pipe_en[0].val = 0x80 | pipe_x_val;
+    err |= max9295d_set_registers(state, link_id, map_multi_pipe_en, ARRAY_SIZE(map_multi_pipe_en));
+
+    dev_dbg(state->dser_dev, "%s: link %d done, err=%d\n", __func__, link_id, err);
+
+    return err;
+}
+
+int max9295d_release_pipe(struct orb *state, u8 pipe_id)
+{
+    return 0;
+}
+
+int max9295d_init_settings(struct orb *state, u8 link_id)
+{
+    int err = 0;
+    int i;
+    //struct max9295d *priv = dev_get_drvdata(dev);
+
+    struct max_reg_pair link_map_pipe_opt[] = {
+        // Enable all pipes
+        {MAX9295D_PIPE_EN_ADDR, 0xF3}, //0x02, 0xF3
+        // 0x06 -> 2x4,A&B, 0x05 -> 2x4,only B, 0x04 -> 2x4,only A, only for MAX9295D
+        {MAX9295D_MIPI_RX0_ADDR, 0x06}, //0x330
+        // 0x11->2 lanes, 0x33->4 lanes
+        {MAX9295D_MIPI_RX1_ADDR, 0x11}, //0x331
+        // Enable line info, Enable CSI Port A&B, Pipeline X&Z&U -> Port A Y -> Port B
+        {MAX9295D_CSI_PORT_SEL_ADDR, 0x72}, //0x308
+        // Pipeline X&Z&U from Port A Y from Port B
+        {MAX9295D_START_PIPE_ADDR, 0x2D}, //0x311
+    };
+    struct max_reg_pair gpio_cfg[] = {
+        {0x0005, 0x00}, // Enables LOCK output[7]: 0->disabled, 1->enabled; Enables ERRB output[7]: 0->disabled, 1->enabled;PU_LF1[1]: 0->: Line-fault Monitor 1 disabled, 1->enabled ;PU_LF1[0]
+        /* map_fsync_trigger, MFP6, SYNC IN, RX */
+        {0x02D0, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02D1, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+        {0x02D2, 0x02}, // GPIO_RX_ID[4:0]
+
+        /* map_sync_out, MFP9, SYNC OUT, TX */
+        {0x02D9, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02DA, 0x9C}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+        {0x02DB, 0x40}, // GPIO_RX_ID[4:0]
+
+        // map_uart_tx, #MFP11, RX 
+        {0x02DF, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable;
+        {0x02E0, 0x60}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+        {0x02E1, 0x1B},
+
+        // map_uart_rx, #MFP12, TX 
+        {0x02E2, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable;
+        {0x02E3, 0x7A}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+        {0x02E4, 0x40}, // GPIO_RX_ID[4:0]
+
+        /* map_pps, MFP7, pps, RX */
+        {0x02D3, 0x84}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02D4, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->7no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+        {0x02D5, 0x1D}, // GPIO_RX_ID[4:0]
+
+        /* map_wake, MFP3, wake, output low */ 
+        {0x02C7, 0x80}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02C8, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+
+        /* map_spi_clk, MFP0, spi_clk, output low */ 
+        {0x02BE, 0x80}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02BF, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+
+        /* map_spi_mosi, MFP1, spi_mosi, output low */ 
+        {0x02C1, 0x80}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02C2, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+
+        /* map_spi_miso, MFP2, spi_miso, output low */ 
+        {0x02C4, 0x80}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02C5, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+
+        /* map_spi_cs, MFP10, spi_cs, output low */ 
+        {0x02DC, 0x80}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]GPIO_OUT_DIS[0]:Disables GPIO output driver 0->enale,1->disable; 
+        {0x02DD, 0xA0}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+    };
+#if 1
+    u8 link_pipe_datatype[] = {
+        GMSL_CSI_DT_YUV422_8,
+        GMSL_CSI_DT_YUV422_8,
+        GMSL_CSI_DT_RAW_8,
+        GMSL_CSI_DT_RAW_8,
+        GMSL_CSI_DT_YUV422_8,
+        GMSL_CSI_DT_YUV422_8,
+    };
+#endif
+
+    if (link_id&1) {
+        link_map_pipe_opt[3].val = 0x74; // Enable line info, Enable CSI Port A&B, Pipeline X&Y&U -> Port A Z -> Port B
+        link_map_pipe_opt[4].val = 0x4B; // Pipeline X&Y&U from Port A Z from Port B
+    }
+
+    dev_info(state->dser_dev, "%s: start, dser_port=%d\n", __func__, link_id);
+
+    //mutex_lock(&priv->lock);
+
+    err |= max9295d_set_registers(state, link_id, link_map_pipe_opt, ARRAY_SIZE(link_map_pipe_opt));
+    err |= max9295d_set_registers(state, link_id, gpio_cfg, ARRAY_SIZE(gpio_cfg));
+
+#if 1
+    for (i = 0; i < MAX9295D_MAX_PIPES; i++) {
+        if(link_id&1)
+            err |= max9295d_set_pipe(state, link_id, i, link_pipe_datatype[i+2], GMSL_CSI_DT_EMBED, 3-i);
+        else
+            err |= max9295d_set_pipe(state, link_id, i, link_pipe_datatype[i], GMSL_CSI_DT_EMBED, i);	
+    }
+#endif
+    //mutex_unlock(&priv->lock);
+    dev_info(state->dser_dev, "%s: link %d done, err=%d\n", __func__, link_id, err);
+
+    return err;
+}
+
+int max9295d_set_orbbec_on(struct orb *state, u8 link_id)
+{
+    int ret = 0;
+    ret = max9295d_write_reg(state, link_id, ORBBEC_POWER_GPIOA_ADDR, 0x00);
+    if (ret)
+        dev_err(state->dser_dev, "%s:set_orbbec_on link %d fail\n", __func__, link_id);
+    
+    return ret;
+}
+
+int max9295d_set_orbbec_off(struct orb *state, u8 link_id)
+{
+    int ret = 0;
+    ret = max9295d_write_reg(state, link_id, ORBBEC_POWER_GPIOA_ADDR, 0x10);
+    if (ret)
+        dev_err(state->dser_dev, "%s:set_orbbec_off link %d fail\n", __func__, link_id);
+    
+    return ret;
+}
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_max9296.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_max9296.c
new file mode 100644
index 000000000..b483dc0dc
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_max9296.c
@@ -0,0 +1,1323 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * max9296a.c - max9296a IO Expander driver
+ *
+ * Copyright (c) 2016-2023, NVIDIA CORPORATION & AFFILIATES. All Rights Reserved.
+ */
+
+/* #define DEBUG */
+
+#include <nvidia/conftest.h>
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+
+#include <media/obc_max9296.h>
+
+
+
+/*
+ Programming Steps - Video Data Path
+Configuring the forward video path from the GMSL2 quad deserializer consists of four basic programming steps:
+ 1. Link Initialization
+ 2. Video Pipe Selection
+ 3. Video Pipe to MIPI Controller Mapping
+ 4. MIPI PHY Settings
+*/
+
+/*-----------------------------------------------------------------------------------------------
+ * 4. MIPI PHY Settings
+ *----------------------------------------------------------------------------------------------*/
+#define MAX9296_DST_CSI_MODE_ADDR 0x330 //MIPI PHY Mode Select Register: 2x4 mode, 1x4 mode, 4x2 mode
+
+#define MAX9296_PWDN_PHYS_ADDR   0x332  //MIPI PHY Enable Register: MIPI PHY 0~3, 0 = PHY in standby, 1 = PHY enabled
+#define ALLPHYS_NOSTDBY          0xF0 
+
+#define MAX9296_LANE_MAP1_ADDR   0x333 //MIPI PHY 0&1 Lane Mapping Register
+#define MAX9296_LANE_MAP2_ADDR   0x334 //MIPI PHY 3&2 Lane Mapping Register
+#define MAX9296_LANE_POLA1_ADDR  0x335 //MIPI PHY 0&1 Lane Polarity Register
+#define MAX9296_LANE_POLA2_ADDR  0x336 //MIPI PHY 3&2 Lane Polarity Register
+
+#define MAX9296_LANE_CTRL0_ADDR  0x40A //MIPI PHY 0 Lane Count / C-PHY enable Register
+#define MAX9296_LANE_CTRL1_ADDR  0x44A //MIPI PHY 1 Lane Count / C-PHY enable Register
+#define MAX9296_LANE_CTRL2_ADDR  0x48A //MIPI PHY 2 Lane Count / C-PHY enable Register
+#define MAX9296_LANE_CTRL3_ADDR  0x4CA //MIPI PHY 3 Lane Count / C-PHY enable Register
+
+#define MAX9296_PHY0_CLK_ADDR 	 0x31D //MIPI PHY 0 DPLL Freq Register
+#define MAX9296_PHY1_CLK_ADDR 	 0x320 //MIPI PHY 1 DPLL Freq Register
+#define MAX9296_PHY2_CLK_ADDR 	 0x323 //MIPI PHY 2 DPLL Freq Register
+#define MAX9296_PHY3_CLK_ADDR 	 0x326 //MIPI PHY 2 DPLL Freq Register
+
+// #define MAX9296_CSI_OUT_EN      0x40B //CSI_OUT_EN: CSI output enabled, en:0x2, dis:0x0
+
+/*-----------------------------------------------------------------------------------------------
+ * 3. Video Pipe to MIPI Controller Mapping
+ *----------------------------------------------------------------------------------------------*/
+#define MAX9296_TX11_PIPE_X_EN_ADDR   0x40B //Mapping Enable Low Byte, 0~7
+#define MAX9296_TX11_PIPE_X_EN_H_ADDR 0x40C //Mapping Enable High Byte, 8~15
+
+#define MAX9296_PIPE_X_SRC_0_MAP_ADDR 0x40D //MAP_SRC_0 Register: VC+DT
+#define MAX9296_PIPE_X_DST_0_MAP_ADDR 0x40E //MAP_DES_0 Register: VC+DT
+#define MAX9296_PIPE_X_SRC_1_MAP_ADDR 0x40F //MAP_SRC_1 Register: VC+DT
+#define MAX9296_PIPE_X_DST_1_MAP_ADDR 0x410 //MAP_DES_1 Register: VC+DT
+#define MAX9296_PIPE_X_SRC_2_MAP_ADDR 0x411 //MAP_SRC_2 Register: VC+DT
+#define MAX9296_PIPE_X_DST_2_MAP_ADDR 0x412 //MAP_DES_2 Register: VC+DT
+#define MAX9296_PIPE_X_SRC_3_MAP_ADDR 0x413 //MAP_SRC_3 Register: VC+DT
+#define MAX9296_PIPE_X_DST_3_MAP_ADDR 0x414 //MAP_DES_3 Register: VC+DT
+
+#define MAX9296_TX45_PIPE_X_DST_CTRL_ADDR  0x42D //MAP Destination Controller Register: 0~3
+#define MAX9296_TX45_PIPE_X_DST_CTRL2_ADDR 0x42E //MAP Destination Controller Register: 4~7
+
+//--------------------------------------------------------------------
+// others
+#define MAX9296_PIPE_X_ST_SEL_ADDR  0x50 //RX packets with selected stream ID, add b7: RX_CRC_EN
+
+#define MAX9296_CTRL0_ADDR 0x10   //get link status
+#define MAX9296_CTRL2_ADDR 0x12
+#define CTRL0_RESET_ALL     0x80  //b[7]: 1->RESET_ALL, Chip reset
+#define CTRL0_RESET_LINK    0x40  //b[6]: reset link
+#define CTRL0_RESET_ONESHOT 0x20  //b[5]: reset oneshot, keep register
+#define CTRL0_LINK_SPLITTER_MODE 0x3 //Enable plitter mode
+#define CTRL0_REG_ENABLE 	0x4 //Enable VDD LDO regulator
+
+#define MAX9296_CTRL3_ADDR 0x13 //get link status
+#define CTRL3_LINK_LOCKED  0x08 //b[3], GMSL2 link locked
+
+#define MAX9296_LINK_RESET_ADDR 0x10
+/*-----------------------------------------------------------------------------------------------
+ * data defines
+ *----------------------------------------------------------------------------------------------*/
+/* MIPI PHY Mode Select */
+#define MAX9296_CSI_MODE_4X2 0x1  //4x2lanes
+#define MAX9296_CSI_MODE_1X4 0x2
+#define MAX9296_CSI_MODE_2X4 0x4  //2x4lanes
+
+//----------------------------------------------------------
+#define MAX9296_MAX_PIPES	4
+#define MAX9296_MAX_LINKS   2
+
+//----------------------------------------------------------
+#define SERI_DEFAULT_I2C_ADDRESS    0x40
+
+//----------------------------------------------------------
+#define TO_SERI_ADDR(A)	(priv->seri_start_addr + (A))
+#define TO_SNR_ADDR(A)	(priv->snr_proxy_addr + (A))
+
+//--------------------------------------------------------------------------------------
+struct index_reg_8 {
+	u8 source;
+	u16 addr;
+	u8 val;
+};
+
+struct max9296a {
+	struct mutex lock;
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	u8 csi_mode;
+	u8 links_map;
+	u8 links_init_flag;
+	u8 pipes_map;
+	u8 index;
+	u8 deser_addr; //deser address
+	u8 seri_start_addr; //serializer start address
+	u8 snr_proxy_addr;  // sensor proxy address
+	u8 snr_real_addr;   // sensor real address
+	int reset_gpio;
+	int fsync_mfp_x;
+	int pps_mfp_x;
+	int vdd_supply_1v2;
+	int splitter_enabled;
+};
+
+//--------------------------------------------------------------------------------------
+static int _max9296a_write_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 val)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	struct i2c_client *i2c_client;
+	int err;
+
+	i2c_client = priv->i2c_client;
+
+	i2c_client->addr = i2c_addr;
+	err = regmap_write(priv->regmap, addr, val);
+	i2c_client->addr = priv->deser_addr;
+	if (err)
+		dev_err(dev, "%s err: 0x%02x, 0x%04x = 0x%02x\n", __func__, i2c_addr, addr, val);
+
+	usleep_range(100, 110);
+
+	dev_dbg(dev, "[%s] wr reg: 0x%02x, 0x%04x = 0x%02x\n", (i2c_addr == priv->deser_addr) ? "dser" : "seri", i2c_addr, addr, val);
+
+	return err;
+}
+
+int max9296a_write_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 val)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int ret;
+
+	if (priv == NULL)
+		return -1;
+
+	mutex_lock(&priv->lock);
+	ret = _max9296a_write_reg_with_addr(dev, i2c_addr, addr, val);
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(max9296a_write_reg_with_addr);
+
+int max9296a_write_tab_with_addr(struct device *dev, u8 i2c_addr, struct max_reg_pair tab[], u16 size)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	struct i2c_client *i2c_client;
+	int i, err;
+
+	if (priv == NULL)
+		return -1;
+
+	mutex_lock(&priv->lock);
+
+	i2c_client = priv->i2c_client;
+
+	i2c_client->addr = i2c_addr;
+	for (i = 0; i < size; i++) {
+		err = regmap_write(priv->regmap, tab[i].addr, tab[i].val);
+		if (err) {
+			dev_err(dev, "%s: error, 0x%02x --> 0x%04x = 0x%02x\n", __func__, i2c_addr, tab[i].addr, tab[i].val);
+			break;
+		}
+		usleep_range(100, 110);
+		dev_dbg(dev, "[%s] wr tab: 0x%02x, 0x%04x = 0x%02x\n", (i2c_addr == priv->deser_addr) ? "dser" : "seri", i2c_addr, tab[i].addr, tab[i].val);
+	}
+	i2c_client->addr = priv->deser_addr;
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296a_write_tab_with_addr);
+
+int max9296a_read_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 *val)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	struct i2c_client *i2c_client;
+	unsigned int value = 0;
+	int err;
+
+	if (priv == NULL)
+		return -1;
+
+	mutex_lock(&priv->lock);
+
+	i2c_client = priv->i2c_client;
+
+	i2c_client->addr = i2c_addr;
+	err = regmap_read(priv->regmap, addr, &value);
+	i2c_client->addr = priv->deser_addr;
+	if (err)
+		dev_err(dev, "%s: 0x%02x, 0x%04x = 0x%02x\n", __func__, i2c_addr, addr, value);
+
+	*val = value;
+
+	usleep_range(100, 110);
+
+	mutex_unlock(&priv->lock);
+
+	dev_dbg(dev, "[cwd]dser rd reg: 0x%04x, 0x%02x = 0x%02x\n", i2c_addr, addr, value);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296a_read_reg_with_addr);
+
+int max9296a_write_seri_reg(struct device *dev, u8 link_id, u16 addr, u8 val)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	return max9296a_write_reg_with_addr(dev, TO_SERI_ADDR(link_id), addr, val);
+}
+EXPORT_SYMBOL(max9296a_write_seri_reg);
+
+int max9296a_write_seri_tab(struct device *dev, u8 link_id, struct max_reg_pair buf[], u16 size)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	return max9296a_write_tab_with_addr(dev, TO_SERI_ADDR(link_id), buf, size);
+}
+EXPORT_SYMBOL(max9296a_write_seri_tab);
+
+int max9296a_write_sensor(struct device *dev, u8 link_id, void *data, u16 length)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	struct i2c_msg send_msg = {
+		.addr = TO_SNR_ADDR(link_id),
+		.flags = 0,
+		.buf = (uint8_t*)data,
+		.len = length,
+	};
+	int error;
+
+	mutex_lock(&priv->lock);
+	error = i2c_transfer(priv->i2c_client->adapter, &send_msg, 1);
+	mutex_unlock(&priv->lock);
+	if (error != 1) {
+		dev_err(dev, "\n i2c_transfer error \n");
+		return -1;
+	}
+
+	// dev_info(dev, "[snr] i2c wr: %x, %d\n", send_msg.addr, length);
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296a_write_sensor);
+
+int max9296a_read_sensor(struct device *dev, u8 link_id, void *data, u16 length)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	struct i2c_msg recv_msg = {
+		.addr = TO_SNR_ADDR(link_id),
+		.flags = I2C_M_RD,
+		.buf = data,
+		.len = length,
+	};
+	int error;
+
+	mutex_lock(&priv->lock);
+	error = i2c_transfer(priv->i2c_client->adapter, &recv_msg, 1);
+	// dev_info(dev, "orb: i2c read: %x, %d\n", client->addr, length);
+	mutex_unlock(&priv->lock);
+	if (error != 1) {
+		dev_err(dev, "\n i2c_read_orbbec error \n");
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296a_read_sensor);
+
+static int max9296a_write_reg(struct device *dev, u16 addr, u8 val)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+
+	int err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s err: 0x%04x = 0x%02x\n", __func__, addr, val);
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+
+	dev_dbg(dev, "[dser] 0x%02x i2c wr: 0x%04x = 0x%02x\n", priv->i2c_client->addr, addr, val);
+
+	return err;
+}
+
+static int max9296a_read_reg(struct device *dev, u16 addr, u8 *val)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	unsigned int value;
+
+	int err = regmap_read(priv->regmap, addr, &value);
+	if (err)
+		dev_err(dev, "%s err: 0x%04x\n", __func__, addr);
+
+	*val = value&0xff;
+
+	// delay before next i2c command as required for SERDES link 
+	usleep_range(100, 110);
+
+	dev_dbg(dev, "[dser] 0x%02x  i2c rd: 0x%04x = 0x%02x\n", priv->i2c_client->addr, addr, value);
+
+	return err;
+}
+
+static int max9296a_set_registers(struct device *dev, struct max_reg_pair *map, u16 count)
+{
+	int err = 0;
+	u16 i;
+
+	for (i = 0; i < count; i++) {
+		err = max9296a_write_reg(dev, map[i].addr, map[i].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+#if 0
+static int max9296a_write_table(struct device *dev, const struct index_reg_8 table[], u16 size)
+{
+	int ret, retry = 5, i = 0;
+
+	for (i = 0; i < size; i++) {
+		ret = _max9296a_write_reg_with_addr(dev, table[i].source, table[i].addr, table[i].val);
+		if (ret) {
+			retry--;
+			if (retry == 0)
+				return -1;
+			dev_warn(dev, "max9296a wr tab: retry = %d\n", retry);
+			msleep(20);
+			continue;
+		}
+		if (0x0000 == table[i].addr || 0x0010 == table[i].addr)
+			msleep(200);
+		retry = 5;
+	}
+	return 0;
+}
+#endif
+
+static int max9295d_set_src_id(struct device *dev, int index)
+{
+    u8 tx_src_id[] = {
+        0x6B, 0x10, //what?
+        0x73, 0x11, //what?
+
+        0x7B, 0x30, //CFGI INFOFR
+        0x83, 0x30, //CFGL SPI
+        0x93, 0x30, //CFGL GPIO
+        0x9B, 0x30, 
+        0xA3, 0x30, //CFGL IIC_X
+        0xAB, 0x30, //CFGL IIC_Y
+        0x8B, 0x30, //CFGC CC
+    };
+
+    int i, err;
+	struct max9296a *priv = dev_get_drvdata(dev);
+
+    for (i = 0; i < ARRAY_SIZE(tx_src_id); i += 2) {
+        /* update address overrides */
+		tx_src_id[i+1] += index;
+		err = _max9296a_write_reg_with_addr(dev, TO_SERI_ADDR(index), tx_src_id[i], tx_src_id[i+1]);
+        if(err)
+            break;
+    }
+
+    dev_info(dev, "%s: done, err=%d\n", __func__, err);
+
+    return err;
+}
+
+u8 max9296a_get_link_map(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	return priv->links_map;
+}
+EXPORT_SYMBOL(max9296a_get_link_map);
+
+u8 max9296a_get_link_init_flag(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	return priv->links_init_flag;
+}
+EXPORT_SYMBOL(max9296a_get_link_init_flag);
+
+void max9296a_set_link_init_flag(struct device *dev, u8 link)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	priv->links_init_flag &= ~(1 << link);
+}
+EXPORT_SYMBOL(max9296a_set_link_init_flag);
+
+int max9296a_reset_oneshot(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+
+	if (priv->splitter_enabled) {
+		if(priv->vdd_supply_1v2 == 1) {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, CTRL0_RESET_ONESHOT|CTRL0_LINK_SPLITTER_MODE|CTRL0_REG_ENABLE);
+		}else {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, CTRL0_RESET_ONESHOT|CTRL0_LINK_SPLITTER_MODE);
+		}
+	} else {
+		if(priv->vdd_supply_1v2 == 1) {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31|CTRL0_REG_ENABLE);  //autolink mode
+		}else {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31);  //autolink mode
+		}
+	}
+
+	mutex_unlock(&priv->lock);
+
+	/* delay to settle link */
+	msleep(100);
+	return err;
+}
+EXPORT_SYMBOL(max9296a_reset_oneshot);
+
+#if 1
+#if 0
+/* Video channel is locked and outputting valid video data */
+u8 max9296a_check_video_channel_lock(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	u16 addr_tab[8] = {0x01DC, 0x01FC, 0x021C, 0x023C}; //, 0x025C, 0x027C, 0x029C, 0x02BC}; //pipe 0~7
+	int i, ret;
+	u8 val = 0, ch_lock = 0;
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_PIPES; i++) {
+		val = 0;
+		ret = max9296a_read_reg(dev, addr_tab[i], &val); //pipe 0~7
+		if(ret)
+			break;
+		if(val&0x1) //bit0
+			ch_lock |= (1<<i);
+	}
+    mutex_unlock(&priv->lock);
+
+	if(ret)
+		ch_lock = 0;
+
+	dev_info(dev, "check channel lock: 0x%x\n", ch_lock);
+
+	return ch_lock;
+}
+EXPORT_SYMBOL(max9296a_check_video_channel_lock);
+#endif
+
+u8 max9296a_check_pipe_lock(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int i, ret;
+	u16 addr_tb[] = {0x108, 0x11A, 0x12C, 0x13E}; //, 0x150, 0x168, 0x17A, 0x18C}; //pipe 0~3
+	u8 val = 0, pipe_lock = 0;
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_PIPES; i++) {
+		val = 0;
+		ret = max9296a_read_reg(dev, addr_tb[i], &val); //video pipeline locked 0~3
+		if(ret)
+			break;
+		if(val&0x40) //bit6
+			pipe_lock |= (1<<i);
+	}
+    mutex_unlock(&priv->lock);
+
+	if(ret)
+		pipe_lock = -1;
+
+	dev_info(dev, "check pipe lock map: 0x%02x\n", pipe_lock);
+
+	return pipe_lock;
+}
+EXPORT_SYMBOL(max9296a_check_pipe_lock);
+#endif
+
+#define MAX9296_CSI_OUT_EN_ADDR  0x313
+#define CSI_OUT_EN  0x02
+#define CSI_OUT_DIS 0x00
+
+/* transform serializer i2c address */
+static int max9296a_seri_i2c_addr_trans(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int i, ret;
+	u8 links = 0;
+
+	mutex_lock(&priv->lock);
+
+	for (i = 0; i < MAX9296_MAX_LINKS; i++) { //link A~D
+		ret = max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, 1<<i); //select link A / B
+		if(ret)
+			break;
+		ret = max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, (1<<i)|CTRL0_RESET_ONESHOT);
+		if(ret)
+			break;
+
+		msleep(200);
+
+		ret = _max9296a_write_reg_with_addr(dev, SERI_DEFAULT_I2C_ADDRESS, 0x00, TO_SERI_ADDR(i)<<1);
+		if(ret) {
+			ret = _max9296a_write_reg_with_addr(dev,  TO_SERI_ADDR(i), 0x00, TO_SERI_ADDR(i)<<1);
+			if(ret)
+				continue;
+		}
+
+		max9295d_set_src_id(dev, i);
+		links |= 1<<i;
+		dev_info(dev, "transf seri i2c addr, 0x%02x, 0x40 -> 0x%02x\n", i, TO_SERI_ADDR(i));
+	}
+	priv->links_map = links;
+	priv->links_init_flag = links;
+	if(links == 0x3) {
+		if(priv->vdd_supply_1v2 == 1) {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, CTRL0_RESET_ONESHOT|CTRL0_LINK_SPLITTER_MODE|CTRL0_REG_ENABLE);
+		}else {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, CTRL0_RESET_ONESHOT|CTRL0_LINK_SPLITTER_MODE);
+		}
+		priv->splitter_enabled = 1;
+		dev_info(dev, "spiliter mode enable \n");
+		msleep(100);
+	}
+ 	else {
+		if(priv->vdd_supply_1v2 == 1) {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31|CTRL0_REG_ENABLE);  //autolink mode
+		}else {
+			max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31);  //autolink mode
+		}
+		dev_info(dev, "autolink mode enable \n");
+		msleep(100);
+	}
+
+	if(priv->vdd_supply_1v2 == 1) {
+		//Enable regulator manual mode to allow regulator to be forced on or off via REG_ENABLE
+		max9296a_write_reg(dev, MAX9296_CTRL2_ADDR, 0x10);
+		msleep(300);
+	}
+
+	mutex_unlock(&priv->lock);
+
+	return 0; //ret;
+}
+
+
+#define ORBBEC_POWER_GPIOA_ADDR 0x2D6
+#define ORBBEC_POWER_GPIOB_ADDR 0x2D7
+#if 0
+static int max9296a_set_sensor_on(struct device *dev, int link_id)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int ret = _max9296a_write_reg_with_addr(dev, TO_SERI_ADDR(link_id), ORBBEC_POWER_GPIOA_ADDR, 0x00);
+	if (ret)
+		dev_err(dev, "%s:set_sensor_on fail\n", __func__);
+
+	return ret;
+}
+
+static int max9296a_set_all_links_sensor_on(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i = 0;
+	if(priv->links_map == 0) return err;
+	/* power on */
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_LINKS; i++) { //link A~B
+		if(priv->links_map & (1<<i)) {
+			err = max9296a_set_sensor_on(dev, i);
+			if(err) {
+				dev_err(dev, "max9296a power on MX6800 :link %d failed \n", i);
+				continue;
+				//break;
+			}
+			dev_info(dev, "%s power on MX6800 :link %d success\n", __func__, i);
+		}
+	}
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "%s : sleep 3(s) after power on MX6800\n", __func__);
+	msleep(3000);
+	return err;
+}
+#endif
+
+static int max9296a_set_sensor_off(struct device *dev, int link_id)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int ret = _max9296a_write_reg_with_addr(dev, TO_SERI_ADDR(link_id), ORBBEC_POWER_GPIOA_ADDR, 0x10);
+	if (ret)
+		dev_err(dev, "%s:set_sensor_off fail\n", __func__);
+
+	return ret;
+}
+
+static int max9296a_set_all_links_sensor_off(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i = 0;
+	if(priv->links_map == 0) return err;
+	/* power on */
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_LINKS; i++) { //link A~B
+		if(priv->links_map & (1<<i)) {
+			err = max9296a_set_sensor_off(dev, i); //power off
+			if(err) {
+				dev_err(dev, "max9296a power off MX6800 : link %d failed \n", i);
+				continue;
+				//break;
+			}
+			dev_info(dev, "%s power off MX6800 : link %d success\n", __func__, i);
+			msleep(800); //At least 800 milliseconds
+		}
+	}
+	mutex_unlock(&priv->lock);
+
+	msleep(2000);
+	return err;
+}
+
+/* set sensor proxy address */
+static int max9296a_set_snr_proxy_addr(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int i, err = 0;
+    if(priv->links_map == 0) return err;
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_LINKS; i++) { //link A~D
+		int ret = 0;
+		if(priv->links_map & (1<<i)) {
+			ret  = _max9296a_write_reg_with_addr(dev, TO_SERI_ADDR(i), 0x0042, (priv->snr_proxy_addr + i)<<1);
+			ret += _max9296a_write_reg_with_addr(dev, TO_SERI_ADDR(i), 0x0043, priv->snr_real_addr<<1);
+			if(ret) {
+				dev_err(dev, "max9296a set_snr_proxy_addr failed %d\n", ret);
+				err = ret;
+				continue;
+			}
+		}
+	}
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static int __max9296a_set_pipe(struct device *dev, u8 link_id, u8 pipe_id, 
+				u8 data_type1, u8 data_type2, u8 src_vc_id, u8 dst_vc_id)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int i, err;
+	u8 mapping2csi = 0x55, mappings_en = 0x0F;
+
+	struct max_reg_pair map_pipe_control[] = {
+		/* Enable 4 mappings for Pipe X */
+		{MAX9296_TX11_PIPE_X_EN_ADDR,   0x0F}, //0x40B
+		/* Map data_type1 on vc_id */
+		{MAX9296_PIPE_X_SRC_0_MAP_ADDR, 0x1E}, //0x40D
+		{MAX9296_PIPE_X_DST_0_MAP_ADDR, 0x1E},
+		/* Map frame_start on vc_id */
+		{MAX9296_PIPE_X_SRC_1_MAP_ADDR, 0x00}, //0x40F
+		{MAX9296_PIPE_X_DST_1_MAP_ADDR, 0x00},
+		/* Map frame end on vc_id */
+		{MAX9296_PIPE_X_SRC_2_MAP_ADDR, 0x01}, //0x411
+		{MAX9296_PIPE_X_DST_2_MAP_ADDR, 0x01},
+		/* Map data_type2 on vc_id */
+		{MAX9296_PIPE_X_SRC_3_MAP_ADDR, 0x12}, //0x413
+		{MAX9296_PIPE_X_DST_3_MAP_ADDR, 0x12},
+		/* All mappings to PHY1 (master for port A) */
+		{MAX9296_TX45_PIPE_X_DST_CTRL_ADDR, 0x55}, //0x42D
+		/* Disable Heartbeat Mode, I's use for DSI */
+		{0x0100, 0x23}, //0x23, SEQ_MISS_EN=0, LINE_CRC_EN=0, DIS_PKT_DET=1
+	};
+
+	for (i = 0; i < 10; i++)
+		map_pipe_control[i].addr += 0x40 * pipe_id;
+	map_pipe_control[10].addr += 0x12 * pipe_id;
+
+	if(priv->csi_mode == MAX9296_CSI_MODE_2X4)
+		mapping2csi = (link_id > 1) ? 0xAA : 0x55;
+	else
+		mapping2csi = 0x55*link_id;
+
+	if(data_type2 == 0) {
+		mapping2csi &= 0x3f;
+		mappings_en = 0x07;
+	}
+
+	map_pipe_control[0].val = mappings_en;
+	map_pipe_control[1].val = (src_vc_id << 6) | data_type1;
+	map_pipe_control[2].val = (dst_vc_id << 6) | data_type1;
+	map_pipe_control[3].val = (src_vc_id << 6) | 0x00;
+	map_pipe_control[4].val = (dst_vc_id << 6) | 0x00;
+	map_pipe_control[5].val = (src_vc_id << 6) | 0x01;
+	map_pipe_control[6].val = (dst_vc_id << 6) | 0x01;
+	map_pipe_control[7].val = (src_vc_id << 6) | data_type2;
+	map_pipe_control[8].val = (dst_vc_id << 6) | data_type2;
+	map_pipe_control[9].val = mapping2csi;
+	map_pipe_control[10].val = 0x23;
+
+	dev_dbg(dev, "set pipe start\n");
+
+	err = max9296a_set_registers(dev, map_pipe_control, ARRAY_SIZE(map_pipe_control));
+
+	dev_dbg(dev, "set pipe %s!\n", err ? "failed" : "success");
+
+	return err;
+}
+
+int max9296a_set_pipe(struct device *dev, u8 link_id, u8 pipe_id,
+		     u8 data_type1, u8 data_type2, u8 src_vc_id, u8 dst_vc_id)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int err = 0;
+	// u8 pipe_lock = 0;
+
+	if (pipe_id > (MAX9296_MAX_PIPES - 1)) {
+		dev_err(dev, "%s, input pipe_id: %d exceed max9296a max pipes\n", __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "%s pipe_id:%d, dt1:0x%x, dt2:0x%x, src_vc:0x%x, dst_vc:0x%x\n",
+		__func__, pipe_id, data_type1, data_type2, src_vc_id, dst_vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max9296a_set_pipe(dev, link_id, pipe_id, data_type1, data_type2, src_vc_id, dst_vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	// msleep(10);
+	// pipe_lock = max9296a_check_pipe_lock(dev);
+	// dev_info(dev, "%s pipe lock: 0x%x\n", __func__, pipe_lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296a_set_pipe);
+
+int max9296a_init_settings(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	struct max_reg_pair map_phy_opt_2x4[] = //2 x 4 Lane
+	{
+		// {0x1458, 0x28}, // PHY A Optimization
+		// {0x1459, 0x68}, // PHY A Optimization
+		// {0x1558, 0x28}, // PHY B Optimization
+		// {0x1559, 0x68}, // PHY B Optimization
+		
+		/* MIPI D-PHY Config */
+		// {MAX9296_DST_CSI_MODE_ADDR, (MAX9296_CSI_MODE_2X4 | 0x20)}, //0x8A0
+		// {MAX9296_LANE_MAP1_ADDR, 0xE4}, //0x8A3, Default 4x2 lane mapping
+		// {MAX9296_LANE_MAP2_ADDR, 0xE4}, //0x8A4, Default 4x2 lane mapping
+
+		/* 4 lanes on port A,  0x40 -> 2 lanes, 0xC0 -> 4 lanes */
+		// {MAX9296_LANE_CTRL0_ADDR, 0xC0}, //0x90A, MIPI PHY0
+		{MAX9296_LANE_CTRL1_ADDR, 0xD0}, //0x94A, MIPI PHY1, as Master controller for A 4lane
+		// {MAX9296_LANE_CTRL2_ADDR, 0xC0}, //0x98A, MIPI PHY2, as Master controller for B 4lane
+		// {MAX9296_LANE_CTRL3_ADDR, 0xC0}, //0x9CA, MIPI PHY3
+
+		/* 1500Mbps/lane on port A */
+		// {MAX9296_PHY0_CLK_ADDR, 0x2F}, //0x415, MIPI PHY0
+		{MAX9296_PHY1_CLK_ADDR, 0x2F}, //0x418, MIPI PHY1, this
+		// {MAX9296_PHY2_CLK_ADDR, 0x2F}, //0x41B, MIPI PHY2, this
+		// {MAX9296_PHY3_CLK_ADDR, 0x2F}, //0x41E, MIPI PHY3
+
+		/* Do not un-double 8bpp (Un-double 8bpp data) */
+		//{0x031C, 0xF0}, //Pipe0~3, Process BPP = 8 as 16-bit color
+		//{0x041F, 0xF0}, //Enable 8-bit write alternate map to RAMs for pipeline X~U
+	
+		/* 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8 */
+		// {0x0433, 0x10}, //MIPI TX0
+		{0x0473, 0x10}, //0x10, MIPI TX1
+		// {0x04B3, 0x10}, //0x10, MIPI TX2
+		// {0x04F3, 0x10}, //MIPI TX3
+
+		{MAX9296_PWDN_PHYS_ADDR, ALLPHYS_NOSTDBY}, //0x8A2, All PHYs not in standby
+		{MAX9296_CSI_OUT_EN_ADDR, CSI_OUT_EN},  // (CSI_OUT_EN): CSI output enabled
+	};
+
+	mutex_lock(&priv->lock);
+
+	if(priv->csi_mode == MAX9296_CSI_MODE_2X4)
+		err |= max9296a_set_registers(dev, map_phy_opt_2x4, ARRAY_SIZE(map_phy_opt_2x4));
+
+	mutex_unlock(&priv->lock);
+
+	if (err == 0)
+		dev_info(dev, "%s done\n", __func__);
+	else
+		dev_err(dev, "%s failed, err %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296a_init_settings);
+
+int max9296a_init_tx_gpio(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	struct max_reg_pair map_disable_uart1[] = {
+		{0x0003, 0x40}, // LOCK_CFG[7]: 0->GMSL2 link locked, 1->GMSL2 link locked and MIPI output started; UART_1_EN[4]:0->disable, 1->enable
+		{0x0B08, 0x20},
+	};
+	struct max_reg_pair map_fsync_trigger[] = {
+		/* MFP10 SYNC IN, Tx*/
+		{0x02CE, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; GPIO_OUT_DIS[0]: 1->disable
+		{0x02CF, 0xA2}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	};
+
+	struct max_reg_pair map_pps_trigger[] = {
+		/* MFP9 pps, TX */
+		{0x02CB, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; 
+		{0x02CC, 0x1D}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+	};
+
+	mutex_lock(&priv->lock);
+
+	// FSYNC Trigger
+	if(priv->fsync_mfp_x == 5 || priv->fsync_mfp_x == 6 || priv->pps_mfp_x == 5 || priv->pps_mfp_x == 6)
+		err |= max9296a_set_registers(dev, map_disable_uart1,
+				     ARRAY_SIZE(map_disable_uart1));
+
+	map_fsync_trigger[0].addr = 0x2B0 + priv->fsync_mfp_x * 3;
+	map_fsync_trigger[1].addr = map_fsync_trigger[0].addr + 1;
+	err |= max9296a_set_registers(dev, map_fsync_trigger,
+				     ARRAY_SIZE(map_fsync_trigger));
+	
+	// PPS Trigger
+	map_pps_trigger[0].addr = 0x2B0 + priv->pps_mfp_x * 3;
+	map_pps_trigger[1].addr = map_pps_trigger[0].addr + 1;
+	err |= max9296a_set_registers(dev, map_pps_trigger,
+				     ARRAY_SIZE(map_pps_trigger));
+
+	mutex_unlock(&priv->lock);
+
+	if (err == 0)
+		dev_info(dev, "%s done\n", __func__);
+	else
+		dev_err(dev, "%s failed, err %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296a_init_tx_gpio);
+
+int max9296a_reset_dev(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&priv->lock);
+	ret = max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, CTRL0_RESET_ALL); //reset all
+	mutex_unlock(&priv->lock);
+
+	msleep(100); /* delay to settle reset */
+
+	return ret;
+}
+EXPORT_SYMBOL(max9296a_reset_dev);
+
+int max9296a_get_link_state(struct device *dev, u8 link_id, int *value)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int ret;
+	u8 val = 0;
+
+	mutex_lock(&priv->lock);
+	ret = max9296a_read_reg(dev, MAX9296_CTRL3_ADDR, &val);
+	if (ret)
+		dev_err(dev, "%s:failed\n", __func__);
+	*value = (val & CTRL3_LINK_LOCKED) ? 1 : 0; //b[3]: gmsl2  link locked, for linkA & B
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "max9296a register 0x%04x= 0x%02x\n", MAX9296_CTRL3_ADDR, val);
+
+	return ret;
+}
+EXPORT_SYMBOL(max9296a_get_link_state);
+
+
+int max9296a_get_available_pipe_id(struct device *dev, int dst_vc_id)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+	int pipe_id = -1;
+
+	mutex_lock(&priv->lock);
+
+#if 0
+	for (int i = 0; i < MAX9296_MAX_PIPES; i++) {
+		if(!(priv->pipes_map & (1<<i))) {
+			priv->pipes_map |= (1<<i);
+			pipe_id = i;
+			break;
+		}
+	}
+#else
+	if(!(priv->pipes_map & (1<<dst_vc_id))) {
+		priv->pipes_map |= (1<<dst_vc_id);
+		pipe_id = dst_vc_id;
+	}
+#endif
+
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "request pipe id: map=0x%02x, id=%d\n", priv->pipes_map, pipe_id);
+
+	return pipe_id;
+}
+EXPORT_SYMBOL(max9296a_get_available_pipe_id);
+
+int max9296a_release_pipe(struct device *dev, u8 link_id, u8 pipe_id)
+{
+#if 1
+	struct max9296a *priv = dev_get_drvdata(dev);
+
+	if (link_id >= MAX9296_MAX_LINKS || pipe_id < 0 || pipe_id >= MAX9296_MAX_PIPES)
+		return -EINVAL;
+
+	// mutex_lock(&priv->lock);
+
+	// max9296a_write_reg(dev, MAX9296_CTRL0_ADDR, CTRL0_RESET_ONESHOT); //link reset oneshot
+
+	priv->pipes_map &= ~(1<<pipe_id);
+
+	// mutex_unlock(&priv->lock);
+
+	dev_info(dev, "release pipe id, 0x%02x\n", priv->pipes_map);
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296a_release_pipe);
+
+static int max9296a_stats_show(struct seq_file *s, void *data)
+{
+	return 0;
+}
+
+static int max9296a_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max9296a_stats_show, inode->i_private);
+}
+
+static ssize_t max9296a_debugfs_write(struct file *s,
+				const char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct max9296a *priv = ((struct seq_file *)s->private_data)->private;
+	struct i2c_client *i2c_client = priv->i2c_client;
+
+	char buf[255];
+	int buf_size;
+	// u8 val = 0;
+
+	if (!user_buf || count <= 1)
+		return -EFAULT;
+
+	memset(buf, 0, sizeof(buf));
+	buf_size = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (buf[0] == 'd') {
+		dev_info(&i2c_client->dev, "%s, set daymode\n", __func__);
+		// max9296a_read_reg(&i2c_client->dev, 0x0010, &val);
+		return count;
+	}
+
+	if (buf[0] == 'n') {
+		dev_info(&i2c_client->dev, "%s, set nightmode\n", __func__);
+		return count;
+	}
+
+	return count;
+}
+
+
+static const struct file_operations max9296a_debugfs_fops = {
+	.open = max9296a_debugfs_open,
+	.read = seq_read,
+	.write = max9296a_debugfs_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+int max9296a_power_on(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+
+	if (priv->reset_gpio > 0) {
+
+		gpio_direction_output(priv->reset_gpio, 1);
+
+		if(gpio_cansleep(priv->reset_gpio))
+			gpio_set_value_cansleep(priv->reset_gpio, 0);
+		else
+			gpio_set_value(priv->reset_gpio, 0);
+	
+		usleep_range(30, 50);
+
+		if(gpio_cansleep(priv->reset_gpio))
+			gpio_set_value_cansleep(priv->reset_gpio, 1);
+		else
+			gpio_set_value(priv->reset_gpio, 1);
+
+		msleep(100);
+		dev_info(dev, "%s\n", __func__);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296a_power_on);
+
+void max9296a_power_off(struct device *dev)
+{
+	struct max9296a *priv = dev_get_drvdata(dev);
+
+	if (priv->reset_gpio > 0) {
+		if(gpio_cansleep(priv->reset_gpio))
+			gpio_set_value_cansleep(priv->reset_gpio, 0);
+		else
+			gpio_set_value(priv->reset_gpio, 0);
+		dev_info(dev, "%s\n", __func__);
+	}
+}
+EXPORT_SYMBOL(max9296a_power_off);
+
+static int max9296a_debugfs_init(const char *dir_name,
+				struct dentry **d_entry,
+				struct dentry **f_entry,
+				struct max9296a *priv)
+{
+	struct dentry  *dp, *fp;
+	char dev_name[20];
+	struct i2c_client *i2c_client = priv->i2c_client;
+	int err = 0;
+
+	err = snprintf(dev_name, sizeof(dev_name), "max9296a_%d", priv->index);
+	if (err < 0)
+		return -EINVAL;
+
+	dp = debugfs_create_dir(dev_name, NULL);
+	if (dp == NULL) {
+		dev_err(&i2c_client->dev, "%s: debugfs create dir failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	fp = debugfs_create_file("max9296a", 0644, dp, priv, &max9296a_debugfs_fops);
+	if (!fp) {
+		dev_err(&i2c_client->dev, "%s: debugfs create file failed\n", __func__);
+		debugfs_remove_recursive(dp);
+		return -ENOMEM;
+	}
+
+	if (d_entry)
+		*d_entry = dp;
+	if (f_entry)
+		*f_entry = fp;
+
+	return 0;
+}
+
+static const struct of_device_id max9296a_of_match[] = {
+	{ .compatible = "maxim,obc_max9296", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, max9296a_of_match);
+
+static int max9296a_parse_dt(struct max9296a *priv, struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	const struct of_device_id *match;
+	const char *str_value;
+	int value, err = 0;
+
+	if (!node)
+		return -EINVAL;
+
+	match = of_match_device(max9296a_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_u32(node, "index", &value);
+	if (err)
+		dev_err(&client->dev, "index not found\n");
+
+	if(value >= 0 && value < 4)
+		priv->index = value;
+	else
+		priv->index = 0;
+
+	dev_dbg(&client->dev, "%s: index %d\n", __func__, priv->index);
+
+	err = of_property_read_string(node, "csi-mode", &str_value);
+	if (err < 0) {
+		dev_err(&client->dev, "csi-mode property not found\n");
+		return err;
+	}
+
+	priv->deser_addr = client->addr;
+	if (!strcmp(str_value, "2x4")) {
+		priv->csi_mode = MAX9296_CSI_MODE_2X4;
+	} else if (!strcmp(str_value, "4x2")) {
+		priv->csi_mode = MAX9296_CSI_MODE_4X2;
+	} else {
+		dev_err(&client->dev, "invalid csi mode\n");
+		return -EINVAL;
+	}
+
+	err = of_property_read_u32(node, "seri-addr", &value);
+	if (err)
+		dev_err(&client->dev, "seri-addr not found\n");
+	priv->seri_start_addr = value;
+
+	err = of_property_read_u32(node, "proxy-addr", &value);
+	if (err)
+		dev_err(&client->dev, "proxy-addr not found\n");
+	priv->snr_proxy_addr = value;
+
+	err = of_property_read_u32(node, "real-addr", &value);
+	if (err)
+		dev_err(&client->dev, "real-addr not found\n");
+	priv->snr_real_addr = value;
+
+	err = of_property_read_u32(node, "fsync_mfp_index", &value);
+	if (err < 0) {
+		priv->fsync_mfp_x = 10;
+		dev_err(&client->dev, "No fsync_mfp_index info\n");
+	} else {
+		priv->fsync_mfp_x = value;
+	}
+
+	err = of_property_read_u32(node, "pps_mfp_index", &value);
+	if (err < 0) {
+		priv->pps_mfp_x = 9;
+		dev_err(&client->dev, "No pps_mfp_index info\n");
+	} else {
+		priv->pps_mfp_x = value;
+	}
+
+	priv->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (priv->reset_gpio < 0)
+		dev_err(&client->dev, "reset-gpios not found %d\n", err);
+
+	if (of_get_property(node, "vdd_supply_1v2", NULL)) {
+		priv->vdd_supply_1v2 = 1;
+	} else {
+		priv->vdd_supply_1v2 = 0;
+	}
+
+	return 0;
+}
+
+static struct regmap_config max9296a_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE, // REGCACHE_RBTREE,
+};
+
+#if defined(NV_I2C_DRIVER_STRUCT_PROBE_WITHOUT_I2C_DEVICE_ID_ARG) /* Linux 6.3 */
+static int max9296a_probe(struct i2c_client *client)
+#else
+static int max9296a_probe(struct i2c_client *client, const struct i2c_device_id *id)
+#endif
+{
+	struct max9296a *priv;
+	struct device_node *node = client->dev.of_node;
+	int err = 0;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &max9296a_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev, "regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+	dev_set_drvdata(&client->dev, priv);
+
+	err = max9296a_parse_dt(priv, client);   //
+	if (err) {
+		dev_err(&client->dev, "parse devicetree error, %d\n", err);
+		return -EFAULT;
+	}
+
+	mutex_init(&priv->lock);
+
+	max9296a_power_off(&client->dev);
+	msleep_range(100);
+	err = max9296a_power_on(&client->dev);
+	if (err) {
+		dev_err(&client->dev, "power on failed, %d\n", err);
+		return err;
+	}
+	msleep_range(200);
+
+	if (of_get_property(node, "is-fg96-2ch", NULL)) {
+		//Enable POC
+		max9296a_write_reg(&client->dev, 0x0005, 0x80);
+		max9296a_write_reg(&client->dev, 0x02BC, 0x80); //Enable MFP4 Output low
+		max9296a_write_reg(&client->dev, 0x02BD, 0x84); //Enable MFP4 Output Pulldown 
+		
+	}
+
+	if (of_get_property(node, "is-fg96-8ch-v2.1", NULL)) {
+		//Enable POC
+		max9296a_write_reg(&client->dev, 0x0005, 0x80);
+		max9296a_write_reg(&client->dev, 0x02BC, 0x90); //Enable MFP4 Output hight
+	}
+	
+	err = max9296a_debugfs_init(NULL, NULL, NULL, priv);
+	if (err)
+		return err;
+
+	/* Serializer i2c address trans */
+	err = max9296a_seri_i2c_addr_trans(&client->dev);
+	if(err) {
+		dev_err(&client->dev, "Serializer i2c address change failed, %d\n", err);
+		return 0; //err;
+	}
+
+	err = max9296a_init_settings(&client->dev);
+	if(err) {
+		dev_err(&client->dev, "max9296a init settings failed, %d\n", err);
+		return 0; //err;
+	}
+
+	err = max9296a_set_snr_proxy_addr(&client->dev);
+	if(err) {
+		dev_err(&client->dev, "max9296a set_snr_proxy_addr failed, %d\n", err);
+		return 0; //err;
+	}
+
+	err = max9296a_set_all_links_sensor_off(&client->dev);
+	{
+		dev_err(&client->dev, "max9296a_set_all_links_sensor_off failed, %d\n", err);
+		return 0; //err;
+	}
+	/*set daymode by fault*/
+	dev_info(&client->dev, "%s: success\n", __func__);
+
+	return 0; //err;
+}
+
+#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+static int max9296a_remove(struct i2c_client *client)
+#else
+static void max9296a_remove(struct i2c_client *client)
+#endif
+{
+	struct max9296a *priv;
+
+	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+		mutex_destroy(&priv->lock);
+		//i2c_unregister_device(client);
+		client = NULL;
+	}
+#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+	return 0;
+#endif
+}
+
+static const struct i2c_device_id max9296a_id[] = {
+	{ "obc_max9296", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, max9296a_id);
+
+static struct i2c_driver max9296a_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "obc_max9296",
+		.of_match_table = of_match_ptr(max9296a_of_match),
+	},
+	.probe = max9296a_probe,
+	.remove = max9296a_remove,
+	.id_table = max9296a_id,
+};
+
+module_i2c_driver(max9296a_i2c_driver);
+
+MODULE_DESCRIPTION("IO Expander driver max9296a");
+MODULE_AUTHOR("NVIDIA Corporation");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_max96712.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_max96712.c
new file mode 100644
index 000000000..114bf0f1b
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/i2c/obc_max96712.c
@@ -0,0 +1,1457 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * max96712.c - max96712 IO Expander driver
+ *
+ * Copyright (c) 2016-2023, NVIDIA CORPORATION & AFFILIATES. All Rights Reserved.
+ */
+
+/* #define DEBUG */
+
+#include <nvidia/conftest.h>
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+
+#include <media/obc_max96712.h>
+
+
+
+/*
+ Programming Steps - Video Data Path
+Configuring the forward video path from the GMSL2 quad deserializer consists of four basic programming steps:
+ 1. Link Initialization
+ 2. Video Pipe Selection
+ 3. Video Pipe to MIPI Controller Mapping
+ 4. MIPI PHY Settings
+*/
+
+/*-----------------------------------------------------------------------------------------------
+ * 4. MIPI PHY Settings
+ *----------------------------------------------------------------------------------------------*/
+#define MAX96712_DST_CSI_MODE_ADDR 0x8A0 //MIPI PHY Mode Select Register: 2x4 mode, 1x4 mode, 4x2 mode
+
+#define MAX96712_PWDN_PHYS_ADDR  0x8A2  //MIPI PHY Enable Register: MIPI PHY 0~3, 0 = PHY in standby, 1 = PHY enabled
+
+#define MAX96712_LANE_MAP1_ADDR  0x8A3 //MIPI PHY 0&1 Lane Mapping Register
+#define MAX96712_LANE_MAP2_ADDR  0x8A4 //MIPI PHY 3&2 Lane Mapping Register
+#define MAX96712_LANE_POLA1_ADDR 0x8A5 //MIPI PHY 0&1 Lane Polarity Register
+#define MAX96712_LANE_POLA2_ADDR 0x8A6 //MIPI PHY 3&2 Lane Polarity Register
+
+#define MAX96712_LANE_CTRL0_ADDR 0x90A //MIPI PHY 0 Lane Count / C-PHY enable Register
+#define MAX96712_LANE_CTRL1_ADDR 0x94A //MIPI PHY 1 Lane Count / C-PHY enable Register
+#define MAX96712_LANE_CTRL2_ADDR 0x98A //MIPI PHY 2 Lane Count / C-PHY enable Register
+#define MAX96712_LANE_CTRL3_ADDR 0x9CA //MIPI PHY 3 Lane Count / C-PHY enable Register
+
+#define MAX96712_PHY0_CLK_ADDR 	 0x415 //MIPI PHY 0 DPLL Freq Register
+#define MAX96712_PHY1_CLK_ADDR 	 0x418 //MIPI PHY 1 DPLL Freq Register
+#define MAX96712_PHY2_CLK_ADDR 	 0x41B //MIPI PHY 2 DPLL Freq Register
+#define MAX96712_PHY3_CLK_ADDR 	 0x41E //MIPI PHY 3 DPLL Freq Register
+
+#define MAX96712_CSI_OUT_EN      0x40B //CSI_OUT_EN: CSI output enabled, en:0x2, dis:0x0
+
+/*-----------------------------------------------------------------------------------------------
+ * 3. Video Pipe to MIPI Controller Mapping
+ *----------------------------------------------------------------------------------------------*/
+#define MAX96712_TX11_PIPE_X_EN_ADDR   0x90B //Mapping Enable Low Byte, 0~7
+#define MAX96712_TX11_PIPE_X_EN_H_ADDR 0x90C //Mapping Enable High Byte, 8~15
+
+#define MAX96712_PIPE_X_SRC_0_MAP_ADDR 0x90D //MAP_SRC_0 Register: VC+DT
+#define MAX96712_PIPE_X_DST_0_MAP_ADDR 0x90E //MAP_DES_0 Register: VC+DT
+#define MAX96712_PIPE_X_SRC_1_MAP_ADDR 0x90F //MAP_SRC_1 Register: VC+DT
+#define MAX96712_PIPE_X_DST_1_MAP_ADDR 0x910 //MAP_DES_1 Register: VC+DT
+#define MAX96712_PIPE_X_SRC_2_MAP_ADDR 0x911 //MAP_SRC_2 Register: VC+DT
+#define MAX96712_PIPE_X_DST_2_MAP_ADDR 0x912 //MAP_DES_2 Register: VC+DT
+#define MAX96712_PIPE_X_SRC_3_MAP_ADDR 0x913 //MAP_SRC_3 Register: VC+DT
+#define MAX96712_PIPE_X_DST_3_MAP_ADDR 0x914 //MAP_DES_3 Register: VC+DT
+
+#define MAX96712_TX45_PIPE_X_DST_CTRL_ADDR  0x92D //MAP Destination Controller Register: 0~3
+#define MAX96712_TX45_PIPE_X_DST_CTRL2_ADDR 0x92E //MAP Destination Controller Register: 4~7
+
+//--------------------------------------------------------------------
+// others
+#define MAX96712_PIPE_X_ST_SEL_ADDR 0x50 //RX packets with selected stream ID, add b7: RX_CRC_EN
+
+#define MAX96712_PWR1_RESET_ALL_ADDR 0x13  //b6: 1->RESET_ALL, Chip reset
+
+#define MAX96712_CTRL0_ADDR 0x17 //bit2 REG_ENABLE: VDD LDO Regulator Enable: 1 -> enable,0 -> disable
+#define MAX96712_CTRL2_ADDR 0x19 //bit4 REG_MNL: VDD LDO Regulator Enable: 1 -> enable,0 -> disable
+#define MAX96712_CTRL3_ADDR 0x1A
+
+#define MAX96712_LOCKED_MASK 0x08 //b3, GMSL2 link locked
+
+/*-----------------------------------------------------------------------------------------------
+ * 2. Video Pipe Selection
+ *----------------------------------------------------------------------------------------------*/
+#define MAX96712_PIPE_SEL_01_ADDR  0xF0 //Video Pipe Select & Stream ID Select Register: PHY A~D Stream 0~3 for Pipe 0&1
+#define MAX96712_PIPE_SEL_23_ADDR  0xF1 //Video Pipe Select & Stream ID Select Register: PHY A~D Stream 0~3 for Pipe 2&3
+#define MAX96712_PIPE_SEL_45_ADDR  0xF2 //Video Pipe Select & Stream ID Select Register: PHY A~D Stream 0~3 for Pipe 4&5
+#define MAX96712_PIPE_SEL_67_ADDR  0xF3 //Video Pipe Select & Stream ID Select Register: PHY A~D Stream 0~3 for Pipe 6&7
+
+#define MAX96712_PIPE_EN_ADDR  	  0xF4 //Video Pipe Enable Register: bits[7:0] for Pipe [7:0]
+
+/*-----------------------------------------------------------------------------------------------
+ * 1. Link Initialization
+ *----------------------------------------------------------------------------------------------*/
+#define MAX96712_LINK_MASK_ADDR     0x03 //Disable GMSL2 remote control channel link
+#define MAX96712_LINK_EN_MODE_ADDR  0x06 //GMSL Link/PHY Enable b[3:0]A~D, Mode b[7:4] (0:GMSL1,1:GMSL2) Select Register
+
+#define MAX96712_LINK_AB_RATE_ADDR  0x10 //GMSL Link/PHY A&B Rate Select Register
+#define MAX96712_LINK_CD_RATE_ADDR  0x11 //GMSL Link/PHY C&D Rate Select Register
+
+#define MAX96712_LINK_RESET_ADDR    0x18 //GMSL Link Reset Register: Bits [7:4]: Link reset for link D/C/B/A,  Bits [3:0]: One-shot link reset for link D/C/B/A
+
+#define CTRL0_REG_ENABLE 	0x4 //Enable VDD LDO regulator
+#define CTRL0_REG_MNL 	0x10 //Enable VDD LDO regulator
+/*-----------------------------------------------------------------------------------------------
+ * data defines
+ *----------------------------------------------------------------------------------------------*/
+/* MIPI PHY Mode Select */
+#define MAX96712_CSI_MODE_4X2 0x1
+#define MAX96712_CSI_MODE_1X4 0x2
+#define MAX96712_CSI_MODE_2X4 0x4
+#define MAX96712_CSI_MODE_1X4A_2X2 0x8
+#define MAX96712_CSI_MODE_1X4B_2X2 0x10
+
+/* MIPI PHY Lane Mapping */
+#define MAX96712_LANE_MAP1_4X2 0x44 
+#define MAX96712_LANE_MAP2_4X2 0x44
+#define MAX96712_LANE_MAP1_2X4 0x4E
+#define MAX96712_LANE_MAP2_2X4 0xE4
+
+#define MAX96712_LANE_CTRL_MAP(num_lanes) \
+	(((num_lanes) << 6) & 0xF0)
+
+#define MAX96712_MAX_PIPES 8
+#define MAX96712_MAX_LINKS 4
+
+#define SERI_DEFAULT_ADDR 0x40 // >>1 = 0x40
+
+#define TO_SERI_ADDR(A)	(priv->seri_start_addr + (A))
+#define TO_SNR_ADDR(A)	(priv->snr_proxy_addr + (A))
+
+//--------------------------------------------------------------------------------------
+struct index_reg_8 {
+	u8 source;
+	u16 addr;
+	u8 val;
+};
+
+struct max96712 {
+	struct mutex lock;
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	u8 csi_mode;
+	u8 links_map;
+	u8 links_init_flag;
+	u8 pipes_map;
+	u8 index;
+	u8 deser_addr; //deser address
+	u8 seri_start_addr; //serializer start address
+	u8 snr_proxy_addr;  // sensor proxy address
+	u8 snr_real_addr;   // sensor real address
+	int reset_gpio;
+	int fsync_mfp_x;
+	int pps_mfp_x;
+	int vdd_supply_1v2;
+};
+
+//--------------------------------------------------------------------------------------
+static int _max96712_write_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 val)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct i2c_client *i2c_client;
+	int err;
+
+	i2c_client = priv->i2c_client;
+
+	i2c_client->addr = i2c_addr;
+	err = regmap_write(priv->regmap, addr, val);
+	i2c_client->addr = priv->deser_addr;
+	if (err)
+		dev_err(dev, "%s err: 0x%02x, 0x%04x = 0x%02x\n", __func__, i2c_addr, addr, val);
+
+	usleep_range(100, 110);
+
+	dev_dbg(dev, "[%s] wr reg: 0x%02x, 0x%04x = 0x%02x\n", (i2c_addr == priv->deser_addr) ? "dser" : "seri", i2c_addr, addr, val);
+
+	return err;
+}
+
+int max96712_write_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 val)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int ret;
+
+	if (priv == NULL)
+		return -1;
+
+	mutex_lock(&priv->lock);
+	ret = _max96712_write_reg_with_addr(dev, i2c_addr, addr, val);
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(max96712_write_reg_with_addr);
+
+int max96712_write_tab_with_addr(struct device *dev, u8 i2c_addr, struct max_reg_pair tab[], u16 size)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct i2c_client *i2c_client;
+	int i, err;
+
+	if (priv == NULL)
+		return -1;
+
+	mutex_lock(&priv->lock);
+
+	i2c_client = priv->i2c_client;
+
+	i2c_client->addr = i2c_addr;
+	for (i = 0; i < size; i++) {
+		err = regmap_write(priv->regmap, tab[i].addr, tab[i].val);
+		if (err) {
+			dev_err(dev, "%s: error, 0x%02x --> 0x%04x = 0x%02x\n", __func__, i2c_addr, tab[i].addr, tab[i].val);
+			break;
+		}
+		usleep_range(100, 110);
+		dev_dbg(dev, "[%s] wr tab: 0x%02x, 0x%04x = 0x%02x\n", (i2c_addr == priv->deser_addr) ? "dser" : "seri", i2c_addr, tab[i].addr, tab[i].val);
+	}
+	i2c_client->addr = priv->deser_addr;
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_write_tab_with_addr);
+
+int max96712_read_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 *val)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct i2c_client *i2c_client;
+	unsigned int value = 0;
+	int err;
+
+	if (priv == NULL)
+		return -1;
+
+	mutex_lock(&priv->lock);
+
+	i2c_client = priv->i2c_client;
+
+	i2c_client->addr = i2c_addr;
+	err = regmap_read(priv->regmap, addr, &value);
+	i2c_client->addr = priv->deser_addr;
+	if (err)
+		dev_err(dev, "%s: 0x%02x, 0x%04x = 0x%02x\n", __func__, i2c_addr, addr, value);
+
+	*val = value;
+
+	usleep_range(100, 110);
+
+	mutex_unlock(&priv->lock);
+
+	dev_dbg(dev, "dser rd reg: 0x%02x, 0x%04x = 0x%02x\n", i2c_addr, addr, value);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_read_reg_with_addr);
+
+int max96712_write_seri_reg(struct device *dev, u8 link_id, u16 addr, u8 val)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	return max96712_write_reg_with_addr(dev, TO_SERI_ADDR(link_id), addr, val);
+}
+EXPORT_SYMBOL(max96712_write_seri_reg);
+
+int max96712_write_seri_tab(struct device *dev, u8 link_id, struct max_reg_pair buf[], u16 size)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	return max96712_write_tab_with_addr(dev, TO_SERI_ADDR(link_id), buf, size);
+}
+EXPORT_SYMBOL(max96712_write_seri_tab);
+
+int max96712_write_sensor(struct device *dev, u8 link_id, void *data, u16 length)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct i2c_msg send_msg = {
+		.addr = TO_SNR_ADDR(link_id),
+		.flags = 0,
+		.buf = (uint8_t*)data,
+		.len = length,
+	};
+	int error;
+	u16 *header = data;
+
+	mutex_lock(&priv->lock);
+	error = i2c_transfer(priv->i2c_client->adapter, &send_msg, 1);
+	mutex_unlock(&priv->lock);
+	if (error != 1) {
+		dev_err(dev, "\nsensor i2c tx error, code=%d, len=%d, index=%d\n", header[1], header[0], header[2]);
+		return -1;
+	}
+
+	dev_dbg(dev, "[snr] i2c wr: 0x%02x, %d\n", send_msg.addr, length);
+
+	return 0;
+}
+EXPORT_SYMBOL(max96712_write_sensor);
+
+int max96712_read_sensor(struct device *dev, u8 link_id, void *data, u16 length)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	struct i2c_msg recv_msg = {
+		.addr = TO_SNR_ADDR(link_id),
+		.flags = I2C_M_RD,
+		.buf = data,
+		.len = length,
+	};
+	int error;
+
+	mutex_lock(&priv->lock);
+	error = i2c_transfer(priv->i2c_client->adapter, &recv_msg, 1);
+	// dev_info(dev, "orb: i2c read: %x, %d\n", client->addr, length);
+	mutex_unlock(&priv->lock);
+	if (error != 1) {
+		dev_err(dev, "\n i2c_read_orbbec error \n");
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(max96712_read_sensor);
+
+static int max96712_write_reg(struct device *dev, u16 addr, u8 val)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+
+	int err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s err: 0x%04x = 0x%02x\n", __func__, addr, val);
+
+	/* delay before next i2c command as required for SERDES link */
+	usleep_range(100, 110);
+
+	dev_dbg(dev, "[dser] i2c wr: 0x%04x = 0x%02x\n", addr, val);
+
+	return err;
+}
+
+static int max96712_read_reg(struct device *dev, u16 addr, u8 *val)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	unsigned int value;
+
+	int err = regmap_read(priv->regmap, addr, &value);
+	if (err)
+		dev_err(dev, "%s err: 0x%04x\n", __func__, addr);
+
+	*val = value&0xff;
+
+	// delay before next i2c command as required for SERDES link 
+	usleep_range(100, 110);
+
+	dev_dbg(dev, "[dser] i2c rd: 0x%04x = 0x%02x\n", addr, value);
+
+	return err;
+}
+
+static int max96712_set_registers(struct device *dev, struct max_reg_pair *map, u16 count)
+{
+	int err = 0;
+	u16 i;
+
+	for (i = 0; i < count; i++) {
+		err = max96712_write_reg(dev, map[i].addr, map[i].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+//--------------------------------------------------------------------------------------
+static int max96712_read_link_lock(struct device *dev, int index)
+{
+	u16 addr_tab[4] = {0x1A, 0x0A, 0x0B, 0x0C}; // link A, B, C, D
+	u8 val = 0;
+	int ret = max96712_read_reg(dev, addr_tab[index], &val); // link A, B, C, D
+	if(ret) {
+		dev_info(dev, "read link reg err, %d\n", ret);
+		return -1;
+	}
+	return (val&0x8) ? 1 : 0; //bit3
+}
+
+static int max96712_check_link_lock(struct device *dev)
+{
+	int i, ret;
+	u8 links = 0;
+
+	for (i = 0; i < MAX96712_MAX_LINKS; i++) {
+		ret = max96712_read_link_lock(dev, i);// link A, B, C, D
+		if(ret < 0)
+			return ret;
+		else if(ret == 1)
+			links |= (1<<i);
+	}
+	dev_info(dev, "check link status: 0x%02x\n", links);
+	return links;
+}
+
+u8 max96712_get_link_map(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	return priv->links_map;
+}
+EXPORT_SYMBOL(max96712_get_link_map);
+
+u8 max96712_get_link_init_flag(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	return priv->links_init_flag;
+}
+EXPORT_SYMBOL(max96712_get_link_init_flag);
+
+void max96712_set_link_init_flag(struct device *dev, u8 link)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	priv->links_init_flag &= ~(1 << link);
+}
+EXPORT_SYMBOL(max96712_set_link_init_flag);
+
+#if 1
+#if 0
+/* Video channel is locked and outputting valid video data */
+u8 max96712_check_video_channel_lock(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	u16 addr_tab[8] = {0x01DC, 0x01FC, 0x021C, 0x023C, 0x025C, 0x027C, 0x029C, 0x02BC}; //pipe 0~7
+	int i, ret;
+	u8 val = 0, ch_lock = 0;
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < 8; i++) {
+		val = 0;
+		ret = max96712_read_reg(dev, addr_tab[i], &val); //pipe 0~7
+		if(ret)
+			break;
+		if(val&0x1) //bit0
+			ch_lock |= (1<<i);
+	}
+    mutex_unlock(&priv->lock);
+
+	if(ret)
+		ch_lock = 0;
+
+	dev_info(dev, "check channel lock: 0x%x\n", ch_lock);
+
+	return ch_lock;
+}
+EXPORT_SYMBOL(max96712_check_video_channel_lock);
+#endif
+
+u8 max96712_check_pipe_lock(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int i, ret;
+	u16 addr_tb[]={0x108, 0x11A, 0x12C, 0x13E, 0x150, 0x168, 0x17A, 0x18C}; //pipe 0~7
+	u8 val = 0, pipe_lock = 0;
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX96712_MAX_PIPES; i++) {
+		val = 0;
+		ret = max96712_read_reg(dev, addr_tb[i], &val); //video pipeline locked 0~7
+		if(ret)
+			break;
+		if(val&0x40) //bit6
+			pipe_lock |= (1<<i);
+	}
+    mutex_unlock(&priv->lock);
+
+	if(ret)
+		pipe_lock = -1;
+
+	dev_info(dev, "check pipe lock: 0x%02x\n", pipe_lock);
+
+	return pipe_lock;
+}
+EXPORT_SYMBOL(max96712_check_pipe_lock);
+#endif
+
+/* transform serializer i2c address */
+static int max96712_seri_i2c_addr_trans(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int i, ret, links;
+	u16 mask = 0xF0;
+
+	mutex_lock(&priv->lock);
+
+	links = max96712_check_link_lock(dev);
+	if(links <= 0) {
+		dev_err(dev, "max96712_check_link_lock failed %d\n", ret);
+		ret = -1;
+		goto err;
+	}
+	priv->links_map = links;
+	priv->links_init_flag = links;
+	ret = _max96712_write_reg_with_addr(dev, priv->deser_addr, 0x40B, 0x00); //CSI_OUT_EN = 0, CSI output disabled
+	if (ret)
+		goto err;
+	ret = _max96712_write_reg_with_addr(dev, priv->deser_addr, 0x18, 0x0F); //reset link A~D oneshot
+	if (ret)
+		goto err;
+	msleep(120);
+
+	for (i = 0; i < MAX96712_MAX_LINKS; i++) { //link A~D
+		if(links & (1<<i)) {
+			mask |= (1<<i);
+			/* max96712 */
+			ret = _max96712_write_reg_with_addr(dev, priv->deser_addr, 0x06, mask); //enable link A~D
+			if (ret)
+				goto err;
+			msleep(120);
+
+			/* max9295d */
+			ret = _max96712_write_reg_with_addr(dev, SERI_DEFAULT_ADDR, 0x0002, 0); //disable all pipe out
+			ret = _max96712_write_reg_with_addr(dev, SERI_DEFAULT_ADDR, 0x0000, TO_SERI_ADDR(i)<<1); //transform serializer i2c address
+
+			dev_info(dev, "transf seri i2c addr, 0x%02x, 0x40 -> 0x%02x\n", mask, TO_SERI_ADDR(i));
+		}
+	}
+
+#if 1
+	ret = _max96712_write_reg_with_addr(dev, priv->deser_addr, 0x40B, 0x02); //CSI_OUT_EN = 1, CSI output enabled
+	if (ret)
+		goto err;
+
+	ret = _max96712_write_reg_with_addr(dev, priv->deser_addr, 0x06, mask); //re enable link A~D
+	if (ret)
+		goto err;
+#endif
+
+	if(priv->vdd_supply_1v2 == 1) {
+		//Enable regulator manual mode to allow regulator to be forced on or off via REG_ENABLE
+		max96712_write_reg(dev, MAX96712_CTRL0_ADDR, 0x10|CTRL0_REG_ENABLE);
+		msleep(100);
+		max96712_write_reg(dev, MAX96712_CTRL2_ADDR, 0x84|CTRL0_REG_MNL);
+		msleep(100);
+	}
+
+err:
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+
+#define ORBBEC_POWER_GPIOA_ADDR 0x2D6
+#define ORBBEC_POWER_GPIOB_ADDR 0x2D7
+
+#if 0
+static int max96712_set_sensor_on(struct device *dev, int link_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int ret = _max96712_write_reg_with_addr(dev, TO_SERI_ADDR(link_id), ORBBEC_POWER_GPIOA_ADDR, 0x00);
+	if (ret)
+		dev_err(dev, "%s:set_sensor_on fail\n", __func__);
+	return ret;
+}
+
+static int max96712_set_all_links_sensor_on(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i = 0;
+	if(priv->links_map == 0) return err;
+	/* power on */
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_LINKS; i++) { //link A~D
+		if(priv->links_map & (1<<i)) {
+			err = max96712_set_sensor_on(dev, i);
+			if(err) {
+				dev_err(dev, "max96712 power on MX6800 :link %d failed \n", i);
+				continue;
+				//break;
+			}
+			dev_info(dev, "%s power on MX6800 :link %d success\n", __func__, i);
+		}
+	}
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "%s : sleep 3(s) after power on MX6800\n", __func__);
+	msleep(3000);
+	return err;
+}
+#endif
+
+static int max96712_set_sensor_off(struct device *dev, int link_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int ret = _max96712_write_reg_with_addr(dev, TO_SERI_ADDR(link_id), ORBBEC_POWER_GPIOA_ADDR, 0x10);
+	if (ret)
+		dev_err(dev, "%s:set_sensor_off fail\n", __func__);
+	return ret;
+}
+
+static int max96712_set_all_links_sensor_off(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	int i = 0;
+	if(priv->links_map == 0) return err;
+	/* power on */
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX96712_MAX_LINKS; i++) { //link A~D
+		if(priv->links_map & (1<<i)) {
+			err = max96712_set_sensor_off(dev, i); //power off
+			if(err) {
+				dev_err(dev, "max96712 power off MX6800 : link %d failed \n", i);
+				continue;
+				//break;
+			}
+			dev_info(dev, "%s power off MX6800 : link %d success\n", __func__, i);
+			msleep(10);
+		}
+	}
+	mutex_unlock(&priv->lock);
+
+	msleep(2000);
+	return err;
+}
+
+/* set sensor proxy address */
+static int max96712_set_snr_proxy_addr(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int i, err = 0;
+	if(priv->links_map == 0) return err;
+	mutex_lock(&priv->lock);
+
+	for (i = 0; i < MAX96712_MAX_LINKS; i++) { //link A~D
+		if(priv->links_map & (1<<i)) {
+			int ret = 0;
+			ret  = _max96712_write_reg_with_addr(dev, TO_SERI_ADDR(i), 0x0042, (priv->snr_proxy_addr + i)<<1);
+			ret += _max96712_write_reg_with_addr(dev, TO_SERI_ADDR(i), 0x0043, priv->snr_real_addr<<1);
+			if(ret) {
+				dev_err(dev, "max96712 set link %d snr_proxy_addr failed %d\n", i, ret);
+				err = ret;
+				continue;
+			}
+		}
+	}
+	mutex_unlock(&priv->lock);
+	return err;
+}
+
+static int __max96712_set_pipe(struct device *dev, u8 link_id, u8 pipe_id, 
+				u8 data_type1, u8 data_type2, u8 src_vc_id, u8 dst_vc_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int i, err;
+	u8 mapping2csi, mappings_en = 0x0F;
+
+	struct max_reg_pair map_pipe_control[] = {
+		/* Enable 4 mappings for Pipe X */
+		{MAX96712_TX11_PIPE_X_EN_ADDR,   0x0F}, //0x90B
+		/* Map data_type1 on vc_id */
+		{MAX96712_PIPE_X_SRC_0_MAP_ADDR, 0x1E}, //0x90D
+		{MAX96712_PIPE_X_DST_0_MAP_ADDR, 0x1E},
+		/* Map frame_start on vc_id */
+		{MAX96712_PIPE_X_SRC_1_MAP_ADDR, 0x00}, //0x90F
+		{MAX96712_PIPE_X_DST_1_MAP_ADDR, 0x00},
+		/* Map frame end on vc_id */
+		{MAX96712_PIPE_X_SRC_2_MAP_ADDR, 0x01}, //0x911
+		{MAX96712_PIPE_X_DST_2_MAP_ADDR, 0x01},
+		/* Map data_type2 on vc_id */
+		{MAX96712_PIPE_X_SRC_3_MAP_ADDR, 0x12}, //0x913
+		{MAX96712_PIPE_X_DST_3_MAP_ADDR, 0x12},
+		/* All mappings to PHY1 (master for port A) */
+		{MAX96712_TX45_PIPE_X_DST_CTRL_ADDR, 0x55}, //0x92D
+		/* Disable Heartbeat Mode, I's use for DSI */
+		{0x0100, 0x23}, //0x23, SEQ_MISS_EN=0, LINE_CRC_EN=0, DIS_PKT_DET=1
+		{0x0106, 0x0A}, //LIM_HEART
+	};
+
+	for (i = 0; i < 10; i++)
+		map_pipe_control[i].addr += 0x40 * pipe_id;
+	for (; i < 12; i++)
+		map_pipe_control[i].addr += (pipe_id < 5) ? (0x12 * pipe_id) : (0x12 * pipe_id + 6);
+
+	if(priv->csi_mode == MAX96712_CSI_MODE_2X4)
+		mapping2csi = (link_id > 1) ? 0xAA : 0x55;
+	else
+		mapping2csi = 0x55*link_id;
+
+	if(data_type2 == 0) {
+		mapping2csi &= 0x3f;
+		mappings_en = 0x07;
+	}
+
+	map_pipe_control[0].val = mappings_en;
+	map_pipe_control[1].val = (src_vc_id << 6) | data_type1;
+	map_pipe_control[2].val = (dst_vc_id << 6) | data_type1;
+	map_pipe_control[3].val = (src_vc_id << 6) | 0x00;
+	map_pipe_control[4].val = (dst_vc_id << 6) | 0x00;
+	map_pipe_control[5].val = (src_vc_id << 6) | 0x01;
+	map_pipe_control[6].val = (dst_vc_id << 6) | 0x01;
+	map_pipe_control[7].val = (src_vc_id << 6) | data_type2;
+	map_pipe_control[8].val = (dst_vc_id << 6) | data_type2;
+	map_pipe_control[9].val = mapping2csi;
+
+	dev_info(dev, "set pipe start\n");
+
+	err = max96712_set_registers(dev, map_pipe_control, ARRAY_SIZE(map_pipe_control));
+
+	dev_info(dev, "set pipe %s!\n", err ? "failed" : "success");
+
+	return err;
+}
+
+/*
+   link_id: 0~3 -> deser link A ~ D
+   pipe_id: 0~7 -> deser pipe
+   seri_pipe_id: 0~3 ->seri pipe
+*/
+int max96712_link_pipe_bind(struct device *dev, u8 link_id, u8 pipe_id, u8 seri_pipe_id)
+{
+#if 1
+	struct max96712 *priv = dev_get_drvdata(dev);
+	const u8 pipe_sel_tb[4] = {
+		MAX96712_PIPE_SEL_01_ADDR,
+		MAX96712_PIPE_SEL_23_ADDR,
+		MAX96712_PIPE_SEL_45_ADDR,
+		MAX96712_PIPE_SEL_67_ADDR
+	};
+	int err;
+	u8 addr, val, temp;
+
+	dev_info(dev, "%s bind pipe, deser link=%d, deser id=%d, seri id=%d\n", __func__, link_id, pipe_id, seri_pipe_id);
+
+	addr = pipe_sel_tb[pipe_id/2];
+
+	mutex_lock(&priv->lock);
+
+	err = max96712_read_reg(dev, addr, &val);
+	if(err) {
+		dev_err(dev, "%s read reg failed, 0x%04x\n", __func__, addr);
+		mutex_unlock(&priv->lock);
+		return -1;
+	}
+
+	temp = (link_id<<2) | seri_pipe_id;
+	if (pipe_id & 1) {
+		val = (val & 0x0f) | (temp<<4);
+	} else {
+		val = (val & 0xf0) | temp;
+	}
+
+	err = max96712_write_reg(dev, addr, val);
+	if(err == 0)
+		dev_info(dev, "%s bind pipe success\n", __func__);
+
+	dev_info(dev, "%s oneshot reset all link\n", __func__);
+	max96712_write_reg(dev, MAX96712_LINK_RESET_ADDR, 0x0f); //0x18, 0x0f -> all link oneshot reset
+	msleep(100);
+	
+	max96712_write_reg(dev, MAX96712_PIPE_EN_ADDR, priv->pipes_map); //0xF4, pipe en
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL(max96712_link_pipe_bind);
+
+int max96712_set_pipe(struct device *dev, u8 link_id, u8 pipe_id,
+		     u8 data_type1, u8 data_type2, u8 src_vc_id, u8 dst_vc_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+	// u8 pipe_lock = 0;
+
+	if (pipe_id > (MAX96712_MAX_PIPES - 1)) {
+		dev_err(dev, "%s, input pipe_id: %d exceed max96712 max pipes\n", __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "%s pipe_id:%d, dt1:%u, dt2:%u, src_vc:%u, dst_vc:%u\n",
+		__func__, pipe_id, data_type1, data_type2, src_vc_id, dst_vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max96712_set_pipe(dev, link_id, pipe_id, data_type1, data_type2, src_vc_id, dst_vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	err |= max96712_link_pipe_bind(dev, link_id, pipe_id, dst_vc_id);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_set_pipe);
+
+int max96712_init_settings(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	struct max_reg_pair map_pipe_opt[] = {
+	#if 0
+		{0x1458, 0x28}, // PHY A Optimization
+		{0x1459, 0x68}, // PHY A Optimization
+		{0x1558, 0x28}, // PHY B Optimization
+		{0x1559, 0x68}, // PHY B Optimization
+		{0x1658, 0x28}, // PHY C Optimization
+		{0x1659, 0x68}, // PHY C Optimization
+		{0x1758, 0x28}, // PHY D Optimization
+		{0x1759, 0x68}, // PHY D Optimization
+    #endif
+		/* ----------Video pipes configure ----------------------*/
+		{MAX96712_PIPE_SEL_01_ADDR, 0x10}, //0xF0, Link A ID 0 to pipe 0 , Link A ID 1 to pipe 1
+		{MAX96712_PIPE_SEL_23_ADDR, 0x32}, //0xF1, Link A ID 2 to pipe 2 , Link A ID 3 to pipe 3
+		// {MAX96712_PIPE_SEL_45_ADDR, 0x54}, //0x10}, //0xF0, Link A ID 0 to pipe 0 , Link A ID 1 to pipe 1
+		// {MAX96712_PIPE_SEL_67_ADDR, 0x76}, //0x32}, //0xF1, Link A ID 2 to pipe 2 , Link A ID 3 to pipe 3
+		{MAX96712_PIPE_SEL_45_ADDR, 0xDC}, //0xF2, Link C ID 0 to pipe 4 , Link C ID 1 to pipe 5
+		{MAX96712_PIPE_SEL_67_ADDR, 0xFE}, //0xF3, Link C ID 2 to pipe 6 , Link C ID 3 to pipe 7
+
+		{MAX96712_PIPE_EN_ADDR, 0x00}, //0xF4, Enable pipe 0-3, 0xFF
+
+		/* ------------Disable heartbeat mode --------------------*/
+	#if 0
+		{0x0100, 0x23},
+		{0x0112, 0x23},
+		{0x0124, 0x23},
+		{0x0136, 0x23},
+
+		{0x0106, 0x0A},
+		{0x0118, 0x0A},
+		{0x012A, 0x0A},
+		{0x013C, 0x0A},
+	#endif
+	};
+
+	struct max_reg_pair map_phy_opt_2x4[] = 
+	{
+		/* MIPI D-PHY Config */
+		{MAX96712_DST_CSI_MODE_ADDR, (MAX96712_CSI_MODE_2X4 | 0x20)}, //0x8A0
+		{MAX96712_LANE_MAP1_ADDR, 0xE4}, //0x8A3, Default 4x2 lane mapping
+		{MAX96712_LANE_MAP2_ADDR, 0xE4}, //0x8A4, Default 4x2 lane mapping
+
+		/* 4 lanes on port A,  0x40 -> 2 lanes, 0xC0 -> 4 lanes */
+		// {MAX96712_LANE_CTRL0_ADDR, 0xC0}, //0x90A, MIPI PHY0
+		{MAX96712_LANE_CTRL1_ADDR, 0xC0}, //0x94A, MIPI PHY1, as Master controller for A 4lane
+		{MAX96712_LANE_CTRL2_ADDR, 0xC0}, //0x98A, MIPI PHY2, as Master controller for B 4lane
+		// {MAX96712_LANE_CTRL3_ADDR, 0xC0}, //0x9CA, MIPI PHY3
+
+		/* Put DPLL for ctrl 1 and 2 in reset (config_soft_rst_n = 0) before changing MIPI lane rates */
+		// {0x1C00, 0xF4}, //PHY0
+		{0x1D00, 0xF4}, //PHY1
+		{0x1E00, 0xF4}, //PHY2
+		// {0x1F00, 0xF4}, //PHY3
+
+		/* 1500Mbps/lane on port A */
+		// {MAX96712_PHY0_CLK_ADDR, 0x2F}, //0x415, MIPI PHY0
+		{MAX96712_PHY1_CLK_ADDR, 0x2F}, //0x418, MIPI PHY1, this
+		{MAX96712_PHY2_CLK_ADDR, 0x2F}, //0x41B, MIPI PHY2, this
+		// {MAX96712_PHY3_CLK_ADDR, 0x2F}, //0x41E, MIPI PHY3
+
+		/* Release DPLL reset (config_soft_rst_n = 1) */
+		// {0x1C00, 0xF5}, //PHY0
+		{0x1D00, 0xF5}, //PHY1
+		{0x1E00, 0xF5}, //PHY2
+		// {0x1F00, 0xF5}, //PHY3
+
+		/* Do not un-double 8bpp (Un-double 8bpp data) */
+		//{0x0414, 0xF0}, //Pipe0~3, Process BPP = 8 as 16-bit color
+		//{0x0417, 0xF0}, //Enable 8-bit write alternate map to RAMs for pipeline X~U
+		//{0x0434, 0xF0}, //Pipe4~7, Process BPP = 8 as 16-bit color
+		//{0x0437, 0xF0}, //Enable 8-bit write alternate map to RAMs for pipeline X~U
+	
+		/* 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8 */
+		// {0x0933, 0x10}, //MIPI TX0
+		{0x0973, 0x10}, //0x10, MIPI TX1
+		{0x09B3, 0x10}, //0x10, MIPI TX2
+		// {0x09F3, 0x10}, //MIPI TX3
+
+		{MAX96712_PWDN_PHYS_ADDR, 0xF0}, //0x8A2
+		{0x40B, 0x02},  // (CSI_OUT_EN): CSI output enabled
+	};
+	struct max_reg_pair map_phy_opt_4x2[] = {
+		/* MIPI D-PHY Config */
+		{MAX96712_DST_CSI_MODE_ADDR, MAX96712_CSI_MODE_4X2}, //0x8A0
+		{MAX96712_LANE_MAP1_ADDR, 0x44}, //0x8A3, Default 4x2 lane mapping
+		{MAX96712_LANE_MAP2_ADDR, 0x44}, //0x8A4, Default 4x2 lane mapping
+
+		/* 4 lanes on port A,  0x40 -> 2 lanes, 0xC0 -> 4 lanes */
+		{MAX96712_LANE_CTRL0_ADDR, 0x40}, //0x90A, MIPI PHY0
+		{MAX96712_LANE_CTRL1_ADDR, 0x40}, //0x94A, MIPI PHY1, as Master controller for A 4lane
+		{MAX96712_LANE_CTRL2_ADDR, 0x40}, //0x98A, MIPI PHY2, as Master controller for B 4lane
+		{MAX96712_LANE_CTRL3_ADDR, 0x40}, //0x9CA, MIPI PHY3
+
+		/* Put DPLL for ctrl 1 and 2 in reset (config_soft_rst_n = 0) before changing MIPI lane rates */
+		{0x1C00, 0xF4}, //PHY0
+		{0x1D00, 0xF4}, //PHY1
+		{0x1E00, 0xF4}, //PHY2
+		{0x1F00, 0xF4}, //PHY3
+
+		/* 1500Mbps/lane on port A */
+		{MAX96712_PHY0_CLK_ADDR, 0x2F}, //0x415, MIPI PHY0
+		{MAX96712_PHY1_CLK_ADDR, 0x2F}, //0x418, MIPI PHY1, this
+		{MAX96712_PHY2_CLK_ADDR, 0x2F}, //0x41B, MIPI PHY2, this
+		{MAX96712_PHY3_CLK_ADDR, 0x2F}, //0x41E, MIPI PHY3
+
+		/* Release DPLL reset (config_soft_rst_n = 1) */
+		{0x1C00, 0xF5}, //PHY0
+		{0x1D00, 0xF5}, //PHY1
+		{0x1E00, 0xF5}, //PHY2
+		{0x1F00, 0xF5}, //PHY3
+
+		/* Do not un-double 8bpp (Un-double 8bpp data) */
+		// {0x0414, 0xF0}, //Pipe0~3, Process BPP = 8 as 16-bit color
+		// {0x0417, 0xF0}, //Enable 8-bit write alternate map to RAMs for pipeline X~U
+		// {0x0434, 0xF0}, //Pipe4~7, Process BPP = 8 as 16-bit color
+		// {0x0437, 0xF0}, //Enable 8-bit write alternate map to RAMs for pipeline X~U
+	
+		/* 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8 */
+		{0x0933, 0x10}, //MIPI TX0
+		{0x0973, 0x10}, //0x10, MIPI TX1
+		{0x09B3, 0x10}, //0x10, MIPI TX2
+		{0x09F3, 0x10}, //MIPI TX3
+
+		{MAX96712_PWDN_PHYS_ADDR, 0xF0}, //0x8A2, 0xF4
+		{0x40B, 0x02},  // (CSI_OUT_EN): CSI output enabled
+	};
+
+	dev_info(dev, "%s start\n", __func__);
+
+	mutex_lock(&priv->lock);
+
+	err |= max96712_set_registers(dev, map_pipe_opt, ARRAY_SIZE(map_pipe_opt));
+
+	if(priv->csi_mode == MAX96712_CSI_MODE_2X4)
+		err |= max96712_set_registers(dev, map_phy_opt_2x4, ARRAY_SIZE(map_phy_opt_2x4));
+	else
+		err |= max96712_set_registers(dev, map_phy_opt_4x2, ARRAY_SIZE(map_phy_opt_4x2));
+
+	mutex_unlock(&priv->lock);
+
+	if (err == 0)
+		dev_info(dev, "%s done\n", __func__);
+	else
+		dev_err(dev, "%s failed, err %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_init_settings);
+
+int max96712_init_tx_gpio(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	struct max_reg_pair map_fsync_trigger[] = {
+		/* MFP2 fsync out */
+		/* Set Internal FSYNC off, GPIO is used for FSYNC, type = GMSL2 */
+		{0x04A0, 0x08},
+		{0x04AF, 0x9F},
+		/* Config MAX96712/722 MFP2 to receive external FSYNC signal for each link */
+		{0x0306, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; GPIO_OUT_DIS[0]: 1->disable
+		{0x0307, 0xA2}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+		{0x033D, 0x22},
+		{0x0374, 0x22},
+		{0x03AA, 0x22},
+	};
+#if 0
+	struct max_reg_pair map_pps_trigger[] = {
+		/* MFP9 pps, TX */
+		{0x031C, 0x83}, // RES_CFG[7]: 0->40K, 1->1M; GPIO_RX_EN[2]; GPIO_TX_EN[1], GPIO_OUT[4]; GPIO_IN[3]; 
+		{0x031D, 0x1D}, // PULL_UPDN_SEL[7:6]: 0->no pullup, 1->Pullup, 2->Pulldown; OUT_TYPE[5]: 1->Push-pull, 0->Open-drain; GPIO_TX_ID[4:0]
+		{0x0354, 0x3D},
+		{0x038A, 0x3D},
+		{0x03C1, 0x3D},
+	};
+#endif
+	dev_info(dev, "%s start\n", __func__);
+
+	mutex_lock(&priv->lock);
+
+	map_fsync_trigger[2].addr = 0x300 + priv->fsync_mfp_x * 3 + priv->fsync_mfp_x / 5;
+	map_fsync_trigger[3].addr = map_fsync_trigger[2].addr + 1;
+	map_fsync_trigger[4].addr = 0x337 + priv->fsync_mfp_x * 3 + (priv->fsync_mfp_x + 2) / 5;
+	map_fsync_trigger[5].addr = 0x36D + priv->fsync_mfp_x * 3 + (priv->fsync_mfp_x + 4) / 5;
+	map_fsync_trigger[6].addr = 0x3A4 + priv->fsync_mfp_x * 3 + (priv->fsync_mfp_x + 1) / 5;
+	err |= max96712_set_registers(dev, map_fsync_trigger, ARRAY_SIZE(map_fsync_trigger));
+
+#if 0
+	// PPS Trigger
+	map_pps_trigger[0].addr = 0x300 + priv->pps_mfp_x * 3 + priv->fsync_mfp_x / 5;
+	map_pps_trigger[1].addr = map_pps_trigger[0].addr + 1;
+	map_pps_trigger[2].addr = 0x337 + priv->pps_mfp_x * 3 + (priv->fsync_mfp_x + 2) / 5;
+	map_pps_trigger[3].addr = 0x36D + priv->pps_mfp_x * 3 + (priv->fsync_mfp_x + 4) / 5;
+	map_pps_trigger[4].addr = 0x3A4 + priv->pps_mfp_x * 3 + (priv->fsync_mfp_x + 1) / 5;
+	err |= max96712_set_registers(dev, map_pps_trigger, ARRAY_SIZE(map_pps_trigger));
+#endif
+
+	mutex_unlock(&priv->lock);
+
+	if (err == 0)
+		dev_info(dev, "%s done\n", __func__);
+	else
+		dev_err(dev, "%s failed, err %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_init_tx_gpio);
+
+int max96712_reset_dev(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&priv->lock);
+	ret = max96712_write_reg(dev, MAX96712_PWR1_RESET_ALL_ADDR, 0x40); //reset all
+	if(ret)
+		dev_err(dev, "reset deseri chip failed, %d\n", ret);
+	mutex_unlock(&priv->lock);
+
+	msleep(100); /* delay to settle reset */
+
+	return ret;
+}
+EXPORT_SYMBOL(max96712_reset_dev);
+
+int max96712_get_link_state(struct device *dev, u8 link_id, int *value)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&priv->lock);
+	ret = max96712_read_link_lock(dev, link_id);
+	if(ret >= 0)
+		*value = ret;
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "%s, %d\n", __func__, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(max96712_get_link_state);
+
+
+int max96712_get_available_pipe_id(struct device *dev, int dst_vc_id)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int pipe_id = -1;
+
+	mutex_lock(&priv->lock);
+
+	#if 0
+	for (int i = 0; i < MAX9296_MAX_PIPES; i++) {
+		if(!(priv->pipes_map & (1<<i))) {
+			priv->pipes_map |= (1<<i);
+			pipe_id = i;
+			break;
+		}
+	}
+#else
+	if(!(priv->pipes_map & (1<<dst_vc_id))) {
+		priv->pipes_map |= (1<<dst_vc_id);
+		pipe_id = dst_vc_id;
+	}
+#endif
+
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "request pipe id, %x\n", dst_vc_id);
+
+	return pipe_id;
+}
+EXPORT_SYMBOL(max96712_get_available_pipe_id);
+
+int max96712_release_pipe(struct device *dev, u8 link_id, u8 pipe_id)
+{
+#if 1
+	struct max96712 *priv = dev_get_drvdata(dev);
+
+	if (link_id > 3 || pipe_id < 0 || pipe_id >= MAX96712_MAX_PIPES)
+		return -EINVAL;
+
+	mutex_lock(&priv->lock);
+
+	max96712_write_reg(dev, MAX96712_LINK_RESET_ADDR, 1<<link_id); //link reset oneshot
+
+	priv->pipes_map &= ~(1<<pipe_id);
+	max96712_write_reg(dev, MAX96712_PIPE_EN_ADDR, priv->pipes_map); //pipe disable
+
+	mutex_unlock(&priv->lock);
+
+	dev_info(dev, "release pipe id, 0x%02x\n", priv->pipes_map);
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(max96712_release_pipe);
+
+int max96712_reset_oneshot(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	mutex_lock(&priv->lock);
+
+	dev_info(dev, "%s oneshot reset all link.\n", __func__);
+	err = max96712_write_reg(dev, MAX96712_LINK_RESET_ADDR, 0x0f); //0x18, 0x0f -> all link oneshot reset
+	msleep(100);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max96712_reset_oneshot);
+
+static int max96712_stats_show(struct seq_file *s, void *data)
+{
+	return 0;
+}
+
+static int max96712_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, max96712_stats_show, inode->i_private);
+}
+
+static ssize_t max96712_debugfs_write(struct file *s,
+				const char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct max96712 *priv = ((struct seq_file *)s->private_data)->private;
+	struct i2c_client *i2c_client = priv->i2c_client;
+
+	char buf[255];
+	int buf_size;
+	// u8 val = 0;
+
+	if (!user_buf || count <= 1)
+		return -EFAULT;
+
+	memset(buf, 0, sizeof(buf));
+	buf_size = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (buf[0] == 'd') {
+		dev_info(&i2c_client->dev, "%s, set daymode\n", __func__);
+		// max96712_read_reg(&i2c_client->dev, 0x0010, &val);
+		return count;
+	}
+
+	if (buf[0] == 'n') {
+		dev_info(&i2c_client->dev, "%s, set nightmode\n", __func__);
+		return count;
+	}
+
+	return count;
+}
+
+
+static const struct file_operations max96712_debugfs_fops = {
+	.open = max96712_debugfs_open,
+	.read = seq_read,
+	.write = max96712_debugfs_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+int max96712_power_on(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+
+	if (priv->reset_gpio > 0) {
+
+		gpio_direction_output(priv->reset_gpio, 1);
+
+		if(gpio_cansleep(priv->reset_gpio))
+			gpio_set_value_cansleep(priv->reset_gpio, 0);
+		else
+			gpio_set_value(priv->reset_gpio, 0);
+	
+		usleep_range(30, 50);
+
+		if(gpio_cansleep(priv->reset_gpio))
+			gpio_set_value_cansleep(priv->reset_gpio, 1);
+		else
+			gpio_set_value(priv->reset_gpio, 1);
+
+		msleep(100);
+		dev_info(dev, "%s\n", __func__);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(max96712_power_on);
+
+void max96712_power_off(struct device *dev)
+{
+	struct max96712 *priv = dev_get_drvdata(dev);
+
+	if (priv->reset_gpio > 0) {
+		if(gpio_cansleep(priv->reset_gpio))
+			gpio_set_value_cansleep(priv->reset_gpio, 0);
+		else
+			gpio_set_value(priv->reset_gpio, 0);
+		dev_info(dev, "%s\n", __func__);
+	}
+}
+EXPORT_SYMBOL(max96712_power_off);
+
+static int max96712_debugfs_init(const char *dir_name,
+				struct dentry **d_entry,
+				struct dentry **f_entry,
+				struct max96712 *priv)
+{
+	struct dentry  *dp, *fp;
+	char dev_name[20];
+	struct i2c_client *i2c_client = priv->i2c_client;
+	int err = 0;
+
+	err = snprintf(dev_name, sizeof(dev_name), "max96712_%d", priv->index);
+	if (err < 0)
+		return -EINVAL;
+
+	dp = debugfs_create_dir(dev_name, NULL);
+	if (dp == NULL) {
+		dev_err(&i2c_client->dev, "%s: debugfs create dir failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	fp = debugfs_create_file("max96712", 0644, dp, priv, &max96712_debugfs_fops);
+	if (!fp) {
+		dev_err(&i2c_client->dev, "%s: debugfs create file failed\n", __func__);
+		debugfs_remove_recursive(dp);
+		return -ENOMEM;
+	}
+
+	if (d_entry)
+		*d_entry = dp;
+	if (f_entry)
+		*f_entry = fp;
+
+	return 0;
+}
+
+static const struct of_device_id max96712_of_match[] = {
+	{ .compatible = "maxim,obc_max96712", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, max96712_of_match);
+
+static int max96712_parse_dt(struct max96712 *priv, struct i2c_client *client)
+{
+	struct device_node *node = client->dev.of_node;
+	const struct of_device_id *match;
+	const char *str_value;
+	int value, err = 0;
+
+	if (!node)
+		return -EINVAL;
+
+	match = of_match_device(max96712_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return -EFAULT;
+	}
+
+	err = of_property_read_u32(node, "index", &value);
+	if (err)
+		dev_err(&client->dev, "index not found\n");
+
+	if(value >= 0 && value < 4)
+		priv->index = value;
+	else
+		priv->index = 0;
+	dev_dbg(&client->dev, "%s: index %d\n", __func__, priv->index);
+
+	err = of_property_read_string(node, "csi-mode", &str_value);
+	if (err < 0) {
+		dev_err(&client->dev, "csi-mode property not found\n");
+		return err;
+	}
+
+	if (!strcmp(str_value, "2x4")) {
+		priv->csi_mode = MAX96712_CSI_MODE_2X4;
+	} else if (!strcmp(str_value, "4x2")) {
+		priv->csi_mode = MAX96712_CSI_MODE_4X2;
+	} else {
+		dev_err(&client->dev, "invalid csi mode\n");
+		return -EINVAL;
+	}
+
+	err = of_property_read_u32(node, "seri-addr", &value);
+	if (err)
+		dev_err(&client->dev, "seri-addr not found\n");
+	priv->seri_start_addr = value;
+
+	err = of_property_read_u32(node, "proxy-addr", &value);
+	if (err)
+		dev_err(&client->dev, "proxy-addr not found\n");
+	priv->snr_proxy_addr = value;
+
+	err = of_property_read_u32(node, "real-addr", &value);
+	if (err)
+		dev_err(&client->dev, "real-addr not found\n");
+	priv->snr_real_addr = value;
+
+	priv->deser_addr = client->addr;
+	err = of_property_read_u32(node, "fsync_mfp_index", &value);
+	if (err < 0) {
+		priv->fsync_mfp_x = 2;
+		dev_err(&client->dev, "No fsync_mfp_index info\n");
+	} else {
+		priv->fsync_mfp_x = value;
+	}
+
+	err = of_property_read_u32(node, "pps_mfp_index", &value);
+	if (err < 0) {
+		priv->pps_mfp_x = 9;
+		dev_err(&client->dev, "No pps_mfp_index info\n");
+	} else {
+		priv->pps_mfp_x = value;
+	}
+
+	priv->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
+	if (priv->reset_gpio < 0)
+		dev_err(&client->dev, "reset-gpios not found %d\n", err);
+
+	if (of_get_property(node, "vdd_supply_1v2", NULL)) {
+		priv->vdd_supply_1v2 = 1;
+	} else {
+		priv->vdd_supply_1v2 = 0;
+	}
+	return 0;
+}
+
+static struct regmap_config max96712_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE, // REGCACHE_RBTREE,
+};
+
+#if defined(NV_I2C_DRIVER_STRUCT_PROBE_WITHOUT_I2C_DEVICE_ID_ARG) /* Linux 6.3 */
+static int max96712_probe(struct i2c_client *client)
+#else
+static int max96712_probe(struct i2c_client *client, const struct i2c_device_id *id)
+#endif
+{
+	struct max96712 *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &max96712_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev, "regmap init i2c failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+	dev_set_drvdata(&client->dev, priv);
+
+	err = max96712_parse_dt(priv, client);   //parse devicetree
+	if (err) {
+		dev_err(&client->dev, "parse devicetree error, %d\n", err);
+		return -EFAULT;
+	}
+
+	mutex_init(&priv->lock);
+
+	max96712_power_off(&client->dev);
+	msleep(400);
+	err = max96712_power_on(&client->dev);
+	if (err) {
+		dev_err(&client->dev, "power on failed, %d\n", err);
+		return err;
+	}
+	msleep(200);
+
+	err = max96712_debugfs_init(NULL, NULL, NULL, priv);
+	if (err)
+		return err;
+
+	/* Serializer i2c address trans */
+	err = max96712_seri_i2c_addr_trans(&client->dev);
+	if(err) {
+		dev_err(&client->dev, "Serializer i2c address change failed, %d\n", err);
+		return 0; //err;
+	}
+
+	err = max96712_init_settings(&client->dev);
+	if(err) {
+		dev_err(&client->dev, "max96712 init settings failed, %d\n", err);
+		return 0; //err;
+	}
+
+	err = max96712_set_snr_proxy_addr(&client->dev);
+	if(err) {
+		dev_err(&client->dev, "max96712 set_snr_proxy_addr failed, %d\n", err);
+		return 0; //err;
+	}
+
+	err = max96712_set_all_links_sensor_off(&client->dev);
+	{
+		dev_err(&client->dev, "max96712_set_all_links_sensor_off failed, %d\n", err);
+		return 0; //err;
+	}
+	/*set daymode by fault*/
+	dev_info(&client->dev, "%s: success\n", __func__);
+
+	return 0; //err;
+}
+
+#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+static int max96712_remove(struct i2c_client *client)
+#else
+static void max96712_remove(struct i2c_client *client)
+#endif
+{
+	struct max96712 *priv;
+
+	if (client != NULL) {
+		priv = dev_get_drvdata(&client->dev);
+		mutex_destroy(&priv->lock);
+		//i2c_unregister_device(client);
+		client = NULL;
+	}
+#if defined(NV_I2C_DRIVER_STRUCT_REMOVE_RETURN_TYPE_INT) /* Linux 6.1 */
+	return 0;
+#endif
+}
+
+static const struct i2c_device_id max96712_id[] = {
+	{ "obc_max96712", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, max96712_id);
+
+static struct i2c_driver max96712_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "obc_max96712",
+		.of_match_table = of_match_ptr(max96712_of_match),
+	},
+	.probe = max96712_probe,
+	.remove = max96712_remove,
+	.id_table = max96712_id,
+};
+
+module_i2c_driver(max96712_i2c_driver);
+
+MODULE_DESCRIPTION("IO Expander driver max96712");
+MODULE_AUTHOR("NVIDIA Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c
index 0e6b74ac6..6e65fbdac 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c
@@ -242,7 +242,7 @@ int vi_channel_close_ex(
 
 	mutex_lock(&chan_drv->lock);
 
-	WARN_ON(rcu_access_pointer(chan_drv->channels[channel]) != chan);
+	//WARN_ON(rcu_access_pointer(chan_drv->channels[channel]) != chan);
 	RCU_INIT_POINTER(chan_drv->channels[channel], NULL);
 
 	mutex_unlock(&chan_drv->lock);
@@ -297,7 +297,8 @@ static int vi_channel_release(
 	struct tegra_vi_channel *chan = file->private_data;
 	unsigned int channel = iminor(inode);
 
-	vi_channel_close_ex(channel, chan);
+	if(chan != NULL) //orbbec add
+		vi_channel_close_ex(channel, chan);
 
 	return 0;
 }
@@ -417,8 +418,10 @@ static long vi_channel_ioctl(
 		if (err < 0) {
 			dev_err(chan->dev,
 				"%s: memory setup failed\n", __func__);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) { //orbbec add
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			return -EFAULT;
 		}
 
@@ -429,8 +432,10 @@ static long vi_channel_ioctl(
 				"%s: descriptor buffer is too small for given queue depth\n",
 				__func__);
 			capture_common_unpin_memory(&capture->requests);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) { //orbbec add
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			return -ENOMEM;
 		}
 
@@ -439,8 +444,10 @@ static long vi_channel_ioctl(
 		if (err < 0) {
 			dev_err(chan->dev, "vi capture setup failed\n");
 			capture_common_unpin_memory(&capture->requests);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) { //orbbec add
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			return err;
 		}
 		break;
@@ -478,8 +485,10 @@ static long vi_channel_ioctl(
 			for (i = 0; i < capture->queue_depth; i++)
 				vi_capture_request_unpin(chan, i);
 			capture_common_unpin_memory(&capture->requests);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) { //orbbec add
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			vfree(capture->unpins_list);
 			capture->unpins_list = NULL;
 		}
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c
index 92cc2fdf9..31054bee6 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/sensor_common.c
@@ -267,6 +267,12 @@ static int extract_pixel_format(
 		*format = V4L2_PIX_FMT_UYVY;
 	else if (strncmp(pixel_t, "yuv_vyuy16", size) == 0)
 		*format = V4L2_PIX_FMT_VYUY;
+#if 1 //orbbec add
+	else if (strncmp(pixel_t, "grey_y8", size) == 0)
+		*format = V4L2_PIX_FMT_GREY;
+	else if (strncmp(pixel_t, "grey_y16", size) == 0)
+		*format = V4L2_PIX_FMT_Y16;
+#endif
 	else {
 		pr_err("%s: Need to extend format%s\n", __func__, pixel_t);
 		return -EINVAL;
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c
index 91f8d5f83..74620fd81 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/channel.c
@@ -202,7 +202,7 @@ static void tegra_channel_fmt_align(struct tegra_channel *chan,
 	 * different. Aligned width also may force a sensor mode change other
 	 * than the requested one
 	 */
-	*height = clamp(*height, TEGRA_MIN_HEIGHT, TEGRA_MAX_HEIGHT);
+	*height = clamp(*height, 1U /*TEGRA_MIN_HEIGHT*/, TEGRA_MAX_HEIGHT); //orbbec modify
 
 	/* Clamp the requested bytes per line value. If the maximum bytes per
 	 * line value is zero, the module doesn't support user configurable line
@@ -503,12 +503,13 @@ void free_ring_buffers(struct tegra_channel *chan, int frames)
 		 * the second buffer is intermittently frame of zeros
 		 * with no error status or padding.
 		 */
+	#if 0 //orbbec del
 		/* This will drop the first two frames. Disable for now. */
 		if (chan->capture_state != CAPTURE_GOOD ||
 			chan->released_bufs < 2)
 			chan->buffer_state[chan->free_index] =
 						VB2_BUF_STATE_ERROR;
-
+    #endif
 		if (chan->sequence == 1) {
 			/*
 			 * Evaluate the initial capture latency
@@ -1027,7 +1028,8 @@ tegra_channel_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 
 	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 	cap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;
-	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_META_CAPTURE; //orbbec add
 
 	len = strscpy(cap->driver, "tegra-video", sizeof(cap->driver));
 	if (len < 0)
@@ -2224,6 +2226,65 @@ static long tegra_channel_default_ioctl(struct file *file, void *fh,
 	return ret;
 }
 
+#if 1 //orbbec add
+static int
+__tegra_channel_get_parm(struct tegra_channel *chan,
+			  struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+	struct v4l2_subdev_frame_interval interval;
+
+	/* dmipx: fixing G_PARM EINVAL error */
+	interval.pad = 0;
+	ret = v4l2_subdev_call(sd, video, g_frame_interval, &interval);
+	// ret = sd->ops->video->g_frame_interval(sd, &interval);
+
+	a->parm.capture.timeperframe.numerator = interval.interval.numerator;
+	a->parm.capture.timeperframe.denominator = interval.interval.denominator;
+
+	return ret;
+}
+
+static int tegra_channel_get_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	a->parm.capture.timeperframe.numerator = 1;
+	a->parm.capture.timeperframe.denominator = 12;
+
+	return __tegra_channel_get_parm(chan, a);
+}
+
+static int
+__tegra_channel_set_parm(struct tegra_channel *chan,
+			  struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+
+	struct v4l2_subdev_frame_interval interval;
+	interval.pad = 0;
+	interval.interval.numerator = a->parm.capture.timeperframe.numerator;
+	interval.interval.denominator = a->parm.capture.timeperframe.denominator;
+
+	ret = v4l2_subdev_call(sd, video, s_frame_interval, &interval);
+	// ret = sd->ops->video->s_frame_interval(sd, &interval);
+	if (ret == -ENOIOCTLCMD)
+			return -ENOTTY;
+
+	return ret;
+}
+static int tegra_channel_set_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	if (vb2_is_busy(&chan->queue))
+			return -EBUSY;
+
+	return __tegra_channel_set_parm(chan, a);
+}
+#endif
 static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {
 	.vidioc_querycap		= tegra_channel_querycap,
 	.vidioc_enum_framesizes		= tegra_channel_enum_framesizes,
@@ -2255,6 +2316,8 @@ static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {
 	.vidioc_s_input			= tegra_channel_s_input,
 	.vidioc_log_status		= tegra_channel_log_status,
 	.vidioc_default			= tegra_channel_default_ioctl,
+	.vidioc_g_parm			= tegra_channel_get_parm, //orbbec add
+	.vidioc_s_parm			= tegra_channel_set_parm, //orbbec add
 };
 
 static int tegra_channel_close(struct file *fp);
@@ -2470,6 +2533,333 @@ static int tegra_channel_csi_init(struct tegra_channel *chan)
 	return ret;
 }
 
+#if 1 //add metadata support, orbbec add
+static int tegra_metadata_open(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret;
+
+	mutex_lock(&chan->embedded.lock);
+	ret = v4l2_fh_open(fp);
+	mutex_unlock(&chan->embedded.lock);
+
+	return ret;
+}
+
+static int tegra_metadata_close(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret = _vb2_fop_release(fp, &chan->embedded.lock);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations tegra_metadata_fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.open           = tegra_metadata_open,
+	.release        = tegra_metadata_close,
+	.read           = vb2_fop_read,
+	.poll           = vb2_fop_poll,
+	.mmap           = vb2_fop_mmap,
+};
+
+static int tegra_metadata_querycap(struct file *file, void *fh,
+                                 struct v4l2_capability *cap)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct tegra_channel *chan = video_drvdata(file);
+
+	/* FIXME: why do Device Caps show V4L2_CAP_EXT_PIX_FORMAT? */
+	cap->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_EXT_PIX_FORMAT | V4L2_CAP_VIDEO_CAPTURE;
+
+	strlcpy(cap->driver, "tegra-embedded", sizeof(cap->driver));
+	strlcpy(cap->card, vfh->vdev->name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",
+			dev_name(chan->vi->dev), chan->port[0]);
+
+	return 0;
+}
+
+static int tegra_metadata_enum_format(struct file *file, void *fh,
+                                     struct v4l2_fmtdesc *f)
+{
+	if (f->index)
+		return -EINVAL;
+
+	f->pixelformat = V4L2_META_FMT_G300;
+	strlcpy(f->description, "G300 metadata format", sizeof(f->description));
+
+	return 0;
+}
+
+static int tegra_metadata_get_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct v4l2_meta_format *fmt = &format->fmt.meta;
+
+	if (format->type != vfh->vdev->queue->type)
+		return -EINVAL;
+
+	memset(fmt, 0, sizeof(*fmt));
+
+	fmt->dataformat = V4L2_META_FMT_G300;
+	fmt->buffersize = 96; //255, orbbec modify
+
+	return 0;
+}
+static int tegra_metadata_set_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+   return 0;
+}
+
+static int tegra_metadata_try_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+    return 0;
+}
+static const struct v4l2_ioctl_ops tegra_metadata_ioctl_ops = {
+	.vidioc_querycap                = tegra_metadata_querycap,
+	.vidioc_enum_fmt_meta_cap       = tegra_metadata_enum_format,
+	.vidioc_g_fmt_meta_cap          = tegra_metadata_get_format,
+	.vidioc_s_fmt_meta_cap          = tegra_metadata_set_format,
+	.vidioc_try_fmt_meta_cap        = tegra_metadata_try_format,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+};
+
+static int tegra_metadata_queue_setup(struct vb2_queue *vq,
+                    unsigned int *nbuffers, unsigned int *nplanes,
+                    unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+
+	if (*nplanes) {
+		if (*nplanes != 1)
+			return -EINVAL;
+
+		if (sizes[0] < 96) //255, orbbec modify
+			return -EINVAL;
+
+		return 0;
+	}
+
+	*nplanes = 1;
+	sizes[0] = 96; //255, orbbec modify
+	alloc_devs[0] = chan->vi->dev;
+
+
+	return 0;
+}
+
+static int tegra_metadata_buffer_prepare(struct vb2_buffer *vb)
+{
+	if (vb->num_planes != 1)
+		return -EINVAL;
+
+	if (vb2_plane_size(vb, 0) < 96) //255, orbbec modify
+		return -EINVAL;
+
+	return 0;
+}
+
+static void tegra_metadata_buffer_queue(struct vb2_buffer *vb)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vb->vb2_queue);
+
+	spin_lock(&chan->embedded.spin_lock);
+	if (chan->embedded.num_buffers < 16) {
+		chan->embedded.buffers[chan->embedded.head] = vb;
+		chan->embedded.head++;
+		if (chan->embedded.head > 15)
+			chan->embedded.head = chan->embedded.head - 16;
+		chan->embedded.num_buffers++;
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+}
+
+static int tegra_metadata_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	return 0;
+}
+
+static void tegra_metadata_stop_streaming(struct vb2_queue *vq)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	int i = 0;
+
+	spin_lock(&chan->embedded.spin_lock);
+	for (i = 0; i < chan->embedded.num_buffers; i++) {
+		struct vb2_buffer *evb;
+		evb = chan->embedded.buffers[chan->embedded.tail];
+		chan->embedded.buffers[chan->embedded.tail] = NULL;
+		chan->embedded.tail++;
+		if (chan->embedded.tail > 15)
+			chan->embedded.tail = chan->embedded.tail - 16;
+		vb2_buffer_done(evb, VB2_BUF_STATE_ERROR);
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+
+	chan->embedded.head = 0;
+	chan->embedded.tail = 0;;
+	chan->embedded.num_buffers = 0;
+}
+
+static const struct vb2_ops tegra_metadata_qops = {
+	.queue_setup            = tegra_metadata_queue_setup,
+	.buf_prepare            = tegra_metadata_buffer_prepare,
+	.buf_queue              = tegra_metadata_buffer_queue,
+	.wait_prepare           = vb2_ops_wait_prepare,
+	.wait_finish            = vb2_ops_wait_finish,
+	.start_streaming        = tegra_metadata_start_streaming,
+	.stop_streaming         = tegra_metadata_stop_streaming,
+};
+
+int tegra_channel_init_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret;
+
+	mutex_init(&chan->embedded.lock);
+	spin_lock_init(&chan->embedded.spin_lock);
+
+	video = chan->embedded.video = video_device_alloc();
+	chan->embedded.pad.flags = MEDIA_PAD_FL_SINK;
+
+	ret = tegra_media_entity_init(&video->entity, 1,
+									&chan->embedded.pad, false, false);
+	if (ret < 0) {
+		video_device_release(video);
+		dev_err(vi->dev, "%s(): metadata entity init: %d\n",
+				__func__, ret);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_handler_init(&chan->embedded.ctrl_handler,
+									MAX_CID_CONTROLS);
+	if (chan->embedded.ctrl_handler.error) {
+		dev_err(&video->dev, "failed to init control handler\n");
+		return ret;
+	}
+
+	video->fops = &tegra_metadata_fops;
+	video->v4l2_dev = &vi->v4l2_dev;
+	video->queue = queue;
+	snprintf(video->name, sizeof(video->name), "%s-metadata-%u",
+			dev_name(vi->dev), chan->port[0]);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	video->vfl_type = VFL_TYPE_GRABBER;
+#else
+	video->vfl_type = VFL_TYPE_VIDEO;
+	video->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+#endif
+	video->vfl_dir = VFL_DIR_RX;
+	video->release = video_device_release_empty;
+	video->ioctl_ops = &tegra_metadata_ioctl_ops;
+	video->ctrl_handler = &chan->embedded.ctrl_handler;
+	video->lock = &chan->embedded.lock;
+
+	video_set_drvdata(video, chan);
+
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+	ret = tegra_vb2_dma_init(vi->dev, &chan->embedded.alloc_ctx,
+					SZ_64K, &vi->vb2_dma_alloc_refcnt);
+	if (ret < 0)
+		goto ctx_alloc_error;
+
+#endif
+//#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+//     chan->embedded.alloc_ctx = vb2_dma_contig_init_ctx(vi->dev);
+//     if (IS_ERR(chan->embedded.alloc_ctx)) {
+//             dev_err(vi->dev, "%s(): vb2 buffer init: %ld\n", __func__,
+//                     PTR_ERR(chan->embedded.alloc_ctx));
+//             goto ctx_alloc_error;
+//     }
+//#endif
+
+	queue->type = V4L2_BUF_TYPE_META_CAPTURE;
+	queue->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ | VB2_USERPTR;
+	queue->lock = &chan->embedded.lock;
+	queue->drv_priv = chan;
+	queue->buf_struct_size = sizeof(struct tegra_channel_buffer);
+	queue->ops = &tegra_metadata_qops;
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	queue->mem_ops = &vb2_dma_contig_memops;
+#endif
+	queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC |
+			V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	ret = vb2_queue_init(queue);
+	if (ret < 0) {
+		dev_err(vi->dev, "%s(): metadata queue initialize: %d\n",
+				__func__, ret);
+		goto vb2_queue_error;
+	}
+
+	return 0;
+
+vb2_queue_error:
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	tegra_vb2_dma_cleanup(vi->dev, chan->embedded.alloc_ctx,
+			&vi->vb2_dma_alloc_refcnt);
+ctx_alloc_error:
+#endif
+	media_entity_cleanup(&video->entity);
+
+	return ret;
+}
+
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video = chan->embedded.video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	if (!video)
+		return -EINVAL;
+
+	video_unregister_device(video);
+
+	/* release embedded data buffer */
+	if (chan->emb_buf_size > 0) {
+		dma_free_coherent(vi_unit_dev,
+				chan->emb_buf_size,
+				chan->emb_buf_addr, chan->emb_buf);
+		chan->emb_buf_size = 0;
+		vb2_queue_release(queue);
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+		tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+						&chan->vi->vb2_dma_alloc_refcnt);
+#endif
+	}
+
+	v4l2_ctrl_handler_free(&chan->embedded.ctrl_handler);
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&video->entity);
+#endif
+
+	video_device_release(video);
+
+	return 0;
+}
+#endif
+
 int tegra_channel_init_video(struct tegra_channel *chan)
 {
 	struct tegra_mc_vi *vi = chan->vi;
@@ -2656,6 +3046,15 @@ int tegra_channel_cleanup(struct tegra_channel *chan)
 			chan->emb_buf_size,
 			chan->emb_buf_addr, chan->emb_buf);
 		chan->emb_buf_size = 0;
+#if 1 //metadata, orbbec add
+		vb2_queue_release(&chan->embedded.queue);
+	#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+		tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+			&chan->vi->vb2_dma_alloc_refcnt);
+		//vb2_dma_contig_cleanup_ctx(chan->embedded.alloc_ctx);
+	#endif
+		media_entity_cleanup(&chan->embedded.video->entity);
+#endif
 	}
 
 	tegra_channel_dealloc_buffer_queue(chan);
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c
index 7c2d05e74..175959f4b 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/graph.c
@@ -292,6 +292,12 @@ static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
 	struct tegra_channel *chan =
 		container_of(notifier, struct tegra_channel, notifier);
 	struct tegra_vi_graph_entity *entity;
+#if 1 //orbbec add
+	struct camera_common_data *s_data;
+	struct device_node *node;
+	struct sensor_mode_properties *sensor_mode = NULL;
+	int idx;
+#endif
 	int ret;
 
 	dev_dbg(chan->vi->dev, "notify complete, all subdevs registered\n");
@@ -325,16 +331,49 @@ static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
 	if (ret < 0)
 		goto graph_error;
 
+#if 1 //orbbec add
+	/* Init embedded channel only if embedded is set in DT*/
+	s_data = to_camera_common_data(chan->subdev_on_csi->dev);
+	node = chan->subdev_on_csi->dev->of_node;
+	if (s_data && node) {
+		idx = s_data->mode_prop_idx;
+		if (idx < s_data->sensor_props.num_modes)
+			sensor_mode = &s_data->sensor_props.sensor_modes[idx];
+	}
+
+	if (sensor_mode &&
+		sensor_mode->image_properties.embedded_metadata_height > 0) {
+		ret = tegra_channel_init_video_embedded(chan);
+		if (ret < 0) {
+			dev_err(chan->vi->dev,
+					"failed to initialize embedded channel\n");
+			goto register_embedded_device_error;
+		}
+		ret = video_register_device(chan->embedded.video, VFL_TYPE_VIDEO, -1);
+		if (ret < 0) {
+			dev_err(&chan->video->dev, "failed to register embedded %s: %d\n",
+					chan->embedded.video->name, ret);
+			goto register_embedded_device_error;
+		}
+	}
+#endif
+
 	ret = v4l2_device_register_subdev_nodes(&chan->vi->v4l2_dev);
 	if (ret < 0) {
 		dev_err(chan->vi->dev, "failed to register subdev nodes\n");
-		goto graph_error;
+		goto register_nodes_error; //graph_error; orbbec modify
 	}
 
 	chan->link_status++;
 
 	return 0;
 
+#if 1 //orbbec add
+register_nodes_error:
+	video_unregister_device(chan->embedded.video);
+register_embedded_device_error:
+	tegra_vi_graph_remove_links(chan);
+#endif
 graph_error:
 	video_unregister_device(chan->video);
 register_device_error:
@@ -398,6 +437,7 @@ static void tegra_vi_graph_notify_unbind(struct v4l2_async_notifier *notifier,
 
 	/* cleanup for complete */
 	if (chan->link_status) {
+		tegra_channel_cleanup_video_embedded(chan); //orbbec add
 		tegra_vi_graph_remove_links(chan);
 		tegra_channel_cleanup_video(chan);
 		chan->link_status--;
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c
index 7b16dcaf3..c5af2e01f 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_fops.c
@@ -426,6 +426,41 @@ static void vi5_setup_surface(struct tegra_channel *chan,
 		chan->capture_descr_sequence += 1;
 }
 
+#if 1 //orbbec add
+static void vi5_release_metadata_buffer(struct tegra_channel *chan,
+	struct vb2_v4l2_buffer *vbuf)
+{
+	struct vb2_buffer *evb = NULL;
+	struct vb2_v4l2_buffer *evbuf;
+	void* frm_buffer;
+
+	spin_lock(&chan->embedded.spin_lock);
+	if (0 < chan->embedded.num_buffers) {
+		evb = chan->embedded.buffers[chan->embedded.tail];
+		chan->embedded.buffers[chan->embedded.tail] = NULL;
+		chan->embedded.tail++;
+		if (chan->embedded.tail > 15)
+			chan->embedded.tail = chan->embedded.tail - 16;
+		chan->embedded.num_buffers--;
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+
+	if (!evb)
+		return;
+
+	frm_buffer = vb2_plane_vaddr(evb, 0);
+	if (!frm_buffer)
+		return;
+
+	memcpy(frm_buffer, chan->emb_buf_addr, 96); //255, orbbec modify
+	evbuf = to_vb2_v4l2_buffer(evb);
+	evbuf->sequence = vbuf->sequence;
+	vb2_set_plane_payload(evb, 0, 96); //68, orbbec modify
+	evb->timestamp = vbuf->vb2_buf.timestamp;
+	vb2_buffer_done(evb, VB2_BUF_STATE_DONE);
+}
+#endif
+
 static void vi5_release_buffer(struct tegra_channel *chan,
 	struct tegra_channel_buffer *buf)
 {
@@ -436,6 +471,11 @@ static void vi5_release_buffer(struct tegra_channel *chan,
 	vb2_set_plane_payload(&vbuf->vb2_buf, 0, chan->format.sizeimage);
 
 	vb2_buffer_done(&vbuf->vb2_buf, buf->vb2_state);
+
+#if 1 //orbbec add
+	if (chan->embedded_data_height == 1 && buf->vb2_state == VB2_BUF_STATE_DONE)
+		vi5_release_metadata_buffer(chan, vbuf);
+#endif
 }
 
 static void vi5_capture_enqueue(struct tegra_channel *chan,
@@ -511,8 +551,8 @@ static void vi5_capture_dequeue(struct tegra_channel *chan,
 		if (err) {
 			if (err == -ETIMEDOUT) {
 				dev_err(vi->dev,
-					"uncorr_err: request timed out after %d ms\n",
-					CAPTURE_TIMEOUT_MS);
+					"uncorr_err: request timed out after %d ms, port=%d, vc-id=%d\n",
+					CAPTURE_TIMEOUT_MS, vi_port, chan->virtual_channel);
 			} else {
 				dev_err(vi->dev, "uncorr_err: request err %d\n", err);
 			}
@@ -526,9 +566,15 @@ static void vi5_capture_dequeue(struct tegra_channel *chan,
 			} else {
 				dev_warn(vi->dev,
 					"corr_err: discarding frame %d, flags: %d, "
-					"err_data %d\n",
+					"err_data %d, vc: %d\n",
 					descr->status.frame_id, descr->status.flags,
-					descr->status.err_data);
+					descr->status.err_data, chan->virtual_channel);
+
+				/* G335Lg: err_data 131072 (20000h) | 64 (40h) | 4194400 (400060h) |262144(40000) | 256 (100h)leading to channel
+				* timeout. This happens when first frame is corrupted - no md
+				* and less lines than requested. Channel reset time is 6ms */
+				if (descr->status.err_data & 0x460160) //orbbec add
+					goto uncorr_err;
 				frame_err = true;
 			}
 		} else if (!vi_port) {
@@ -583,16 +629,27 @@ static int vi5_channel_error_recover(struct tegra_channel *chan,
 	struct tegra_mc_vi *vi = chan->vi;
 	struct v4l2_subdev *csi_subdev;
 
+	dev_info(chan->vi->dev, "%s() vc: %d\n", __func__, chan->virtual_channel);
+
 	/* stop vi channel */
 	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+		if(chan->tegra_vi_channel[vi_port] != NULL) //orbbec add
+			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
 		if (err) {
 			dev_err(&chan->video->dev, "vi capture release failed\n");
 			goto done;
 		}
 		vi_channel_close_ex(chan->vi_channel_id[vi_port],
 					chan->tegra_vi_channel[vi_port]);
+
+		/* Release capture requests */
+		if (chan->request[vi_port] != NULL) {
+			dma_free_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
+			chan->capture_queue_depth * sizeof(struct capture_descriptor),
+			chan->request[vi_port], chan->request_iova[vi_port]);
+		}
+		chan->request[vi_port] = NULL;
 		chan->tegra_vi_channel[vi_port] = NULL;
 	}
 
@@ -930,10 +987,11 @@ err_set_stream:
 
 err_start_kthreads:
 	if (!chan->bypass)
-		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++)
-			vi_capture_release(chan->tegra_vi_channel[vi_port],
-				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
-
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+			if(chan->tegra_vi_channel[vi_port] != NULL) //orbbec add
+				vi_capture_release(chan->tegra_vi_channel[vi_port],
+					CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+	}
 err_setup:
 	if (!chan->bypass)
 		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
@@ -962,8 +1020,9 @@ static int vi5_channel_stop_streaming(struct vb2_queue *vq)
 
 	if (!chan->bypass) {
 		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+			if(chan->tegra_vi_channel[vi_port] != NULL) //orbbec add
+				err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+					CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
 
 			if (err)
 				dev_err(&chan->video->dev,
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h
index 1d0c1133c..d7e8bf041 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/media/platform/tegra/camera/vi/vi5_formats.h
@@ -82,14 +82,21 @@ static const struct tegra_video_format vi5_video_formats[] = {
 	/* RAW 7: TODO */
 
 	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_R8,
+				RAW8, GREY, "Greyscale 8"), //orbbec add
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_R8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_R8,
 				RAW8, SGRBG8, "GRGR.. BGBG.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGBRG8_1X8, 1, 1, T_R8,
 				RAW8, SGBRG8, "GBGB.. RGRG.."),
+#if 0 //orbbec del
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SBGGR8_1X8, 1, 1, T_R8,
 				RAW8, SBGGR8, "BGBG.. GRGR.."),
+#else //orbbec add
+	TEGRA_VIDEO_FORMAT(RAW8, 8, SBGGR8_1X8, 1, 1, T_R8,
+				RAW8, MJPEG, "Motion-JPEG"),
+#endif
 
 	/* RAW 10 */
 	TEGRA_VIDEO_FORMAT(RAW10, 10, SRGGB10_1X10, 2, 1, T_R16,
@@ -100,34 +107,50 @@ static const struct tegra_video_format vi5_video_formats[] = {
 				RAW10, SGBRG10, "GBGB.. RGRG.."),
 	TEGRA_VIDEO_FORMAT(RAW10, 10, SBGGR10_1X10, 2, 1, T_R16,
 				RAW10, SBGGR10, "BGBG.. GRGR.."),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, Y10_1X10, 2, 1, T_R16,
+				RAW10, Y10, "10-bit Greyscale"), //Orbbec add
 
 	/* RAW 12 */
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SRGGB12_1X12, 2, 1, T_R16,
 				RAW12, SRGGB12, "RGRG.. GBGB.."),
+#if 0 /* orbbec del */
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SGRBG12_1X12, 2, 1, T_R16,
 				RAW12, SGRBG12, "GRGR.. BGBG.."),
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SGBRG12_1X12, 2, 1, T_R16,
 				RAW12, SGBRG12, "GBGB.. RGRG.."),
 	TEGRA_VIDEO_FORMAT(RAW12, 12, SBGGR12_1X12, 2, 1, T_R16,
 				RAW12, SBGGR12, "BGBG.. GRGR.."),
+#else /* orbbec add */
+	TEGRA_VIDEO_FORMAT(RAW12, 12, Y12_1X12, 2, 1, T_R16,
+				RAW12, Y12, "12-bit Greyscale"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SGRBG12_1X12, 2, 1, T_R16,
+				RAW12, NV12, "Y/CbCr 4:2:0"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SGBRG12_1X12, 2, 1, T_R16,
+				RAW12, NV21, "Y/CbCr 4:2:0"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SBGGR12_1X12, 2, 1, T_R16,
+				RAW12, H264, "H.264"),
 
+	/* RAW 14 */
+	TEGRA_VIDEO_FORMAT(RAW14, 14, Y14_1X14, 2, 1, T_R16,
+				RAW14, Y14, "14-bit Greyscale"),
+#endif
 	/* RGB888 */
-	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
-				RGB888, RGBA32, "RGBA-8-8-8-8"),
+	// TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+	// 			RGB888, RGBA32, "RGBA-8-8-8-8"), //orbbec del
 	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X32_PADHI, 4, 1, T_A8B8G8R8,
 				RGB888, RGB32, "RGB-8-8-8-8"),
 
 	/* YUV422 */
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
-				YUV422_8, VYUY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+	// 			YUV422_8, VYUY, "YUV 4:2:2"), //orbbec del
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
 				YUV422_8, YUYV, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
-				YUV422_8, NV16, "NV16"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+	// 			YUV422_8, NV16, "NV16"), //orbbec del
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
@@ -136,6 +159,14 @@ static const struct tegra_video_format vi5_video_formats[] = {
 				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+
+#if 1 //orbbec add
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, Z16, "Depth 16"),
+
+	TEGRA_VIDEO_FORMAT(YUV422, 16, Y16_1X16, 2, 1, T_R16,
+				YUV422_8, Y16, "16-bit Greyscale"),
+#endif
 };
 
 #endif
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/misc/Makefile b/Linux_for_Tegra/source/nvidia-oot/drivers/misc/Makefile
index 9364d84ac..64ff44e7b 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/misc/Makefile
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/misc/Makefile
@@ -11,3 +11,5 @@ endif
 obj-m += bluedroid_pm.o
 obj-m += nvscic2c-pcie/
 obj-m += ioctl_example.o
+# orbbec add
+obj-m += obc_cam_sync.o
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/misc/obc_cam_sync.c b/Linux_for_Tegra/source/nvidia-oot/drivers/misc/obc_cam_sync.c
new file mode 100644
index 000000000..eb4a590a2
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/misc/obc_cam_sync.c
@@ -0,0 +1,874 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <asm/ioctl.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/pwm.h>
+#include <linux/debugfs.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+//--------------------------------------------------------------------------
+#define DELAY_TIME  1 // 20ms
+
+#define FPS_SCALE   100 //0.01 fps
+#define TSC_FPS_SCALE   1000 //0.0001 fps
+
+#define SYNC_HWTIMER_OFFSET_TIME 100 // 100us
+#define SYNC_TSC_OFFSET_TIME 50 // 50us
+//--------------------------------------------------------------------------
+#define CAM_SYNC_START  _IOW('c', 1, int)
+#define CAM_SYNC_STOP   _IOW('c', 2, int)
+
+//--------------------------------------------------------------------------
+
+
+//--------------------------------------------------------------------------
+#define TSC_TICKS_PER_HZ			(31250000ULL)
+#define TSC_NS_PER_TICK				(32)
+#define NS_PER_MS				(1000000U)
+
+#define TSC_MTSCCNTCV0				(0x10)
+#define TSC_MTSCCNTCV0_CV			GENMASK(31, 0)
+
+#define TSC_MTSCCNTCV1				(0x14)
+#define TSC_MTSCCNTCV1_CV			GENMASK(31, 0)
+
+#define TSC_GENX_CTRL				(0x00)
+#define TSC_GENX_CTRL_RST			(0x00)
+#define TSC_GENX_CTRL_INITIAL_VAL		BIT(1)
+#define TSC_GENX_CTRL_ENABLE			BIT(0)
+
+#define TSC_GENX_START0				(0x04)
+#define TSC_GENX_START0_LSB_VAL			GENMASK(31, 0)
+
+#define TSC_GENX_START1				(0x08)
+#define TSC_GENX_START1_MSB_VAL			GENMASK(23, 0)
+
+#define TSC_GENX_STATUS				(0x0C)
+#define TSC_GENX_STATUS_INTERRUPT_STATUS	BIT(6)
+#define TSC_GENX_STATUS_VALUE			BIT(5)
+#define TSC_GENX_STATUS_EDGE_ID			GENMASK(4, 2)
+#define TSC_GENX_STATUS_RUNNING			BIT(1)
+#define TSC_GENX_STATUS_WAITING			BIT(0)
+
+#define TSC_GENX_EDGE0				(0x18)
+#define TSC_GENX_EDGE1				(0x1C)
+#define TSC_GENX_EDGE2				(0x20)
+#define TSC_GENX_EDGE3				(0x24)
+#define TSC_GENX_EDGE4				(0x28)
+#define TSC_GENX_EDGE5				(0x2C)
+#define TSC_GENX_EDGE6				(0x30)
+#define TSC_GENX_EDGE7				(0x34)
+
+#define TSC_GENX_EDGEX_INTERRUPT_EN		BIT(31)
+#define TSC_GENX_EDGEX_STOP			BIT(30)
+#define TSC_GENX_EDGEX_TOGGLE			BIT(29)
+#define TSC_GENX_EDGEX_LOOP			BIT(28)
+#define TSC_GENX_EDGEX_OFFSET			GENMASK(27, 0)
+
+/* Time (ms) offset for the TSC signal generators */
+#define TSC_GENX_START_OFFSET_MS		(100)
+
+/**
+ * struct tsc_signal_generator : Generator context.
+ * @base: ioremapped register base.
+ * @of: Generator device node.
+ * @config:
+ *   @freq_hz: Frequency (hz) of the generator.
+ *   @duty_cycle: Duty cycle (%) of the generator.
+ *   @offset_ms: Offset (ms) to shift the signal by.
+ * @debugfs:
+ *   @regset_ro: Debug FS read-only register set.
+ * @list: List node
+ */
+struct tsc_signal_generator {
+	void __iomem *base;
+	struct device_node *of;
+	struct {
+		u32 freq_hz;
+		u32 duty_cycle;
+		u32 offset_ms;
+		u32 gpio_pinmux;
+	} config;
+	struct {
+		struct debugfs_regset32 regset_ro;
+	} debugfs;
+	struct list_head list;
+};
+
+/**
+ * struct tsc_signal_controller : Controller context
+ * @dev: device.
+ * @base: ioremapped register base.
+ * @debugfs:
+ *   @d: dentry to debugfs directory.
+ * @generators: Linked list of child generators.
+ */
+struct tsc_signal_controller {
+	struct device *dev;
+	void __iomem *base;
+	struct {
+		struct dentry *d;
+	} debugfs;
+	struct list_head generators;
+	bool opened;
+
+};
+
+static const struct debugfs_reg32 tsc_signal_generator_debugfs_regset[] = {
+	{
+		.name = "status",
+		.offset = TSC_GENX_STATUS,
+	},
+};
+#define TSC_SIG_GEN_DEBUGFS_REGSET_SIZE ARRAY_SIZE(tsc_signal_generator_debugfs_regset)
+
+static inline void cdi_tsc_generator_writel(struct tsc_signal_generator *generator, u32 reg, u32 val)
+{
+	writel(val, generator->base + reg);
+}
+
+static inline u32 cdi_tsc_generator_readl(struct tsc_signal_generator *generator, u32 reg)
+{
+	return readl(generator->base + reg);
+}
+
+static inline u32 cdi_tsc_controller_readl(struct tsc_signal_controller *controller, u32 reg)
+{
+	return readl(controller->base + reg);
+}
+//--------------------------------------------------------------------------
+
+typedef enum
+{
+    MODE_SYNC_IN,
+    MODE_SYNC_OUT
+} cs_mode_e;
+
+typedef enum
+{
+    NO_TRIGGER,
+    GPIO_TRIGGER,
+    PWM_TRIGGER
+} trigger_type_t;
+
+typedef struct
+{
+    uint8_t mode;
+    uint16_t fps; 
+} cs_param_t;
+
+typedef struct
+{
+    struct mutex lock;
+    struct tsc_signal_controller controller;
+    struct device *dev;
+    struct regulator *reg;
+    struct pwm_device *pwm;
+    struct pwm_state pwm_state;
+    struct hrtimer trigger_timer;
+    struct timer_list delay_timer;
+    cs_param_t param;
+    unsigned long pwm_period;
+    unsigned long pwm_value;
+    uint32_t trigger_type;
+    uint32_t irq; /* IRQ number */
+    unsigned long hdelay;
+    unsigned long ldelay;
+    int sync_in_gpios;
+    int sync_out_gpios;
+    bool irq_enabled;
+    uint8_t is_high;
+    // ktime_t kt;
+} cam_sync_t;
+
+cam_sync_t *cam_sync = NULL;
+int m_lock = 0;
+
+//--------------------------------------------------------------------------
+static int debug_en = 0;
+module_param(debug_en, int, 0644);
+
+//--------------------------------------------------------------------------
+
+static int cdi_tsc_find_and_add_generators(struct tsc_signal_controller *controller)
+{
+	struct tsc_signal_generator *generator;
+	struct device_node *np;
+	struct resource res;
+	const char *node_status;
+	int err;
+
+	for_each_child_of_node(controller->dev->of_node, np) {
+		err = of_property_read_string(np, "status", &node_status);
+		if (err != 0) {
+			dev_err(controller->dev, "Failed to read generator status: %d\n", err);
+			return err;
+		}
+		if (strcmp("okay", node_status) != 0) {
+			dev_dbg(controller->dev, "Generator %s disabled - skipping\n", np->full_name);
+			continue;
+		}
+
+
+		dev_dbg(controller->dev, "Generator found: %s\n", np->full_name);
+
+		generator = devm_kzalloc(controller->dev, sizeof(*generator), GFP_KERNEL);
+		if (!generator)
+			return -ENOMEM;
+
+		/* Read pinmux gpio from DT */
+		generator->config.gpio_pinmux = of_get_named_gpio(np, "gpio_pinmux", 0);
+
+		generator->of = np;
+		INIT_LIST_HEAD(&generator->list);
+
+		if (of_address_to_resource(np, 0, &res))
+			return -EINVAL;
+
+		generator->base = devm_ioremap_resource(controller->dev, &res);
+		if (IS_ERR(generator->base))
+			return PTR_ERR(generator->base);
+
+		err = of_property_read_u32(np, "freq_hz", &generator->config.freq_hz);
+		if (err != 0) {
+			dev_err(controller->dev, "Failed to read generator frequency: %d\n", err);
+			return err;
+		}
+        generator->config.freq_hz = generator->config.freq_hz * TSC_FPS_SCALE;
+		if (generator->config.freq_hz == 0) {
+			dev_err(controller->dev, "Frequency must be non-zero\n");
+			return -EINVAL;
+		}
+
+		err = of_property_read_u32(np, "duty_cycle", &generator->config.duty_cycle);
+		if (err != 0) {
+			dev_err(controller->dev, "Failed to read generator duty cycle: %d\n", err);
+			return err;
+		}
+		if (generator->config.duty_cycle >= 100) {
+			dev_err(controller->dev, "Duty cycle must be < 100%%\n");
+			return -EINVAL;
+		}
+
+		err = of_property_read_u32(np, "offset_ms", &generator->config.offset_ms);
+		if (err != 0) {
+			dev_err(controller->dev, "Failed to read generator offset: %d\n", err);
+			return err;
+		}
+
+		list_add_tail(&generator->list, &cam_sync->controller.generators);
+		dev_dbg(controller->dev, "Generator %s added to controller\n", np->full_name);
+	}
+
+	return 0;
+}
+
+static int cdi_tsc_program_generator_edges(struct tsc_signal_controller *controller)
+{
+	struct tsc_signal_generator *generator;
+	
+	list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+		u32 ticks_in_period = 0;
+		u32 ticks_active = 0;
+		u32 ticks_inactive = 0;
+
+		ticks_in_period = DIV_ROUND_CLOSEST(TSC_TICKS_PER_HZ * TSC_FPS_SCALE, generator->config.freq_hz);
+		
+		ticks_active = TSC_TICKS_PER_HZ/750; //1.5ms
+		ticks_inactive = ticks_in_period - ticks_active;
+
+		cdi_tsc_generator_writel(generator, TSC_GENX_EDGE0,
+			TSC_GENX_EDGEX_TOGGLE |
+			FIELD_PREP(TSC_GENX_EDGEX_OFFSET, ticks_active));
+
+		cdi_tsc_generator_writel(generator, TSC_GENX_EDGE1,
+			TSC_GENX_EDGEX_TOGGLE |
+			TSC_GENX_EDGEX_LOOP |
+			FIELD_PREP(TSC_GENX_EDGEX_OFFSET, ticks_inactive));
+	}
+
+	return 0;
+}
+
+static void cdi_tsc_program_generator_start_values(struct tsc_signal_controller *controller)
+{
+	const u32 relative_ticks_to_start = mult_frac(
+		TSC_GENX_START_OFFSET_MS, NS_PER_MS, TSC_NS_PER_TICK);
+
+	const u32 current_ticks_lo = FIELD_GET(TSC_MTSCCNTCV0_CV,
+		cdi_tsc_controller_readl(controller, TSC_MTSCCNTCV0));
+	const u32 current_ticks_hi = FIELD_GET(TSC_MTSCCNTCV1_CV,
+		cdi_tsc_controller_readl(controller, TSC_MTSCCNTCV1));
+
+	const u64 current_ticks = ((u64)current_ticks_hi << 32) | current_ticks_lo;
+
+	struct tsc_signal_generator *generator;
+
+	list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+		u64 absolute_ticks_to_start = current_ticks + relative_ticks_to_start;
+
+		if (generator->config.offset_ms != 0) {
+			absolute_ticks_to_start += mult_frac(generator->config.offset_ms, NS_PER_MS, TSC_NS_PER_TICK);
+		}
+
+		cdi_tsc_generator_writel(generator, TSC_GENX_START0,
+			FIELD_PREP(TSC_GENX_START0_LSB_VAL, lower_32_bits(absolute_ticks_to_start)));
+
+		cdi_tsc_generator_writel(generator, TSC_GENX_START1,
+			FIELD_PREP(TSC_GENX_START1_MSB_VAL, upper_32_bits(absolute_ticks_to_start)));
+	}
+}
+
+static bool cdi_tsc_generator_is_running(struct tsc_signal_generator *generator)
+{
+	const u32 status = cdi_tsc_generator_readl(generator, TSC_GENX_STATUS);
+
+	return FIELD_GET(TSC_GENX_STATUS_RUNNING, status) == 1;
+}
+
+static bool cdi_tsc_generator_is_waiting(struct tsc_signal_generator *generator)
+{
+	const u32 status = cdi_tsc_generator_readl(generator, TSC_GENX_STATUS);
+
+	return FIELD_GET(TSC_GENX_STATUS_WAITING, status) == 1;
+}
+
+static inline bool cdi_tsc_generator_is_idle(struct tsc_signal_generator *generator)
+{
+	return !cdi_tsc_generator_is_running(generator) &&
+		!cdi_tsc_generator_is_waiting(generator);
+}
+
+static int cdi_tsc_start_generators(struct tsc_signal_controller *controller)
+{
+	struct tsc_signal_generator *generator;
+	int err;
+
+	dev_info(controller->dev, "%s: Starting TSC Gen ...\n", __func__);
+
+	/* A generator must be idle (e.g. neither running nor waiting) before starting */
+	list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+		/* Try to free the gpio, so it can act as TSC */
+		gpio_free(generator->config.gpio_pinmux);
+		if (!cdi_tsc_generator_is_idle(generator)) {
+			dev_err(controller->dev, "Generator %s is not idle\n", generator->of->full_name);
+			return -EBUSY;
+		}
+	}
+
+	err = cdi_tsc_program_generator_edges(controller);
+	if (err != 0)
+		return err;
+
+	cdi_tsc_program_generator_start_values(controller);
+
+	/* Start the generators */
+	list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+		cdi_tsc_generator_writel(generator, TSC_GENX_CTRL,
+			TSC_GENX_CTRL_INITIAL_VAL | TSC_GENX_CTRL_ENABLE);
+	}
+
+	return 0;
+}
+
+static int cdi_tsc_stop_generators(struct tsc_signal_controller *controller)
+{
+	struct tsc_signal_generator *generator;
+
+	dev_info(controller->dev, "%s: TSC Gen Stop ...\n", __func__);
+	list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+		cdi_tsc_generator_writel(generator, TSC_GENX_CTRL, TSC_GENX_CTRL_RST);
+
+		/* Ensure the generator has stopped */
+		if (!cdi_tsc_generator_is_idle(generator)) {
+			dev_err(controller->dev, "Generator %s failed to stop\n",
+				generator->of->full_name);
+			return -EIO;
+		}
+		/* To avoid pin state in "high", When tsc gen stopped. Which inturn causes
+		 * inconsistency in sensor streaming */
+		gpio_request(generator->config.gpio_pinmux, "tsc-gen");
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static int cdi_tsc_debugfs_init(struct tsc_signal_controller *controller)
+{
+	struct tsc_signal_generator *generator;
+
+	controller->debugfs.d =
+		debugfs_create_dir(controller->dev->of_node->full_name, NULL);
+	if (IS_ERR(controller->debugfs.d))
+		return PTR_ERR(controller->debugfs.d);
+
+	list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+		generator->debugfs.regset_ro.regs = tsc_signal_generator_debugfs_regset;
+		generator->debugfs.regset_ro.nregs = TSC_SIG_GEN_DEBUGFS_REGSET_SIZE;
+		generator->debugfs.regset_ro.base = generator->base;
+
+		debugfs_create_regset32(
+				generator->of->full_name,
+				0400,
+				controller->debugfs.d,
+				&generator->debugfs.regset_ro);
+	}
+
+	return 0;
+}
+
+static void cdi_tsc_debugfs_remove(struct tsc_signal_controller *controller)
+{
+	debugfs_remove_recursive(controller->debugfs.d);
+	controller->debugfs.d = NULL;
+}
+#endif
+
+static void sync_enable_irq(void)
+{
+    if (cam_sync->irq_enabled == false)
+    {
+        enable_irq(cam_sync->irq);
+        cam_sync->irq_enabled = true;
+    }
+}
+
+static void sync_disable_irq(void)
+{
+    if (cam_sync->irq_enabled == true)
+    {
+        disable_irq(cam_sync->irq);
+        cam_sync->irq_enabled = false;
+    }
+}
+
+static int set_pwm_period(cam_sync_t *cam_sync, unsigned long period)
+{
+    int ret = 0;
+    struct pwm_state *state = &cam_sync->pwm_state;
+
+    mutex_lock(&cam_sync->lock);
+
+    if (period > cam_sync->pwm_state.duty_cycle)
+    {
+        state->enabled = true;
+    }
+    else
+    {
+        dev_err(cam_sync->dev, "pwm_period is too short\n");
+        goto exit_set_pwm_err;
+    }
+    state->period = period;
+    ret = pwm_apply_state(cam_sync->pwm, state);
+    if (ret)
+        dev_err(cam_sync->dev, "set pwm_period err \n");
+    else
+        cam_sync->pwm_period = period;
+    dev_info(cam_sync->dev, "set pwm_period to %lldns\n", state->period);
+exit_set_pwm_err:
+    mutex_unlock(&cam_sync->lock);
+    return ret;
+}
+
+static void cam_sync_stop(void)
+{
+    sync_disable_irq();
+
+    cdi_tsc_stop_generators(&cam_sync->controller);
+    if (cam_sync->trigger_type == GPIO_TRIGGER)
+        hrtimer_cancel(&cam_sync->trigger_timer);
+    else if (cam_sync->trigger_type == PWM_TRIGGER)
+        pwm_disable(cam_sync->pwm);
+    if (cam_sync->sync_in_gpios > 0 && cam_sync->sync_out_gpios > 0)
+        del_timer(&cam_sync->delay_timer);
+    if (cam_sync->sync_out_gpios > 0)
+        gpio_set_value(cam_sync->sync_out_gpios, 0);
+
+    dev_info(cam_sync->dev, "cam sync close\n");
+}
+
+static void cam_sync_set_mode(cs_param_t *param)
+{
+    struct tsc_signal_generator *generator;
+    unsigned long period;
+
+    if (cam_sync->sync_out_gpios > 0)
+        gpio_set_value(cam_sync->sync_out_gpios, 0);
+
+    if (m_lock == 1)
+    {
+        m_lock = 0;
+        del_timer(&cam_sync->delay_timer);
+    }
+
+    if (param->mode == MODE_SYNC_IN)
+    {
+        if (cam_sync->trigger_type == GPIO_TRIGGER)
+            hrtimer_cancel(&cam_sync->trigger_timer);
+        else if (cam_sync->trigger_type == PWM_TRIGGER)
+            pwm_disable(cam_sync->pwm);
+        sync_enable_irq();
+        dev_info(cam_sync->dev, "sync in trigger mode\n");
+    }
+    else
+    {
+        int offset = SYNC_HWTIMER_OFFSET_TIME;
+        int tsc_offset = SYNC_TSC_OFFSET_TIME;
+
+        switch (param->fps)
+        {
+        case 6000:
+            if (cam_sync->trigger_type == GPIO_TRIGGER)
+                offset = 30;
+            else if (cam_sync->trigger_type == PWM_TRIGGER)
+                offset = 50;
+            else
+                offset = 20;
+            tsc_offset = 20;
+            break;
+
+        case 3000:
+            offset = 100;
+            tsc_offset = 50;
+            break;
+
+        case 1500:
+            offset = 100;
+            tsc_offset = 50;
+            break;
+
+        case 2000:
+            offset = 65;
+            tsc_offset = 65;
+            break;
+
+        case 1000:
+            offset = 100;
+            tsc_offset = 50;
+            break;
+
+        case 600:
+            offset = 100;
+            tsc_offset = 50;
+            break;
+
+        case 500:
+            offset = 100;
+            tsc_offset = 50;
+            break;
+
+        default:
+            offset = SYNC_HWTIMER_OFFSET_TIME;
+            tsc_offset = SYNC_TSC_OFFSET_TIME;
+            break;
+        }
+        sync_disable_irq();
+        
+        list_for_each_entry(generator, &cam_sync->controller.generators, list) {
+            generator->config.freq_hz = (1000000 * TSC_FPS_SCALE) / (1000000 * FPS_SCALE / param->fps + tsc_offset);
+            dev_info(cam_sync->dev, "freq_hz:%d\n", generator->config.freq_hz);
+        }
+        cdi_tsc_start_generators(&cam_sync->controller);
+
+        cam_sync->ldelay = 1000000 * FPS_SCALE / param->fps - cam_sync->hdelay + offset; // us
+
+        if (cam_sync->trigger_type == GPIO_TRIGGER)
+        {
+            ktime_t kt = ktime_set(0, cam_sync->ldelay * 1000); // ns
+            cam_sync->is_high = 0;
+            hrtimer_start(&cam_sync->trigger_timer, kt, HRTIMER_MODE_REL_PINNED_HARD);
+        }
+        else if (cam_sync->trigger_type == PWM_TRIGGER)
+        {
+            period = (cam_sync->ldelay + cam_sync->hdelay) * 1000;
+            set_pwm_period(cam_sync, period);
+            // dev_info(cam_sync->dev, "sync out mode pwm_period :%ldns\n", period);
+        }
+    }
+}
+
+static ssize_t cam_sync_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+{
+    int ret;
+    // cam_sync_t *cam_sync = container_of(file->private_data, cam_sync_t, misc_dev);
+    dev_info(cam_sync->dev, "cam-sync read:%d, %d\n", cam_sync->param.mode, cam_sync->param.fps);
+
+    ret = copy_to_user(buf, &cam_sync->param, sizeof(cam_sync->param));
+    if (ret)
+    {
+        dev_info(cam_sync->dev, "copy_to_user err:%d\n", ret);
+        return ret;
+    }
+    return 0;
+}
+
+static ssize_t cam_sync_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
+{
+    // cam_sync_t *cam_sync = container_of(file->private_data, cam_sync_t, misc_dev);
+    cs_param_t param;
+    int ret = copy_from_user(&param, buf, sizeof(param));
+    if (ret)
+    {
+        dev_info(cam_sync->dev, "copy_from_user err:%d\n", ret);
+        return ret;
+    }
+    dev_info(cam_sync->dev, "cam-sync write:%d, %d\n", param.mode, param.fps);
+
+    if (param.mode > 2 || param.fps < 1 * FPS_SCALE || param.fps > 120 * FPS_SCALE) // 1~120fps
+        return -1;
+
+    cam_sync_set_mode(&param);
+    cam_sync->param = param;
+
+    return 0;
+}
+
+static long cam_sync_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    if (cmd == CAM_SYNC_START)
+    {
+        cs_param_t param;
+        int ret = copy_from_user(&param, (void *)arg, sizeof(param));
+        if (ret)
+        {
+            dev_info(cam_sync->dev, "copy_from_user err:%d\n", ret);
+            return ret;
+        }
+        cam_sync_set_mode(&param);
+        dev_info(cam_sync->dev, "cam sync start\n");
+    }
+    else if (cmd == CAM_SYNC_STOP)
+    {
+        cam_sync_stop();
+        dev_info(cam_sync->dev, "cam sync stop\n");
+    }
+    else
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int cam_sync_open(struct inode *inode, struct file *file)
+{
+    dev_info(cam_sync->dev, "cam sync open\n");
+    return 0;
+}
+
+static int cam_sync_release(struct inode *inode, struct file *file)
+{
+    // cam_sync_t *cam_sync = container_of(file->private_data, cam_sync_t, misc_dev);
+    cam_sync_stop();
+    return 0;
+}
+
+static const struct file_operations cam_sync_fops = {
+    .owner = THIS_MODULE,
+    .llseek = no_llseek,
+    .write = cam_sync_write,
+    .read = cam_sync_read,
+    .unlocked_ioctl = cam_sync_ioctl,
+    .open = cam_sync_open,
+    .release = cam_sync_release,
+};
+
+static enum hrtimer_restart cam_sync_hrtimer_irq(struct hrtimer *timer)
+{
+    ktime_t kt;
+
+    gpio_set_value(cam_sync->sync_out_gpios, cam_sync->is_high ? 1 : 0);
+
+    kt = ktime_set(0, (cam_sync->is_high ? cam_sync->hdelay : cam_sync->ldelay) * 1000); // ns
+    hrtimer_forward(timer, timer->base->get_time(), kt);                                 // hrtimer_forward(trigger_timer, now, tick_period);
+    cam_sync->is_high ^= 1;
+    dev_dbg(cam_sync->dev, "htim\n");
+    return HRTIMER_RESTART; // HRTIMER_NORESTART
+}
+
+static void cam_sync_in_timer_irq(struct timer_list *timer)
+{
+    gpio_set_value(cam_sync->sync_out_gpios, 0);
+    del_timer(timer);
+    m_lock = 0;
+    dev_dbg(cam_sync->dev, "tim\n");
+}
+
+static irqreturn_t cam_sync_in_trigger_irq(int irq, void *data)
+{
+    if (m_lock)
+        return IRQ_HANDLED;
+    m_lock = 1;
+
+    gpio_set_value(cam_sync->sync_out_gpios, 1);
+
+    dev_dbg(cam_sync->dev, "tri\n");
+
+    /* start trigger_timer */
+    cam_sync->delay_timer.expires = jiffies + DELAY_TIME;
+    add_timer(&cam_sync->delay_timer);
+
+    return IRQ_HANDLED;
+}
+
+static struct miscdevice csync_misc_device = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "camsync",
+    .fops = &cam_sync_fops,
+};
+
+static int obc_cam_sync_probe(struct platform_device *pdev)
+{
+    struct device *dev = &pdev->dev;
+	struct resource *res;
+    int err = 0;
+    struct device_node *node = dev->of_node;
+    cam_sync = devm_kzalloc(dev, sizeof(cam_sync_t), GFP_KERNEL);
+    if (!cam_sync)
+    {
+        dev_err(dev, "failed to malloc cam_sync_t\n");
+        return -ENOMEM;
+    }
+    mutex_init(&cam_sync->lock);
+    cam_sync->dev = dev;
+    cam_sync->controller.opened = false;
+	cam_sync->controller.dev = dev;
+
+    INIT_LIST_HEAD(&cam_sync->controller.generators);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	cam_sync->controller.base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(cam_sync->controller.base))
+		return PTR_ERR(cam_sync->controller.base);
+
+	err = cdi_tsc_find_and_add_generators(&cam_sync->controller);
+	if (err != 0)
+		return err;
+
+#ifdef CONFIG_DEBUG_FS
+	err = cdi_tsc_debugfs_init(&cam_sync->controller);
+	if (err != 0)
+		return err;
+#endif
+
+    cam_sync->sync_in_gpios = of_get_named_gpio(node, "sync-in-gpios", 0);
+    if (cam_sync->sync_in_gpios < 0)
+    {
+        dev_info(dev, "sync-in-gpios not found\n");
+    }
+
+    cam_sync->sync_out_gpios = of_get_named_gpio(node, "sync-out-gpios", 0);
+    if (cam_sync->sync_out_gpios < 0)
+    {
+        dev_info(dev, "sync-out-gpios not found\n");
+    }
+    else
+    {
+        gpio_request(cam_sync->sync_out_gpios, "sync-out");
+        gpio_direction_output(cam_sync->sync_out_gpios, 0);
+        cam_sync->hdelay = 1000;  // 1ms
+        cam_sync->ldelay = 32333; // 32.333ms
+        cam_sync->trigger_type = GPIO_TRIGGER;
+
+        hrtimer_init(&cam_sync->trigger_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_PINNED_HARD);
+        cam_sync->trigger_timer.function = cam_sync_hrtimer_irq;
+        hrtimer_cancel(&cam_sync->trigger_timer);
+    }
+
+    if (cam_sync->sync_in_gpios > 0 && cam_sync->sync_out_gpios > 0)
+    {
+        gpio_request(cam_sync->sync_in_gpios, "sync-in");
+        gpio_direction_input(cam_sync->sync_in_gpios);
+        cam_sync->irq = gpio_to_irq(cam_sync->sync_in_gpios);
+        dev_info(cam_sync->dev, "gpio to irq: %d -> %d\n", cam_sync->sync_in_gpios, cam_sync->irq);
+
+        // disable_irq(cam_sync->irq);
+        cam_sync->irq_enabled = false;
+        timer_setup(&cam_sync->delay_timer, cam_sync_in_timer_irq, 0);
+        err = request_irq(cam_sync->irq, cam_sync_in_trigger_irq, IRQF_TRIGGER_RISING, "cam_sync_in_trigger_irq", NULL);
+        if (err)
+        {
+            dev_info(cam_sync->dev, "failed to request cam_sync_in_trigger_irq\n");
+            return err;
+        }
+    }
+
+    cam_sync->pwm = devm_of_pwm_get(dev, dev->of_node, NULL);
+    if (IS_ERR(cam_sync->pwm))
+        dev_info(dev, "Could not get PWM\n");
+    else
+    {
+        cam_sync->trigger_type = PWM_TRIGGER;
+        pwm_init_state(cam_sync->pwm, &cam_sync->pwm_state);
+        cam_sync->pwm_state.duty_cycle = 1000000; // 1ms
+        pwm_apply_state(cam_sync->pwm, &cam_sync->pwm_state);
+    }
+    /*
+    if (cam_sync->sync_out_gpios < 0 && IS_ERR(cam_sync->pwm))
+        return -EINVAL;
+    */
+
+    platform_set_drvdata(pdev, cam_sync);
+
+    err = misc_register(&csync_misc_device);
+    if (err)
+    {
+        dev_info(cam_sync->dev, "misc_register failed\n");
+        return err;
+    }
+
+    dev_info(cam_sync->dev, "camsync misc register success!\n");
+
+    return 0;
+}
+
+static int obc_cam_sync_remove(struct platform_device *pdev)
+{
+    // misc_deregister(&cam_sync->misc_dev);
+    misc_deregister(&csync_misc_device);
+    cdi_tsc_debugfs_remove(&cam_sync->controller);
+    free_irq(cam_sync->irq, NULL);
+    if (cam_sync->sync_in_gpios > 0)
+        gpio_free(cam_sync->sync_in_gpios);
+    if (cam_sync->sync_out_gpios > 0)
+        gpio_free(cam_sync->sync_out_gpios);
+    if (cam_sync->pwm != NULL)
+        pwm_free(cam_sync->pwm);
+    kfree(cam_sync);
+    return 0;
+}
+
+static const struct of_device_id of_obc_cam_sync_match[] = {
+    {
+        .compatible = "orbbec,obc_cam_sync",
+    },
+    {},
+};
+MODULE_DEVICE_TABLE(of, of_obc_cam_sync_match);
+
+static struct platform_driver obc_cam_sync_driver = {
+    .probe = obc_cam_sync_probe,
+    .remove = obc_cam_sync_remove,
+    .driver = {
+        .name = "obc_cam_sync",
+        .of_match_table = of_obc_cam_sync_match,
+    },
+};
+
+module_platform_driver(obc_cam_sync_driver);
+
+MODULE_AUTHOR("xuanyuan@orbbec.com");
+MODULE_AUTHOR("yanxiao@orbbec.com");
+MODULE_DESCRIPTION(" orbbec mult-device-sync trigger");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h b/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
index e503f0af2..44e19735c 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
@@ -26,6 +26,7 @@ struct tegra_capture_ivc_cb_ctx {
 	tegra_capture_ivc_cb_func cb_func;
 	/** Private context of a VI/ISP capture context */
 	const void *priv_context;
+	struct semaphore sem_ch; //orbbec add
 };
 
 /**
diff --git a/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c b/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c
index 14e1ba3ee..223a960b7 100644
--- a/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c
+++ b/Linux_for_Tegra/source/nvidia-oot/drivers/platform/tegra/rtcpu/capture-ivc.c
@@ -22,6 +22,10 @@
 #include <trace/events/tegra_capture.h>
 
 #include "capture-ivc-priv.h"
+#include <linux/semaphore.h> //orbbec add
+
+/* Timeout for acquiring channel-id */
+#define TIMEOUT_ACQUIRE_CHANNEL_ID 120 //orbbec add
 
 static int tegra_capture_ivc_tx_(struct tegra_capture_ivc *civc,
 				const void *req, size_t len)
@@ -184,6 +188,10 @@ int tegra_capture_ivc_notify_chan_id(uint32_t chan_id, uint32_t trans_id)
 
 	civc = __scivc_control;
 
+    if (down_timeout(&civc->cb_ctx[chan_id].sem_ch, TIMEOUT_ACQUIRE_CHANNEL_ID)) { //orbbec add
+        return -EBUSY;
+    }
+
 	mutex_lock(&civc->cb_ctx_lock);
 
 	if (WARN(civc->cb_ctx[trans_id].cb_func == NULL,
@@ -278,6 +286,8 @@ int tegra_capture_ivc_unregister_control_cb(uint32_t id)
 
 	mutex_lock(&civc->cb_ctx_lock);
 
+	up(&civc->cb_ctx[id].sem_ch); //orbbec add
+
 	if (WARN(civc->cb_ctx[id].cb_func == NULL,
 			"control channel %u is idle", id)) {
 		mutex_unlock(&civc->cb_ctx_lock);
@@ -454,6 +464,8 @@ static int tegra_capture_ivc_probe(struct tegra_ivc_channel *chan)
 	mutex_init(&civc->cb_ctx_lock);
 	mutex_init(&civc->ivc_wr_lock);
 
+	for (i = 0; i < TOTAL_CHANNELS; i++) sema_init(&civc->cb_ctx[i].sem_ch, 1); //orbbec add
+
 	/* Initialize kworker */
 	kthread_init_work(&civc->work, tegra_capture_ivc_worker);
 
diff --git a/Linux_for_Tegra/source/nvidia-oot/include/media/gmsl-link.h b/Linux_for_Tegra/source/nvidia-oot/include/media/gmsl-link.h
index ad902d0a7..a32654fcf 100644
--- a/Linux_for_Tegra/source/nvidia-oot/include/media/gmsl-link.h
+++ b/Linux_for_Tegra/source/nvidia-oot/include/media/gmsl-link.h
@@ -40,6 +40,14 @@
 #define GMSL_CSI_DT_RAW_12 0x2C
 #define GMSL_CSI_DT_UED_U1 0x30
 #define GMSL_CSI_DT_EMBED 0x12
+#if 1 //orbbec add
+#define GMSL_CSI_DT_YUV422_8 0x1E
+#define GMSL_CSI_DT_RGB_888 0x24
+#define GMSL_CSI_DT_RAW_8 0x2A
+#endif
+/* orbbec add */
+#define GMSL_CSI_DT_RAW_10 0x2B
+#define GMSL_CSI_DT_RAW_14 0x2D
 
 #define GMSL_ST_ID_UNUSED 0xFF
 
diff --git a/Linux_for_Tegra/source/nvidia-oot/include/media/mc_common.h b/Linux_for_Tegra/source/nvidia-oot/include/media/mc_common.h
index 0408ba670..053de8bff 100644
--- a/Linux_for_Tegra/source/nvidia-oot/include/media/mc_common.h
+++ b/Linux_for_Tegra/source/nvidia-oot/include/media/mc_common.h
@@ -223,7 +223,24 @@ struct tegra_channel {
 	unsigned int gang_sizeimage;
 	unsigned int embedded_data_width;
 	unsigned int embedded_data_height;
-
+#if 1 //orbbec add
+	struct {
+		struct video_device *video;
+		struct mutex lock;
+		spinlock_t spin_lock;
+		struct vb2_queue queue;
+		/*FIXME: 16 is max queued metadata buffers
+		* define 16
+		*/
+		struct vb2_buffer *buffers[16];
+		unsigned int head;
+		unsigned int tail;
+		unsigned int num_buffers;
+		void *alloc_ctx;
+		struct media_pad pad;
+		struct v4l2_ctrl_handler ctrl_handler;
+	} embedded;
+#endif
 	DECLARE_BITMAP(fmts_bitmap, MAX_FORMAT_NUM);
 	atomic_t power_on_refcnt;
 	struct v4l2_fh *fh;
@@ -400,7 +417,9 @@ struct tegra_channel_buffer *dequeue_inflight(struct tegra_channel *chan);
 int tegra_channel_set_power(struct tegra_channel *chan, bool on);
 
 int tegra_channel_init_video(struct tegra_channel *chan);
+int tegra_channel_init_video_embedded(struct tegra_channel *chan); //orbbec add
 int tegra_channel_cleanup_video(struct tegra_channel *chan);
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan); //orbbec add
 
 struct tegra_vi_fops {
 	int (*vi_power_on)(struct tegra_channel *chan);
diff --git a/Linux_for_Tegra/source/nvidia-oot/include/media/obc_g300_priv.h b/Linux_for_Tegra/source/nvidia-oot/include/media/obc_g300_priv.h
new file mode 100644
index 000000000..69b38adbe
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/include/media/obc_g300_priv.h
@@ -0,0 +1,262 @@
+/*
+ * obc_g300_priv.h - Orbbec G300 camera driver
+ *
+ * Copyright (c) 2023-2025, ORBBEC CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _OBC_G300_PRIV_H_
+#define _OBC_G300_PRIV_H_
+
+
+#define CONFIG_TEGRA_CAMERA_PLATFORM  1
+
+//---------------------------------------------------------------------------
+#define MAX_I2C_PACKET_SIZE 	240
+
+#define ORB_FORMARS_MAX     	3
+#define ORB_RESOLUTIONS_MAX    	15
+
+struct orbbec_header {
+	u16 len;
+    u16 code;
+    u16 index;
+};
+
+struct orbbec_msg_body {
+	uint16_t res;
+	uint16_t prop_ver;
+    uint8_t  data[MAX_I2C_PACKET_SIZE - 4];
+};
+
+struct orbbec_msg_body1 {
+	uint16_t res;
+    uint8_t  data[MAX_I2C_PACKET_SIZE - 2];
+};
+
+struct orbbec_set_imu_cmd {
+	uint16_t prop_code0;
+	uint16_t prop_code1;
+	uint16_t value0;
+	uint16_t value1;
+};
+
+struct orbbec_set_stream_cmd {
+	uint8_t stream_type;
+	uint8_t res;
+	uint8_t format;
+	uint8_t fps;
+};
+
+struct orbbec_cmd {
+	struct orbbec_header header;
+	union {
+		uint8_t _data[MAX_I2C_PACKET_SIZE];
+        struct orbbec_msg_body msg_body;
+		struct orbbec_msg_body1 msg_body1;
+		struct orbbec_set_stream_cmd set_stream_cmd;
+		struct orbbec_set_imu_cmd set_imu_cmd;
+	};
+};
+
+struct orbbec_device_info {
+	uint16_t vid;
+	uint16_t pid;
+	uint8_t  sn[16];
+    uint8_t  asic_sn[16];
+	uint16_t video_type;
+	uint16_t sub_num;
+	uint32_t cam_num;
+};
+
+//---------------------------------------------------------------------------
+typedef enum {
+	ORB_CAM_DEPTH,
+	ORB_CAM_COLOR,
+	ORB_CAM_IR_L,
+	ORB_CAM_IR_R,
+	ORB_CAM_TYPE_COUNT,
+} orb_cam_type_e;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define orb_mux_subdev camera_common_data
+#else
+struct orb_mux_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct orb_resolution {
+	u16 width;
+	u16 height;
+	u8 n_framerates;
+	const u16 *framerates;
+};
+
+struct orb_format {
+	unsigned int n_resolutions;
+	struct orb_resolution *resolutions;
+	u32 mbus_code;
+	u8 data_type;
+};
+
+struct orb_sensor {
+	struct orb_mux_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct {
+		struct orb_format *format;
+		struct orb_resolution *resolution;
+		u16 framerate;
+	} config;
+	bool streaming;
+	/*struct orb_vchan *vchan;*/
+	struct orb_format *formats;
+	unsigned int n_formats;
+	s16 pipe_id;
+};
+
+
+struct orb_ctrls {
+	struct v4l2_ctrl_handler handler;
+	// struct {
+		struct v4l2_ctrl *log;
+		struct v4l2_ctrl *fw_version;
+		struct v4l2_ctrl *gvd;
+		struct v4l2_ctrl *get_depth_calib;
+		struct v4l2_ctrl *set_depth_calib;
+		struct v4l2_ctrl *get_coeff_calib;
+		struct v4l2_ctrl *set_coeff_calib;
+		struct v4l2_ctrl *ae_roi_get;
+		struct v4l2_ctrl *ae_roi_set;
+		struct v4l2_ctrl *ae_setpoint_get;
+		struct v4l2_ctrl *ae_setpoint_set;
+		struct v4l2_ctrl *erb;
+		struct v4l2_ctrl *ewb;
+		struct v4l2_ctrl *hwmc;
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+		/* in ORB manual gain only works with manual exposure */
+		struct v4l2_ctrl *gain;
+		struct v4l2_ctrl *backlight;
+		struct v4l2_ctrl *brightness;
+		struct v4l2_ctrl *contrast;
+		struct v4l2_ctrl *gamma;
+		struct v4l2_ctrl *hue;
+		struct v4l2_ctrl *saturation;
+		struct v4l2_ctrl *sharpness;
+		struct v4l2_ctrl *whitebalance;
+		struct v4l2_ctrl *autowhitebalance;
+		struct v4l2_ctrl *powerlinefreq;
+		struct v4l2_ctrl *aepriority;
+		//struct v4l2_ctrl *focus_absolute;
+
+		struct v4l2_ctrl *set_date;
+		struct v4l2_ctrl *reset_device_link;
+		struct v4l2_ctrl *reset_device;
+		struct v4l2_ctrl *pps_trigger;
+		struct v4l2_ctrl *set_datelen;
+		struct v4l2_ctrl *get_date;
+		struct v4l2_ctrl *get_pid_sn;
+		struct v4l2_ctrl *get_version;
+		struct v4l2_ctrl *get_imu_fps;
+		//struct v4l2_ctrl *get_imu_stock;
+		struct v4l2_ctrl *get_imu_data;
+		struct v4l2_ctrl *get_link_state;
+		struct v4l2_ctrl *get_metadata_place;
+	// };
+};
+
+struct max_reg_pair {
+	u16 addr;
+	u8 val;
+};
+
+struct orb_deser_ops {
+	int (*init)(struct device *dev);
+	u8 (*get_link_map)(struct device *dev);
+	u8 (*get_link_init_flag)(struct device *dev);
+	int (*init_tx_gpio)(struct device *dev);
+	void (*set_link_init_flag)(struct device *dev, u8 link);
+	int (*get_link_state)(struct device *dev, u8 link_id, int *value);
+	int (*get_available_pipe)(struct device *dev, int dst_vc_id);
+	int (*set_pipe)(struct device *dev, u8 link_id, u8 pipe_id,
+		    		 u8 data_type1, u8 data_type2, u8 src_vc_id, u8 dst_vc_id);
+	u8 (*check_pipe_lock)(struct device *dev);
+	int (*release_pipe)(struct device *dev, u8 link_id, u8 pipe_id);
+	int (*power_on)(struct device *dev);
+	void (*power_off)(struct device *dev);
+	int (*reset_dev)(struct device *dev);
+	int (*write_seri_reg)(struct device *dev, u8 link_id, u16 addr, u8 val);
+	int (*write_seri_tab)(struct device *dev, u8 link_id, struct max_reg_pair buf[], u16 size);
+	int (*write_sensor)(struct device *dev, u8 link_id, void *data, u16 length);
+	int (*read_sensor)(struct device *dev, u8 link_id, void *data, u16 length);
+	int (*reset_oneshot)(struct device *dev);
+};
+
+struct orb {
+	struct orb_sensor sensor;
+	struct orb_resolution orb_depth_sizes[ORB_FORMARS_MAX][ORB_RESOLUTIONS_MAX];
+	struct orb_resolution orb_mono_sizes[ORB_FORMARS_MAX][ORB_RESOLUTIONS_MAX];
+	struct orb_resolution orb_rgb_sizes[ORB_FORMARS_MAX][ORB_RESOLUTIONS_MAX];
+	struct orb_resolution orb_default_sizes[ORB_FORMARS_MAX][ORB_RESOLUTIONS_MAX];
+	struct orb_format orb_depth_formats[ORB_FORMARS_MAX];
+	struct orb_format orb_default_formats[ORB_FORMARS_MAX];
+	struct orb_format orb_mono_formats[ORB_FORMARS_MAX];
+	struct orb_format orb_rgb_formats[ORB_FORMARS_MAX];
+	struct orb_ctrls ctrls;
+	struct i2c_client *client;
+	/* All below pointers are used for writing, cannot be const */
+	struct mutex lock;
+	struct regmap *regmap;
+	struct regulator *vcc;
+	//const struct orb_variant *variant;
+	struct device *dser_dev;
+	const struct orb_deser_ops *deser_ops;
+
+	struct orbbec_device_info device_info;
+	u8 src_vc; //source vc id, form max9295d
+	u8 dst_vc; //destination vc id, to max9296
+	u8 dser_link; //max9296 link port A,B,C,D
+	// u8 dev_real_addr;  //g3xx sensor real address, 0x66
+	// u8 dev_proxy_addr; //sensor proxy address, 0x1a/0x1b -> 0x66
+	orb_cam_type_e cam_type;
+	u16 imu_fps;
+	u8 embedded_metadata_height;
+	int pps_gpios;
+	int orb_depth_formats_num;
+	int orb_default_formats_num;
+	int orb_mono_formats_num;
+	int orb_rgb_formats_num;
+};
+
+//---------------------------------------------------------------------------
+int max9295d_set_pipe(struct orb *state, u8 link_id, u8 pipe_id, u8 data_type1, u8 data_type2, u8 src_vc_id);
+int max9295d_release_pipe(struct orb *state, u8 pipe_id);
+int max9295d_init_settings(struct orb *state, u8 link_id);
+int max9295d_set_orbbec_on(struct orb *state, u8 link_id);
+int max9295d_set_orbbec_off(struct orb *state, u8 link_id);
+
+int orbbec_reset_device_link(struct orb *state, s32 value);
+
+//---------------------------------------------------------------------------
+int orbbec_get_frame_profile_data(struct orb *state, void * data, int offset, int length);
+int orbbec_get_frame_profile_len(struct orb *state, void * data);
+int orbbec_get_deviceinfo(struct orb *state, void *pid, void *sn, void *asic_sn);
+int sensor_stream_opt(struct orb *state, struct orbbec_set_stream_cmd *strcmd, int on);
+
+int orb_ctrl_init(struct orb *state);
+int orbbec_set_metadata_place(struct orb *state, u8 data);
+int orbbec_get_metadata_place(struct orb *state, u8 *data);
+#endif
\ No newline at end of file
diff --git a/Linux_for_Tegra/source/nvidia-oot/include/media/obc_max9296.h b/Linux_for_Tegra/source/nvidia-oot/include/media/obc_max9296.h
new file mode 100644
index 000000000..12fc8894a
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/include/media/obc_max9296.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2018-2023, NVIDIA CORPORATION & AFFILIATES. All rights reserved. */
+
+/**
+ * @file
+ * <b>max9296a API: For Maxim Integrated max9296a deserializer</b>
+ *
+ * @b Description: Defines elements used to set up and use a
+ *  Maxim Integrated max9296a deserializer.
+ */
+
+#ifndef __OBC_MAX9296_H__
+#define __OBC_MAX9296_H__
+
+#include <linux/types.h>
+#include <media/gmsl-link.h>
+#include <media/obc_g300_priv.h>
+
+int max9296a_write_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 val);
+int max9296a_write_tab_with_addr(struct device *dev, u8 i2c_addr, struct max_reg_pair tab[], u16 size);
+int max9296a_read_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 *val);
+
+int max9296a_write_seri_reg(struct device *dev, u8 link_id, u16 addr, u8 val);
+int max9296a_write_seri_tab(struct device *dev, u8 link_id, struct max_reg_pair buf[], u16 size);
+
+int max9296a_write_sensor(struct device *dev, u8 link_id, void *data, u16 length);
+int max9296a_read_sensor(struct device *dev, u8 link_id, void *data, u16 length);
+
+
+int max9296a_init_settings(struct device *dev);
+int max9296a_reset_dev(struct device *dev);
+int max9296a_set_pipe(struct device *dev, u8 link_id, u8 pipe_id, u8 data_type1, u8 data_type2, u8 srcvc_id, u8 dstvc_id);
+
+int max9296a_link_pipe_bind(struct device *dev, u8 link_id, u8 pipe_id, u8 seri_pipe_id);
+
+u8 max9296a_get_link_map(struct device *dev);
+u8 max9296a_check_pipe_lock(struct device *dev);
+
+int max9296a_power_on(struct device *dev);
+void max9296a_power_off(struct device *dev);
+
+int max9296a_get_link_state(struct device *dev, u8 link_id, int *value);
+int max9296a_get_available_pipe_id(struct device *dev, int dst_vc_id);
+int max9296a_release_pipe(struct device *dev, u8 link_id, u8 pipe_id);
+u8 max9296a_get_link_init_flag(struct device *dev);
+void max9296a_set_link_init_flag(struct device *dev, u8 link);
+int max9296a_init_tx_gpio(struct device *dev);
+
+int max9296a_reset_oneshot(struct device *dev);
+
+/** @} */
+
+#endif  /* __max9296a_H__ */
diff --git a/Linux_for_Tegra/source/nvidia-oot/include/media/obc_max96712.h b/Linux_for_Tegra/source/nvidia-oot/include/media/obc_max96712.h
new file mode 100644
index 000000000..c056cdff7
--- /dev/null
+++ b/Linux_for_Tegra/source/nvidia-oot/include/media/obc_max96712.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2018-2023, NVIDIA CORPORATION & AFFILIATES. All rights reserved. */
+
+/**
+ * @file
+ * <b>max96712 API: For Maxim Integrated max96712 deserializer</b>
+ *
+ * @b Description: Defines elements used to set up and use a
+ *  Maxim Integrated max96712 deserializer.
+ */
+
+#ifndef __OBC_MAX96712_H__
+#define __OBC_MAX96712_H__
+
+#include <linux/types.h>
+#include <media/gmsl-link.h>
+#include <media/obc_g300_priv.h>
+
+int max96712_write_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 val);
+int max96712_write_tab_with_addr(struct device *dev, u8 i2c_addr, struct max_reg_pair tab[], u16 size);
+int max96712_read_reg_with_addr(struct device *dev, u8 i2c_addr, u16 addr, u8 *val);
+
+int max96712_write_seri_reg(struct device *dev, u8 link_id, u16 addr, u8 val);
+int max96712_write_seri_tab(struct device *dev, u8 link_id, struct max_reg_pair buf[], u16 size);
+
+int max96712_write_sensor(struct device *dev, u8 link_id, void *data, u16 length);
+int max96712_read_sensor(struct device *dev, u8 link_id, void *data, u16 length);
+
+
+int max96712_init_settings(struct device *dev);
+int max96712_reset_dev(struct device *dev);
+int max96712_set_pipe(struct device *dev, u8 link_id, u8 pipe_id, u8 data_type1, u8 data_type2, u8 srcvc_id, u8 dstvc_id);
+
+int max96712_link_pipe_bind(struct device *dev, u8 link_id, u8 pipe_id, u8 seri_pipe_id);
+
+u8 max96712_get_link_map(struct device *dev);
+u8 max96712_check_pipe_lock(struct device *dev);
+
+int max96712_power_on(struct device *dev);
+void max96712_power_off(struct device *dev);
+
+int max96712_get_link_state(struct device *dev, u8 link_id, int *value);
+int max96712_get_available_pipe_id(struct device *dev, int dst_vc_id);
+int max96712_release_pipe(struct device *dev, u8 link_id, u8 pipe_id);
+void max96712_set_link_init_flag(struct device *dev, u8 link);
+u8 max96712_get_link_init_flag(struct device *dev);
+int max96712_init_tx_gpio(struct device *dev);
+
+int max96712_reset_oneshot(struct device *dev);
+
+/** @} */
+
+#endif  /* __max96712_H__ */
diff --git a/Linux_for_Tegra/source/nvidia-oot/include/media/tegra_camera_core.h b/Linux_for_Tegra/source/nvidia-oot/include/media/tegra_camera_core.h
index e6d9a2b1c..29563adec 100644
--- a/Linux_for_Tegra/source/nvidia-oot/include/media/tegra_camera_core.h
+++ b/Linux_for_Tegra/source/nvidia-oot/include/media/tegra_camera_core.h
@@ -18,7 +18,7 @@
 /* Width alignment */
 #define TEGRA_WIDTH_ALIGNMENT	1
 /* Stride alignment */
-#define TEGRA_STRIDE_ALIGNMENT	1
+#define TEGRA_STRIDE_ALIGNMENT	64 //1, orbbec modify
 /* Height alignment */
 #define TEGRA_HEIGHT_ALIGNMENT	1
 /* Size alignment */
@@ -32,6 +32,8 @@
 #define TEGRA_IMAGE_FORMAT_DEF	32
 
 enum tegra_image_dt {
+	//TEGRA_IMAGE_DT_EMBEDDED_8 = 18, //orbbec add
+
 	TEGRA_IMAGE_DT_YUV420_8 = 24,
 	TEGRA_IMAGE_DT_YUV420_10,
 
@@ -51,6 +53,7 @@ enum tegra_image_dt {
 	TEGRA_IMAGE_DT_RAW10,
 	TEGRA_IMAGE_DT_RAW12,
 	TEGRA_IMAGE_DT_RAW14,
+
 };
 
 /* Supported CSI to VI Data Formats */
